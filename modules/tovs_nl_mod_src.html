<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>tovs_nl_mod source &mdash; MIDAS  documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="MIDAS  documentation" href="../index.html" /> 
  </head>
  <body>
  <div>
    <img src="../_static/MIDAS_header.png" alt="MIDAS" />
  </div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li><a href="../index.html">MIDAS  documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/tovs_nl_mod_src.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <section id="tovs-nl-mod-source">
<h1>tovs_nl_mod source<a class="headerlink" href="#tovs-nl-mod-source" title="Permalink to this headline">Â¶</a></h1>
<blockquote>
<div><div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="linenos">   1</span>!--------------------------------------- LICENCE BEGIN -----------------------------------
<span class="linenos">   2</span>!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
<span class="linenos">   3</span>!                     version 3; Last Modified: May 7, 2008.
<span class="linenos">   4</span>!This is free but copyrighted software; you can use/redistribute/modify it under the terms
<span class="linenos">   5</span>!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
<span class="linenos">   6</span>!version 3 or (at your option) any later version that should be found at:
<span class="linenos">   7</span>!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
<span class="linenos">   8</span>!
<span class="linenos">   9</span>!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
<span class="linenos">  10</span>!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
<span class="linenos">  11</span>!See the above mentioned License/Disclaimer for more details.
<span class="linenos">  12</span>!You should have received a copy of the License/Disclaimer along with this software;
<span class="linenos">  13</span>!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
<span class="linenos">  14</span>!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
<span class="linenos">  15</span>!-------------------------------------- LICENCE END --------------------------------------
<span class="linenos">  16</span>
<span class="linenos">  17</span>module tovs_nl_mod
<span class="linenos">  18</span>  ! MODULE tovs_nl (prefix=&#39;tvs&#39; category=&#39;5. Observation operators&#39;)
<span class="linenos">  19</span>  !
<span class="linenos">  20</span>  !:Purpose: Derived types, public variables and procedures related to the
<span class="linenos">  21</span>  !           nonlinear version of RTTOV
<span class="linenos">  22</span>  !
<span class="linenos">  23</span>
<span class="linenos">  24</span>  use rttov_interfaces_mod
<span class="linenos">  25</span>  use rttov_types, only :   &amp;
<span class="linenos">  26</span>       rttov_coefs         ,&amp;
<span class="linenos">  27</span>       rttov_fast_coef     ,&amp;
<span class="linenos">  28</span>       rttov_scatt_coef    ,&amp;
<span class="linenos">  29</span>       rttov_options       ,&amp;
<span class="linenos">  30</span>       rttov_options_scatt ,&amp;
<span class="linenos">  31</span>       rttov_profile       ,&amp;
<span class="linenos">  32</span>       rttov_profile_cloud ,&amp;
<span class="linenos">  33</span>       rttov_radiance      ,&amp;
<span class="linenos">  34</span>       rttov_transmission  ,&amp;
<span class="linenos">  35</span>       rttov_chanprof      ,&amp;
<span class="linenos">  36</span>       rttov_emissivity
<span class="linenos">  37</span>
<span class="linenos">  38</span>  use rttov_const, only :           &amp;
<span class="linenos">  39</span>       platform_name               ,&amp;
<span class="linenos">  40</span>       nplatforms                  ,&amp;
<span class="linenos">  41</span>       inst_name                   ,&amp;
<span class="linenos">  42</span>       ninst                       ,&amp;
<span class="linenos">  43</span>       inst_id_goesim              ,&amp;
<span class="linenos">  44</span>       inst_id_gmsim               ,&amp;
<span class="linenos">  45</span>       inst_id_mtsatim             ,&amp;
<span class="linenos">  46</span>       inst_id_amsua               ,&amp;
<span class="linenos">  47</span>       inst_id_mhs                 ,&amp;
<span class="linenos">  48</span>       sensor_id_mw                ,&amp;
<span class="linenos">  49</span>       sensor_id_po                ,&amp;
<span class="linenos">  50</span>       platform_id_jpss            ,&amp;
<span class="linenos">  51</span>       platform_id_himawari        ,&amp;
<span class="linenos">  52</span>       platform_id_eos             ,&amp;
<span class="linenos">  53</span>       errorstatus_success         ,&amp;
<span class="linenos">  54</span>       mair, mh2o, mo3             ,&amp;
<span class="linenos">  55</span>       surftype_land               ,&amp;
<span class="linenos">  56</span>       surftype_seaice             ,&amp;
<span class="linenos">  57</span>       surftype_sea                ,&amp;
<span class="linenos">  58</span>       watertype_ocean_water       ,&amp;
<span class="linenos">  59</span>       ngases_max                  ,&amp;
<span class="linenos">  60</span>       gas_id_mixed                ,&amp;
<span class="linenos">  61</span>       gas_unit_specconc           ,&amp;
<span class="linenos">  62</span>       interp_rochon_loglinear_wfn ,&amp;
<span class="linenos">  63</span>       zenmax                      ,&amp;
<span class="linenos">  64</span>       zenmaxv9                    ,&amp;
<span class="linenos">  65</span>       o3min                       ,&amp;
<span class="linenos">  66</span>       o3max                       ,&amp;
<span class="linenos">  67</span>       tmin                        ,&amp;
<span class="linenos">  68</span>       tmax                        ,&amp;
<span class="linenos">  69</span>       qmin                        ,&amp;
<span class="linenos">  70</span>       qmax                        ,&amp;
<span class="linenos">  71</span>       elevmax                     ,&amp;
<span class="linenos">  72</span>       wmax                        ,&amp;
<span class="linenos">  73</span>       pmin                        ,&amp;
<span class="linenos">  74</span>       pmax
<span class="linenos">  75</span>
<span class="linenos">  76</span>  use parkind1, only : jpim, jplm
<span class="linenos">  77</span>
<span class="linenos">  78</span>  use rttov_fast_coef_utils_mod, only: set_pointers, set_fastcoef_level_bounds
<span class="linenos">  79</span>  use rttov_solar_refl_mod, only : rttov_refl_water_interp
<span class="linenos">  80</span>
<span class="linenos">  81</span>  use midasMpi_mod
<span class="linenos">  82</span>  use codtyp_mod
<span class="linenos">  83</span>  use mpi
<span class="linenos">  84</span>  use utilities_mod
<span class="linenos">  85</span>  use obsSpaceData_mod
<span class="linenos">  86</span>  use earthConstants_mod
<span class="linenos">  87</span>  use MathPhysConstants_mod
<span class="linenos">  88</span>  use ozoneclim_mod
<span class="linenos">  89</span>  use columnData_mod 
<span class="linenos">  90</span>  use mod_rttov_emis_atlas
<span class="linenos">  91</span>  use verticalCoord_mod
<span class="linenos">  92</span>  use codePrecision_mod
<span class="linenos">  93</span>  use humidityLimits_mod
<span class="linenos">  94</span>  use interpolation_mod
<span class="linenos">  95</span>
<span class="linenos">  96</span>  implicit none
<span class="linenos">  97</span>  save
<span class="linenos">  98</span>  private
<span class="linenos">  99</span>
<span class="linenos"> 100</span>  type surface_params
<span class="linenos"> 101</span>    real(8)              :: albedo   ! surface albedo (0-1)
<span class="linenos"> 102</span>    real(8)              :: ice      ! ice cover (0-1) 
<span class="linenos"> 103</span>    real(8)              :: snow     ! snow cover (0-1)
<span class="linenos"> 104</span>    real(8)              :: pcnt_wat ! water percentage in pixel containing profile (0-1)
<span class="linenos"> 105</span>    real(8)              :: pcnt_reg ! water percentage in an area around profile (0-1)
<span class="linenos"> 106</span>    integer              :: ltype    ! surface type (1,...,20)
<span class="linenos"> 107</span>  end type surface_params
<span class="linenos"> 108</span>
<span class="linenos"> 109</span>  ! public variables (parameters)
<span class="linenos"> 110</span>  public :: tvs_maxChannelNumber, tvs_maxNumberOfChannels, tvs_maxNumberOfSensors, tvs_defaultEmissivity
<span class="linenos"> 111</span>  ! public variables (non-parameters)
<span class="linenos"> 112</span>  public :: tvs_nchan, tvs_ichan, tvs_lsensor, tvs_headerIndex, tvs_tovsIndex, tvs_nobtov
<span class="linenos"> 113</span>  public :: tvs_nchanMpiGlobal, tvs_ichanMpiGlobal
<span class="linenos"> 114</span>  public :: tvs_isReallyPresent,tvs_listSensors
<span class="linenos"> 115</span>  public :: tvs_isReallyPresentMpiGlobal
<span class="linenos"> 116</span>  public :: tvs_nsensors, tvs_platforms, tvs_satellites, tvs_instruments, tvs_channelOffset
<span class="linenos"> 117</span>  public :: tvs_debug, tvs_satelliteName, tvs_instrumentName, tvs_useO3Climatology
<span class="linenos"> 118</span>  public :: tvs_coefs, tvs_opts, tvs_transmission,tvs_emissivity
<span class="linenos"> 119</span>  public :: tvs_coef_scatt, tvs_opts_scatt
<span class="linenos"> 120</span>  public :: tvs_radiance, tvs_surfaceParameters
<span class="linenos"> 121</span>  public :: tvs_numMWInstrumUsingCLW, tvs_numMWInstrumUsingHydrometeors
<span class="linenos"> 122</span>  public :: tvs_mwInstrumUsingCLW_tl, tvs_mwInstrumUsingHydrometeors_tl
<span class="linenos"> 123</span>  public :: tvs_mwAllskyAssim
<span class="linenos"> 124</span>  ! public procedures
<span class="linenos"> 125</span>  public :: tvs_fillProfiles, tvs_rttov, tvs_printDetailledOmfStatistics, tvs_allocTransmission, tvs_cleanup
<span class="linenos"> 126</span>  public :: tvs_deallocateProfilesNlTlAd
<span class="linenos"> 127</span>  public :: tvs_setupAlloc,tvs_setup, tvs_isIdBurpTovs, tvs_isIdBurpHyperSpectral, tvs_isIdBurpInst, tvs_getAllIdBurpTovs
<span class="linenos"> 128</span>  public :: tvs_isInstrumGeostationary,  tvs_isNameHyperSpectral
<span class="linenos"> 129</span>  public :: tvs_isNameGeostationary
<span class="linenos"> 130</span>  public :: tvs_getInstrumentId, tvs_getPlatformId, tvs_mapSat, tvs_mapInstrum
<span class="linenos"> 131</span>  public :: tvs_isInstrumHyperSpectral, tvs_getChanprof, tvs_countRadiances
<span class="linenos"> 132</span>  public :: tvs_ChangedStypValue
<span class="linenos"> 133</span>  public :: tvs_getHIREmissivities, tvs_getOtherEmissivities, tvs_rttov_read_coefs
<span class="linenos"> 134</span>  public :: tvs_getLocalChannelIndexFromChannelNumber
<span class="linenos"> 135</span>  public :: tvs_getMWemissivityFromAtlas, tvs_getProfile
<span class="linenos"> 136</span>  public :: tvs_getCorrectedSatelliteAzimuth
<span class="linenos"> 137</span>  public :: tvs_isInstrumUsingCLW, tvs_isInstrumUsingHydrometeors, tvs_getChannelNumIndexFromPPP
<span class="linenos"> 138</span>  public :: tvs_isInstrumAllskyTtAssim, tvs_isInstrumAllskyHuAssim
<span class="linenos"> 139</span>  ! Module parameters
<span class="linenos"> 140</span>  ! units conversion from  mixing ratio to ppmv and vice versa
<span class="linenos"> 141</span>  real(8), parameter :: qMixratio2ppmv  = (1000000.0d0 * mair) / mh2o
<span class="linenos"> 142</span>  real(8), parameter :: qppmv2Mixratio  = mh2o / (1000000.0d0 * mair)
<span class="linenos"> 143</span>  real(8), parameter :: o3Mixratio2ppmv = (1000000.0d0 * mair) / mo3
<span class="linenos"> 144</span>  real(8), parameter :: o3ppmv2Mixratio = mo3 / (1000000.0d0 * mair)
<span class="linenos"> 145</span>  real(pre_obsReal), parameter :: tvs_defaultEmissivity = 0.95
<span class="linenos"> 146</span>
<span class="linenos"> 147</span>  integer, parameter :: tvs_maxChannelNumber   = 8461   ! Max. value for channel number
<span class="linenos"> 148</span>  integer, parameter :: tvs_maxNumberOfChannels = 2211  ! Max. no. of channels (for one profile/spectra)
<span class="linenos"> 149</span>  integer, parameter :: tvs_maxNumberOfSensors  = 100   ! Max no sensors to be used
<span class="linenos"> 150</span>  integer, parameter :: tvs_nlevels     = 101           ! Maximum No. of RTTOV pressure levels including &#39;rttov top&#39; at 0.005 hPa
<span class="linenos"> 151</span>
<span class="linenos"> 152</span>  ! Module variables
<span class="linenos"> 153</span>  integer, allocatable :: tvs_bodyIndexFromBtIndex(:)  ! Provides the bodyIndex in ObsSpaceData based on btIndex
<span class="linenos"> 154</span>  integer, allocatable :: tvs_nchan(:)             ! Number of channels per instrument (local)
<span class="linenos"> 155</span>  integer, allocatable :: tvs_ichan(:,:)           ! List of channels per instrument (local)
<span class="linenos"> 156</span>  integer, allocatable :: tvs_nchanMpiGlobal(:)     ! Number of channels per instrument (global)
<span class="linenos"> 157</span>  integer, allocatable :: tvs_ichanMpiGlobal(:,:)  ! List of channels per instrument  (global)
<span class="linenos"> 158</span>  integer, allocatable :: tvs_lsensor(:)           ! Sensor number for each profile
<span class="linenos"> 159</span>  integer, allocatable :: tvs_headerIndex (:)      ! Observation position in obsSpaceData header for each profile
<span class="linenos"> 160</span>  integer, allocatable :: tvs_tovsIndex (:)        ! Index in TOVS structures for each observation header in obsSpaceData
<span class="linenos"> 161</span>  logical, allocatable :: tvs_isReallyPresent(:)   ! Logical flag to identify instruments really assimilated (local)
<span class="linenos"> 162</span>  logical, allocatable :: tvs_isReallyPresentMpiGLobal(:)   ! Logical flag to identify instruments really assimilated (global)
<span class="linenos"> 163</span>  integer, allocatable :: tvs_listSensors(:,:)     ! Sensor list
<span class="linenos"> 164</span>  type (rttov_emis_atlas_data), allocatable :: tvs_atlas(:)     ! Emissivity atlases
<span class="linenos"> 165</span>  type(surface_params), allocatable :: tvs_surfaceParameters(:) ! surface parameters 
<span class="linenos"> 166</span>  integer tvs_nobtov                               ! Number of tovs observations
<span class="linenos"> 167</span>  integer tvs_nsensors                             ! Number of individual sensors.
<span class="linenos"> 168</span>  integer tvs_platforms(tvs_maxNumberOfSensors)    ! RTTOV platform ID&#39;s (e.g., 1=NOAA; 2=DMSP; ...)
<span class="linenos"> 169</span>  integer tvs_satellites(tvs_maxNumberOfSensors)   ! RTTOV satellite ID&#39;s (e.g., 1 to 16 for NOAA; ...)
<span class="linenos"> 170</span>  integer tvs_instruments(tvs_maxNumberOfSensors)  ! RTTOVinstrument ID&#39;s (e.g., 3=AMSU-A; 4=AMSU-B; 6=SSMI; ...)
<span class="linenos"> 171</span>  integer tvs_channelOffset(tvs_maxNumberOfSensors)! BURP to RTTOV channel mapping offset
<span class="linenos"> 172</span>  integer instrumentIdsUsingCLW(tvs_maxNumberOfSensors)
<span class="linenos"> 173</span>  integer instrumentIdsUsingHydrometeors(tvs_maxNumberOfSensors)
<span class="linenos"> 174</span>  integer tvs_numMWInstrumUsingCLW 
<span class="linenos"> 175</span>  integer tvs_numMWInstrumUsingHydrometeors
<span class="linenos"> 176</span>  logical tvs_mwInstrumUsingCLW_tl
<span class="linenos"> 177</span>  logical tvs_mwInstrumUsingHydrometeors_tl
<span class="linenos"> 178</span>  logical tvs_mwAllskyAssim
<span class="linenos"> 179</span>  logical :: tvs_mpiTask0ReadCoeffs 
<span class="linenos"> 180</span>  real(8) :: tvs_cloudScaleFactor 
<span class="linenos"> 181</span>  logical tvs_debug                                ! Logical key controlling statements to be  executed while debugging TOVS only
<span class="linenos"> 182</span>  logical tvs_useO3Climatology                     ! Determine if ozone model field or climatology is used
<span class="linenos"> 183</span>                                                   ! If ozone model field is specified, related increments will be generated in assimilation
<span class="linenos"> 184</span>  logical tvs_regLimitExtrap                       ! use RTTOV reg_limit_extrap option
<span class="linenos"> 185</span>  logical tvs_doAzimuthCorrection(tvs_maxNumberOfSensors)
<span class="linenos"> 186</span>  logical tvs_isAzimuthValid(tvs_maxNumberOfSensors)
<span class="linenos"> 187</span>  logical tvs_userDefinedDoAzimuthCorrection
<span class="linenos"> 188</span>  logical tvs_userDefinedIsAzimuthValid
<span class="linenos"> 189</span>
<span class="linenos"> 190</span>  character(len=15) tvs_satelliteName(tvs_maxNumberOfSensors)
<span class="linenos"> 191</span>  character(len=15) tvs_instrumentName(tvs_maxNumberOfSensors)
<span class="linenos"> 192</span>  character(len=8) radiativeTransferCode           ! RadiativeTransferCode : TOVS radiation model used
<span class="linenos"> 193</span>  real(8), allocatable :: tvs_emissivity(:,:)      ! Surface emissivities organized by profiles and channels
<span class="linenos"> 194</span>  integer, parameter :: kslon=2160, kslat=1080     ! CERES file dimension in grid points
<span class="linenos"> 195</span>
<span class="linenos"> 196</span>  ! High resolution surface fields
<span class="linenos"> 197</span>  integer :: surfaceType(kslon,kslat)  
<span class="linenos"> 198</span>  real(8) :: waterFraction(kslon,kslat) 
<span class="linenos"> 199</span>
<span class="linenos"> 200</span>  ! Derived typeso
<span class="linenos"> 201</span>  type(rttov_coefs), allocatable           :: tvs_coefs(:)          ! rttov coefficients
<span class="linenos"> 202</span>  type(rttov_options), allocatable         :: tvs_opts(:)           ! rttov options
<span class="linenos"> 203</span>  type(rttov_scatt_coef),allocatable       :: tvs_coef_scatt(:)     ! rttovscatt coefficients
<span class="linenos"> 204</span>  type(rttov_options_scatt), allocatable   :: tvs_opts_scatt(:)     ! rttovscatt options
<span class="linenos"> 205</span>  type(rttov_profile), target, allocatable :: tvs_profiles_nl(:)    ! all profiles on trial vertical coordinate for nl obs operator
<span class="linenos"> 206</span>  type(rttov_profile), target, allocatable :: tvs_profiles_tlad(:)  ! all profiles on increments vertical coordinates for linearized obs. operator
<span class="linenos"> 207</span>  type(rttov_radiance), allocatable        :: tvs_radiance(:)       ! radiances organized by profile
<span class="linenos"> 208</span>  type(rttov_transmission), allocatable    :: tvs_transmission(:)   ! transmittances all profiles for HIR quality control
<span class="linenos"> 209</span>  type(rttov_profile_cloud), target, allocatable :: tvs_cld_profiles_nl(:)! rttov scatt cloud profiles on trial vertical coordinate
<span class="linenos"> 210</span>  type(rttov_profile_cloud), target, allocatable :: tvs_cld_profiles_tlad(:) ! rttov scatt cloud profiles on increment vertical coordinates
<span class="linenos"> 211</span>
<span class="linenos"> 212</span>  ! Namelist variables:
<span class="linenos"> 213</span>  logical useUofWIREmiss                           ! Flag to activate use of RTTOV U of W IR emissivity Atlases
<span class="linenos"> 214</span>  logical useMWEmissivityAtlas                     ! Flag to activate use of RTTOV built-in MW emissivity Atlases      
<span class="linenos"> 215</span>  integer mWAtlasId                                ! MW Atlas Id used when useMWEmissivityAtlas == .true. ; 1 TELSEM2, 2 CNRM atlas
<span class="linenos"> 216</span>
<span class="linenos"> 217</span>  integer, external :: get_max_rss
<span class="linenos"> 218</span> 
<span class="linenos"> 219</span>contains
<span class="linenos"> 220</span>
<span class="linenos"> 221</span>  !--------------------------------------------------------------------------
<span class="linenos"> 222</span>  !  validateRttovVariable
<span class="linenos"> 223</span>  !--------------------------------------------------------------------------
<span class="linenos"> 224</span>  subroutine validateRttovVariable(value, variableName, obsSpaceData, headerIndex, minimum_opt, maximum_opt) 
<span class="linenos"> 225</span>    !
<span class="linenos"> 226</span>    !:Purpose:  check variable for validity for RTTOV-13, 
<span class="linenos"> 227</span>    !            if invalid replace by acceptable value and reject
<span class="linenos"> 228</span>    !
<span class="linenos"> 229</span>    implicit none
<span class="linenos"> 230</span>
<span class="linenos"> 231</span>    ! Arguments:
<span class="linenos"> 232</span>    real(8), intent(inout)          :: value           ! Value of the RTTOV input variable to check for validity
<span class="linenos"> 233</span>    character(len=*),intent(in)     :: variableName    ! Name of the checked variable for output in listings
<span class="linenos"> 234</span>    type(struct_obs), intent(inout) :: obsSpaceData    ! obsSpaceData object
<span class="linenos"> 235</span>    integer, intent(in)             :: headerIndex     ! Index of the observation in obsSpaceData header table 
<span class="linenos"> 236</span>    real(8), intent(in), optional   :: minimum_opt     ! Minimum acceptable value
<span class="linenos"> 237</span>    real(8), intent(in), optional   :: maximum_opt     ! Maximum acceptable value
<span class="linenos"> 238</span>    ! Locals:
<span class="linenos"> 239</span>    real(8)                         :: minimum, maximum
<span class="linenos"> 240</span>
<span class="linenos"> 241</span>    if (present(minimum_opt)) then
<span class="linenos"> 242</span>      minimum = minimum_opt
<span class="linenos"> 243</span>    else
<span class="linenos"> 244</span>      minimum = - huge(0.d0)
<span class="linenos"> 245</span>    end if
<span class="linenos"> 246</span>    
<span class="linenos"> 247</span>    if (present(maximum_opt)) then
<span class="linenos"> 248</span>      maximum = maximum_opt
<span class="linenos"> 249</span>    else
<span class="linenos"> 250</span>      maximum = huge(0.d0)
<span class="linenos"> 251</span>    end if
<span class="linenos"> 252</span>    
<span class="linenos"> 253</span>    if ( value &lt; minimum .or. value &gt; maximum ) then
<span class="linenos"> 254</span>      write(*,*) &#39;validateRttovVariable: !!! WARNING !!!&#39;
<span class="linenos"> 255</span>      write(*,*) &#39;validateRttovVariable: INVALID &#39; // trim(variableName)
<span class="linenos"> 256</span>      write(*,*) &#39;validateRttovVariable: headerIndex &#39;, headerIndex, &quot; !&quot;
<span class="linenos"> 257</span>      write(*,*) &#39;validateRttovVariable: &#39;, value, &#39; should be between &#39;, minimum, &#39; and &#39;, maximum
<span class="linenos"> 258</span>      value = max(minimum, min(value, maximum) )
<span class="linenos"> 259</span>      write(*,*) &#39;validateRttovVariable: replaced with &#39;, value, &#39; !&#39;
<span class="linenos"> 260</span>      call rejectObs(obsSpaceData, headerIndex)
<span class="linenos"> 261</span>    end if
<span class="linenos"> 262</span>
<span class="linenos"> 263</span>  end subroutine validateRttovVariable
<span class="linenos"> 264</span>
<span class="linenos"> 265</span>  !--------------------------------------------------------------------------
<span class="linenos"> 266</span>  !  validateRttovProfile
<span class="linenos"> 267</span>  !--------------------------------------------------------------------------
<span class="linenos"> 268</span>  subroutine validateRttovProfile(profile, profileName, minimum, maximum, obsSpaceData, headerIndex) 
<span class="linenos"> 269</span>    !
<span class="linenos"> 270</span>    !:Purpose:  check profile for validity for RTTOV-13, 
<span class="linenos"> 271</span>    !            if invalid replace by acceptable value(s) and reject
<span class="linenos"> 272</span>    !
<span class="linenos"> 273</span>    implicit none
<span class="linenos"> 274</span>
<span class="linenos"> 275</span>    ! Arguments:
<span class="linenos"> 276</span>    real(8), intent(inout)          :: profile(:)    ! Vertical profile of input variables to check for validity
<span class="linenos"> 277</span>    character(len=*),intent(in)     :: profileName   ! Name of the checked profile for output in listings
<span class="linenos"> 278</span>    real(8), intent(in)             :: minimum       ! Minimum acceptable value
<span class="linenos"> 279</span>    real(8), intent(in)             :: maximum       ! Maximum acceptable value
<span class="linenos"> 280</span>    type(struct_obs), intent(inout) :: obsSpaceData  ! obsSpaceData object
<span class="linenos"> 281</span>    integer, intent(in)             :: headerIndex   ! Index of the observation in obsSpaceData header table
<span class="linenos"> 282</span>    ! Locals:
<span class="linenos"> 283</span>    logical                         :: ltest(size(profile))
<span class="linenos"> 284</span>    integer                         :: levelIndex
<span class="linenos"> 285</span>    
<span class="linenos"> 286</span>    ltest(:) = (profile(:) &gt; maximum .or. profile(:) &lt; minimum)
<span class="linenos"> 287</span>    
<span class="linenos"> 288</span>    if ( any(ltest) ) then
<span class="linenos"> 289</span>      write(*,*) &#39;validateRttovProfile: !!! WARNING !!!&#39;
<span class="linenos"> 290</span>      write(*,*) &#39;validateRttovProfile: some INVALID &#39; // trim(profileName)
<span class="linenos"> 291</span>      write(*,*) &#39;validateRttovProfile: headerIndex &#39;, headerIndex, &quot; !&quot;
<span class="linenos"> 292</span>      do levelIndex = 1, size(profile)
<span class="linenos"> 293</span>        if ( ltest(levelIndex) ) then
<span class="linenos"> 294</span>          write(*,*) &#39;validateRttovProfile: &#39;, profile(levelIndex), &amp;
<span class="linenos"> 295</span>              &#39;should be between &#39;, minimum, &#39; and &#39;, maximum
<span class="linenos"> 296</span>          profile(levelIndex) = max(minimum, min(profile(levelIndex), maximum) )
<span class="linenos"> 297</span>          write(*,*) &#39;validateRttovProfile: replaced with &#39;, profile(levelIndex) 
<span class="linenos"> 298</span>        end if
<span class="linenos"> 299</span>      end do
<span class="linenos"> 300</span>      call rejectObs(obsSpaceData, headerIndex)
<span class="linenos"> 301</span>    end if
<span class="linenos"> 302</span>    
<span class="linenos"> 303</span>  end subroutine validateRttovProfile
<span class="linenos"> 304</span>  
<span class="linenos"> 305</span>  !--------------------------------------------------------------------------
<span class="linenos"> 306</span>  ! rejectObs
<span class="linenos"> 307</span>  !--------------------------------------------------------------------------
<span class="linenos"> 308</span>  subroutine rejectObs(obsSpaceData, headerIndex)
<span class="linenos"> 309</span>    !
<span class="linenos"> 310</span>    !:Purpose: reject all data corresponding to headerIndex
<span class="linenos"> 311</span>    !
<span class="linenos"> 312</span>    implicit none
<span class="linenos"> 313</span>
<span class="linenos"> 314</span>    !Arguments:
<span class="linenos"> 315</span>    type(struct_obs), intent(inout) :: obsSpaceData ! obsSpaceData object
<span class="linenos"> 316</span>    integer, intent(in)             :: headerIndex  ! Index of the observation in obsSpaceData header table
<span class="linenos"> 317</span>
<span class="linenos"> 318</span>    !Locals:
<span class="linenos"> 319</span>    integer :: bodyIndex
<span class="linenos"> 320</span>    
<span class="linenos"> 321</span>    call obs_set_current_body_list(obsSpaceData, headerIndex)
<span class="linenos"> 322</span>    BODY:do 
<span class="linenos"> 323</span>      bodyIndex = obs_getBodyIndex(obsSpaceData)
<span class="linenos"> 324</span>      if (bodyIndex &lt; 0) exit BODY
<span class="linenos"> 325</span>      call obs_bodySet_i(obsSpaceData, OBS_ASS, bodyIndex, obs_notAssimilated)
<span class="linenos"> 326</span>    end do BODY
<span class="linenos"> 327</span>  end subroutine rejectObs
<span class="linenos"> 328</span>  
<span class="linenos"> 329</span>  !--------------------------------------------------------------------------
<span class="linenos"> 330</span>  ! tvs_setupAlloc
<span class="linenos"> 331</span>  !--------------------------------------------------------------------------
<span class="linenos"> 332</span>  subroutine tvs_setupAlloc(obsSpaceData)
<span class="linenos"> 333</span>    !
<span class="linenos"> 334</span>    !:Purpose: Memory allocation for the non linear radiative transfer model variables.
<span class="linenos"> 335</span>    !
<span class="linenos"> 336</span>    implicit none
<span class="linenos"> 337</span>
<span class="linenos"> 338</span>    !Arguments:
<span class="linenos"> 339</span>    type(struct_obs) :: obsSpaceData
<span class="linenos"> 340</span>
<span class="linenos"> 341</span>    ! Locals:
<span class="linenos"> 342</span>    integer :: allocStatus(9)
<span class="linenos"> 343</span>    integer :: satelliteCode, instrumentCode, iplatform, isat, instrum
<span class="linenos"> 344</span>    integer :: tovsIndex, idatyp, sensorIndex
<span class="linenos"> 345</span>    integer :: channelNumber, nosensor, channelIndex
<span class="linenos"> 346</span>    integer :: errorStatus
<span class="linenos"> 347</span>    integer :: headerIndex, bodyIndex, taskIndex
<span class="linenos"> 348</span>    logical :: runObsOperatorWithClw
<span class="linenos"> 349</span>    logical :: runObsOperatorWithHydrometeors
<span class="linenos"> 350</span>    logical, allocatable :: logicalBuffer(:)
<span class="linenos"> 351</span>    character(len=32) :: hydroTableFilename
<span class="linenos"> 352</span>
<span class="linenos"> 353</span>    if (tvs_nsensors == 0) return
<span class="linenos"> 354</span>
<span class="linenos"> 355</span>    !  1. Determine the number of radiances to be assimilated.
<span class="linenos"> 356</span>    !      Construct a list of channels for each sensor.
<span class="linenos"> 357</span>    !      Construct a list of sensor number for each profile
<span class="linenos"> 358</span>
<span class="linenos"> 359</span>    write(*,*) &#39;tvs_setupAlloc: Starting&#39; 
<span class="linenos"> 360</span>
<span class="linenos"> 361</span>    allocStatus = 0
<span class="linenos"> 362</span>    allocate (tvs_nchan(tvs_nsensors),                         stat= allocStatus(1))
<span class="linenos"> 363</span>    allocate (tvs_ichan(tvs_maxNumberOfChannels,tvs_nsensors), stat= allocStatus(2))
<span class="linenos"> 364</span>    allocate (tvs_lsensor(obs_numheader(obsSpaceData)),        stat= allocStatus(3))
<span class="linenos"> 365</span>    allocate (tvs_headerIndex (obs_numheader(obsSpaceData)),   stat= allocStatus(4))
<span class="linenos"> 366</span>    allocate (tvs_tovsIndex(obs_numheader(obsSpaceData)),      stat= allocStatus(5))
<span class="linenos"> 367</span>    allocate (tvs_isReallyPresent(tvs_nsensors),               stat= allocStatus(6))
<span class="linenos"> 368</span>    allocate (tvs_nchanMpiGlobal(tvs_nsensors),                stat= allocStatus(7))
<span class="linenos"> 369</span>    allocate (tvs_ichanMpiGlobal(tvs_maxNumberOfChannels,tvs_nsensors), stat= allocStatus(8))
<span class="linenos"> 370</span>    allocate (tvs_isReallyPresentMpiGlobal(tvs_nsensors), stat= allocStatus(9))
<span class="linenos"> 371</span>
<span class="linenos"> 372</span>    call utl_checkAllocationStatus(allocStatus, &#39; tvs_setupAlloc&#39;)
<span class="linenos"> 373</span>
<span class="linenos"> 374</span>    tvs_nchan(:) = 0 
<span class="linenos"> 375</span>    tvs_ichan(:,:) = 0
<span class="linenos"> 376</span>    tvs_isReallyPresent(:) = .true.
<span class="linenos"> 377</span>    tvs_lsensor(:) = -1
<span class="linenos"> 378</span>    tvs_headerIndex(:) = -1
<span class="linenos"> 379</span>    tvs_tovsIndex (:) = -1
<span class="linenos"> 380</span>
<span class="linenos"> 381</span>    tvs_nobtov = 0
<span class="linenos"> 382</span>
<span class="linenos"> 383</span>    ! Loop over all header indices of the &#39;TO&#39; family
<span class="linenos"> 384</span>    ! Set the header list &amp; start at the beginning of the list
<span class="linenos"> 385</span>    call obs_set_current_header_list(obsSpaceData,&#39;TO&#39;)
<span class="linenos"> 386</span>    HEADER: do
<span class="linenos"> 387</span>      headerIndex = obs_getHeaderIndex(obsSpaceData)
<span class="linenos"> 388</span>      if (headerIndex &lt; 0) exit HEADER
<span class="linenos"> 389</span>
<span class="linenos"> 390</span>      idatyp = obs_headElem_i(obsSpaceData,OBS_ITY,headerIndex)
<span class="linenos"> 391</span>
<span class="linenos"> 392</span>      if ( .not. tvs_isIdBurpTovs(idatyp) ) then
<span class="linenos"> 393</span>        write(*,*) &#39;tvs_setupAlloc: warning unknown radiance codtyp present check NAMTOVSINST&#39;, idatyp
<span class="linenos"> 394</span>        call rejectObs(obsSpaceData, headerIndex)
<span class="linenos"> 395</span>        cycle HEADER   ! Proceed to the next headerIndex
<span class="linenos"> 396</span>      end if
<span class="linenos"> 397</span>      tvs_nobtov = tvs_nobtov + 1
<span class="linenos"> 398</span>     
<span class="linenos"> 399</span>      !    Construct list of channels for each sensor:
<span class="linenos"> 400</span>      !          map burp satellite info to RTTOV platform and satellite.
<span class="linenos"> 401</span>      satelliteCode = obs_headElem_i(obsSpaceData,OBS_SAT,headerIndex)
<span class="linenos"> 402</span>      call tvs_mapSat(satelliteCode,iplatform,isat)
<span class="linenos"> 403</span>      if (iplatform == -1) then
<span class="linenos"> 404</span>        write(*,*) &#39;Unknown OBS_SAT !&#39;, satelliteCode
<span class="linenos"> 405</span>        call utl_abort(&#39;tvs_setupAlloc&#39;)
<span class="linenos"> 406</span>      end if
<span class="linenos"> 407</span>      !    map burp instrument info to RTTOV instrument.
<span class="linenos"> 408</span>      instrumentCode = obs_headElem_i(obsSpaceData,OBS_INS,headerIndex)
<span class="linenos"> 409</span>      call tvs_mapInstrum(instrumentCode,instrum)
<span class="linenos"> 410</span>      if (instrum == -1) then
<span class="linenos"> 411</span>        write(*,*) &#39;Unknown OBS_INS !&#39;, instrumentCode
<span class="linenos"> 412</span>        call utl_abort(&#39;tvs_setupAlloc&#39;)
<span class="linenos"> 413</span>      end if
<span class="linenos"> 414</span>      !    find sensor number for this obs.
<span class="linenos"> 415</span>      nosensor =0
<span class="linenos"> 416</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 417</span>        if ( iplatform == tvs_platforms  (sensorIndex) .and. &amp;
<span class="linenos"> 418</span>             isat      == tvs_satellites (sensorIndex) .and. &amp;
<span class="linenos"> 419</span>             instrum   == tvs_instruments(sensorIndex)      ) then
<span class="linenos"> 420</span>          nosensor = sensorIndex
<span class="linenos"> 421</span>          exit
<span class="linenos"> 422</span>        end if
<span class="linenos"> 423</span>      end do
<span class="linenos"> 424</span>
<span class="linenos"> 425</span>      if (nosensor &gt; 0) then
<span class="linenos"> 426</span>        tvs_lsensor(tvs_nobtov) = nosensor
<span class="linenos"> 427</span>        tvs_headerIndex (tvs_nobtov) = headerIndex
<span class="linenos"> 428</span>        tvs_tovsIndex (headerIndex) = tvs_nobtov
<span class="linenos"> 429</span>      else
<span class="linenos"> 430</span>        write(*,*) &#39; tvs_setupAlloc: Warning Invalid Sensor &#39;, iplatform, isat, instrum, &#39; skipping ...&#39;
<span class="linenos"> 431</span>      end if
<span class="linenos"> 432</span>
<span class="linenos"> 433</span>      ! Loop over all body indices (still in the &#39;TO&#39; family)
<span class="linenos"> 434</span>      ! Set the body list &amp; start at the beginning of the list
<span class="linenos"> 435</span>      call obs_set_current_body_list(obsSpaceData, headerIndex)
<span class="linenos"> 436</span>      BODY: do 
<span class="linenos"> 437</span>        bodyIndex = obs_getBodyIndex(obsSpaceData)
<span class="linenos"> 438</span>        if (bodyIndex &lt; 0) exit BODY
<span class="linenos"> 439</span>        if (nosensor &gt; 0) then
<span class="linenos"> 440</span>          if ( obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex) == obs_assimilated ) then
<span class="linenos"> 441</span>            call tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos"> 442</span>                                                channelNumber, channelIndex )
<span class="linenos"> 443</span>            if ( channelIndex == 0 ) then
<span class="linenos"> 444</span>              tvs_nchan(nosensor) = tvs_nchan(nosensor) + 1
<span class="linenos"> 445</span>              tvs_ichan(tvs_nchan(nosensor),nosensor) = channelNumber
<span class="linenos"> 446</span>            end if
<span class="linenos"> 447</span>            
<span class="linenos"> 448</span>            if ( tvs_debug .and. mmpi_myid == 0 .and. &amp;
<span class="linenos"> 449</span>                 trim(tvs_instrumentName(nosensor)) == &#39;AMSUA&#39; ) then
<span class="linenos"> 450</span>              write(*,*) &#39;test channelNumber:&#39;, headerIndex, bodyIndex, nosensor, &amp;
<span class="linenos"> 451</span>                   tvs_satelliteName(nosensor), channelNumber, channelIndex
<span class="linenos"> 452</span>            end if
<span class="linenos"> 453</span>          end if
<span class="linenos"> 454</span>        else           
<span class="linenos"> 455</span>          ! set to notAssimilated if instrument not in NAMTOV namelist
<span class="linenos"> 456</span>          call obs_bodySet_i(obsSpaceData, OBS_ASS, bodyIndex, obs_notAssimilated)
<span class="linenos"> 457</span>        end if
<span class="linenos"> 458</span>      end do BODY
<span class="linenos"> 459</span>    end do HEADER
<span class="linenos"> 460</span>
<span class="linenos"> 461</span>    if ( .not. tvs_userDefinedDoAzimuthCorrection) then 
<span class="linenos"> 462</span>      ! tvs_doAzimuthCorrection user defined values will be overwriten by the old default values 
<span class="linenos"> 463</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 464</span>        tvs_doAzimuthCorrection(sensorIndex) = ( tvs_platforms(sensorIndex) /= platform_id_eos .and. &amp;
<span class="linenos"> 465</span>             ( tvs_instruments(sensorIndex) == inst_id_amsua .or. tvs_instruments(sensorIndex) == inst_id_mhs )  )     
<span class="linenos"> 466</span>      end do
<span class="linenos"> 467</span>      if ( mmpi_myId == 0 ) write(*,*) &#39; tvs_setupAlloc: Warning tvs_doAzimuthCorrection user defined values overwriten by the old default values&#39;
<span class="linenos"> 468</span>    end if
<span class="linenos"> 469</span>
<span class="linenos"> 470</span>    if ( .not. tvs_userDefinedIsAzimuthValid ) then 
<span class="linenos"> 471</span>      ! tvs_isAzimuthValid  user defined values will be overwriten by the current default values 
<span class="linenos"> 472</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 473</span>        tvs_isAzimuthValid(sensorIndex) = .not. ( tvs_isInstrumGeostationary(tvs_instruments(sensorIndex)) )
<span class="linenos"> 474</span>      end do
<span class="linenos"> 475</span>      if ( mmpi_myId == 0 ) write(*,*) &#39; tvs_setupAlloc: Warning tvs_isAzimuthValid user defined values overwriten by the current default values&#39;
<span class="linenos"> 476</span>    end if
<span class="linenos"> 477</span>
<span class="linenos"> 478</span>    if ( mmpi_myId == 0 ) then
<span class="linenos"> 479</span>      write(*,*) &#39; tvs_setupAlloc: platform satellite id tvs_doAzimuthCorrection tvs_isAzimuthValid&#39;
<span class="linenos"> 480</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 481</span>        write(*,&#39;(18x,a,1x,a,1x,i2,1x,L1,10x,L1)&#39;) inst_name(tvs_instruments(sensorIndex)), &amp;
<span class="linenos"> 482</span>             platform_name(tvs_platforms(sensorIndex)), tvs_satellites(sensorIndex), &amp;
<span class="linenos"> 483</span>             tvs_doAzimuthCorrection(sensorIndex), tvs_isAzimuthValid(sensorIndex)
<span class="linenos"> 484</span>      end do
<span class="linenos"> 485</span>    end if
<span class="linenos"> 486</span>    
<span class="linenos"> 487</span>    ! Sort list of channels in ascending order.Also force at least one channel, if none are found.
<span class="linenos"> 488</span>    do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 489</span>      call isort(tvs_ichan(:,sensorIndex),tvs_nchan(sensorIndex))
<span class="linenos"> 490</span>      if ( tvs_nchan(sensorIndex) == 0 ) then
<span class="linenos"> 491</span>        tvs_isReallyPresent ( sensorIndex ) =.false.
<span class="linenos"> 492</span>        tvs_nchan(sensorIndex) = 1
<span class="linenos"> 493</span>        tvs_ichan(1,sensorIndex) = 1
<span class="linenos"> 494</span>      end if
<span class="linenos"> 495</span>    end do
<span class="linenos"> 496</span>
<span class="linenos"> 497</span>    write(*,*) &#39; tvs_setupAlloc: tvs_nobtov = &#39;, tvs_nobtov
<span class="linenos"> 498</span>
<span class="linenos"> 499</span>    do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 500</span>      call tvs_getCommonChannelSet(tvs_ichan(:,sensorIndex),tvs_nchanMpiGlobal(sensorIndex), tvs_ichanMpiGlobal(:,sensorIndex))
<span class="linenos"> 501</span>      print *, &#39;sensorIndex,tvs_nchan(sensorIndex),tvs_nchanMpiGlobal(sensorIndex)&#39;, sensorIndex, tvs_nchan(sensorIndex),tvs_nchanMpiGlobal(sensorIndex)
<span class="linenos"> 502</span>    end do
<span class="linenos"> 503</span>
<span class="linenos"> 504</span>    if (mmpi_myid ==0) then
<span class="linenos"> 505</span>      allocate(logicalBuffer(mmpi_nprocs))
<span class="linenos"> 506</span>    else
<span class="linenos"> 507</span>      allocate(logicalBuffer(1))
<span class="linenos"> 508</span>    end if
<span class="linenos"> 509</span>    
<span class="linenos"> 510</span>    do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 511</span>      call RPN_COMM_gather( tvs_isReallyPresent ( sensorIndex ) , 1, &#39;MPI_LOGICAL&#39;, logicalBuffer, 1,&#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, errorStatus )
<span class="linenos"> 512</span>      if (mmpi_myid ==0) then
<span class="linenos"> 513</span>        tvs_isReallyPresentMpiGlobal ( sensorIndex ) =.false.
<span class="linenos"> 514</span>        do taskIndex=1, mmpi_nprocs
<span class="linenos"> 515</span>          tvs_isReallyPresentMpiGlobal ( sensorIndex ) =  tvs_isReallyPresentMpiGlobal ( sensorIndex ) .or. logicalBuffer(taskIndex)
<span class="linenos"> 516</span>        end do
<span class="linenos"> 517</span>      end if
<span class="linenos"> 518</span>      call rpn_comm_bcast(tvs_isReallyPresentMpiGlobal ( sensorIndex ), 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, errorStatus )
<span class="linenos"> 519</span>    end do
<span class="linenos"> 520</span>    
<span class="linenos"> 521</span>    deallocate(logicalBuffer)
<span class="linenos"> 522</span>
<span class="linenos"> 523</span>    if ( tvs_debug .and. mmpi_myid == 0 ) then
<span class="linenos"> 524</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos"> 525</span>        write(*,*) &#39;sensorIndex, tvs_instrumentName(sensorIndex), tvs_satelliteName(sensorIndex)&#39;
<span class="linenos"> 526</span>        write(*,*) sensorIndex, tvs_instrumentName(sensorIndex), tvs_satelliteName(sensorIndex)
<span class="linenos"> 527</span>        write(*,*) &#39;tvs_channelOffset(sensorIndex), tvs_nchan(sensorIndex)&#39;
<span class="linenos"> 528</span>        write(*,*) tvs_channelOffset(sensorIndex), tvs_nchan(sensorIndex)
<span class="linenos"> 529</span>        write(*,*) &#39;tvs_ichan(1:tvs_nchan(sensorIndex),sensorIndex)&#39;
<span class="linenos"> 530</span>        write(*,*) tvs_ichan(1:tvs_nchan(sensorIndex),sensorIndex)
<span class="linenos"> 531</span>        write(*,*) 
<span class="linenos"> 532</span>      end do
<span class="linenos"> 533</span>    end if
<span class="linenos"> 534</span>
<span class="linenos"> 535</span>    !  3. Initialize TOVS radiance transfer model
<span class="linenos"> 536</span>
<span class="linenos"> 537</span>    if ( radiativeTransferCode == &#39;RTTOV&#39; ) then
<span class="linenos"> 538</span>
<span class="linenos"> 539</span>      write(*,&#39;(//,10x,A)&#39;) &#39;-rttov_setup: initializing the TOVS radiative transfer model&#39;
<span class="linenos"> 540</span>
<span class="linenos"> 541</span>      allocate (tvs_coefs(tvs_nsensors)          ,stat= allocStatus(1))
<span class="linenos"> 542</span>      allocate (tvs_listSensors (3,tvs_nsensors) ,stat= allocStatus(2))
<span class="linenos"> 543</span>      allocate (tvs_opts (tvs_nsensors)          ,stat= allocStatus(3))
<span class="linenos"> 544</span>      if (tvs_numMWInstrumUsingHydrometeors  &gt; 0) then
<span class="linenos"> 545</span>        allocate (tvs_opts_scatt (tvs_nsensors) ,stat= allocStatus(4))
<span class="linenos"> 546</span>        allocate (tvs_coef_scatt (tvs_nsensors) ,stat= allocStatus(5))
<span class="linenos"> 547</span>      end if
<span class="linenos"> 548</span>      call utl_checkAllocationStatus(allocStatus(1:5), &#39; tvs_setupAlloc before rttov initialization&#39;)
<span class="linenos"> 549</span>
<span class="linenos"> 550</span>      do sensorIndex=1, tvs_nsensors
<span class="linenos"> 551</span>        tvs_listSensors(1,sensorIndex) = tvs_platforms  (sensorIndex)
<span class="linenos"> 552</span>        tvs_listSensors(2,sensorIndex) = tvs_satellites (sensorIndex)
<span class="linenos"> 553</span>        tvs_listSensors(3,sensorIndex) = tvs_instruments(sensorIndex)
<span class="linenos"> 554</span>
<span class="linenos"> 555</span>        runObsOperatorWithClw = (tvs_numMWInstrumUsingCLW /= 0 .and. &amp;
<span class="linenos"> 556</span>                                 tvs_isInstrumUsingCLW(tvs_instruments(sensorIndex)))
<span class="linenos"> 557</span>        runObsOperatorWithHydrometeors = (tvs_numMWInstrumUsingHydrometeors /= 0 .and. &amp;
<span class="linenos"> 558</span>                                          tvs_isInstrumUsingHydrometeors(tvs_instruments(sensorIndex)))
<span class="linenos"> 559</span>
<span class="linenos"> 560</span>        !&lt; General configuration options
<span class="linenos"> 561</span>        tvs_opts(sensorIndex) % config % apply_reg_limits = .true. ! if true application of profiles limits
<span class="linenos"> 562</span>        tvs_opts(sensorIndex) % config % verbose = .false. ! verbose output
<span class="linenos"> 563</span>        tvs_opts(sensorIndex) % config % do_checkinput = .true. ! to check if input profiles are within absolute and regression limits
<span class="linenos"> 564</span>        tvs_opts(sensorIndex) % config % fix_hgpl = .false. ! for backward compatibility with RTTOV-12 should be changed later
<span class="linenos"> 565</span>        !&lt; General RT options
<span class="linenos"> 566</span>        tvs_opts(sensorIndex) % rt_all % switchrad = .true.  ! to use brightness temperature (true) or radiance (false) units in AD routine
<span class="linenos"> 567</span>        tvs_opts(sensorIndex) % rt_all % use_q2m = .false.   ! if true use of surface humidity (false for compatibility with the way rttov 8.7 was compiled)
<span class="linenos"> 568</span>        tvs_opts(sensorIndex) % rt_all % addrefrac = .true.  ! to account for atmospheric refraction
<span class="linenos"> 569</span>        tvs_opts(sensorIndex) % rt_all % dtau_test = .true.  ! for backward compatibility with RTTOV-12 may be changed later
<span class="linenos"> 570</span>        tvs_opts(sensorIndex) % rt_all % use_t2m_opdep = .false. ! for backward compatibility with RTTOV-12 may be changed later
<span class="linenos"> 571</span>        !&lt; VIS/IR RT options
<span class="linenos"> 572</span>        tvs_opts(sensorIndex) % rt_ir % addsolar = .false.  ! to model solar component in the near IR (2000 cm-1 et plus)
<span class="linenos"> 573</span>        tvs_opts(sensorIndex) % rt_ir % addaerosl = .false. ! to account for scattering due to aerosols
<span class="linenos"> 574</span>        tvs_opts(sensorIndex) % rt_ir % addclouds = .false. ! to account for scattering due to clouds
<span class="linenos"> 575</span>        tvs_opts(sensorIndex) % rt_ir % ir_sea_emis_model = 2 ! ISEM (ir_sea_emis_model 1) useful for GEORAD
<span class="linenos"> 576</span>                                                              ! 2 selects IREMIS which is more sophisticated 
<span class="linenos"> 577</span>        tvs_opts(sensorIndex) % rt_ir % pc % ipcreg = -1         ! index of the required PC predictors... to see later
<span class="linenos"> 578</span>        tvs_opts(sensorIndex) % rt_ir % pc % addpc = .false.     ! to carry out principal component calculations 
<span class="linenos"> 579</span>        tvs_opts(sensorIndex) % rt_ir % pc % addradrec = .false. ! to reconstruct radiances from principal components
<span class="linenos"> 580</span>        !&lt; MW RT options
<span class="linenos"> 581</span>        tvs_opts(sensorIndex) % rt_mw % clw_data = tvs_isInstrumUsingCLW(tvs_instruments(sensorIndex)) ! disponibilite du profil d&#39;eau liquide
<span class="linenos"> 582</span>        tvs_opts(sensorIndex) % rt_mw % fastem_version = 6  ! use fastem version 6 microwave sea surface emissivity model (1-6)
<span class="linenos"> 583</span>        tvs_opts(sensorIndex) % rt_mw % clw_scheme = 1 ! default and recommended is 2 just for backward compatibility
<span class="linenos"> 584</span>        !&lt; Interpolation options
<span class="linenos"> 585</span>        tvs_opts(sensorIndex) % interpolation % addinterp = .true. ! use of internal profile interpolator (rt calculation on model levels)
<span class="linenos"> 586</span>        tvs_opts(sensorIndex) % interpolation % lgradp = .true.    ! allow tl/ad of user pressure levels
<span class="linenos"> 587</span>        tvs_opts(sensorIndex) % interpolation % interp_mode = interp_rochon_loglinear_wfn ! see table 9 page 37 of RTTOV 12.1 users guide
<span class="linenos"> 588</span>        tvs_opts(sensorIndex) % interpolation % reg_limit_extrap = tvs_regLimitExtrap 
<span class="linenos"> 589</span>
<span class="linenos"> 590</span>        tvs_opts(sensorIndex) % rt_all % co2_data = .false.
<span class="linenos"> 591</span>        tvs_opts(sensorIndex) % rt_all % n2o_data = .false.
<span class="linenos"> 592</span>        tvs_opts(sensorIndex) % rt_all % co_data  = .false.
<span class="linenos"> 593</span>        tvs_opts(sensorIndex) % rt_all % ch4_data = .false.
<span class="linenos"> 594</span>
<span class="linenos"> 595</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos"> 596</span>          tvs_opts_scatt(sensorIndex) % interp_mode =  tvs_opts(sensorIndex) % interpolation % interp_mode ! Set interpolation method
<span class="linenos"> 597</span>          tvs_opts_scatt(sensorIndex) % reg_limit_extrap = tvs_regLimitExtrap 
<span class="linenos"> 598</span>          tvs_opts_scatt(sensorIndex) % fastem_version = tvs_opts(sensorIndex) % rt_mw % fastem_version  
<span class="linenos"> 599</span>          tvs_opts_scatt(sensorIndex) % supply_foam_fraction = .false.
<span class="linenos"> 600</span>          tvs_opts_scatt(sensorIndex) % use_t2m_opdep = tvs_opts(sensorIndex) % rt_all % use_t2m_opdep
<span class="linenos"> 601</span>          tvs_opts_scatt(sensorIndex) % use_q2m = tvs_opts(sensorIndex) % rt_all % use_q2m
<span class="linenos"> 602</span>          tvs_opts_scatt(sensorIndex) % lgradp = .true.
<span class="linenos"> 603</span>          tvs_opts_scatt(sensorIndex) % lusercfrac = .false. !&lt; Switch to enable user-specified effective cloud fraction ??
<span class="linenos"> 604</span>          tvs_opts_scatt(sensorIndex) % config % do_checkinput = tvs_opts(sensorIndex) % config % do_checkinput
<span class="linenos"> 605</span>          tvs_opts_scatt(sensorIndex) % config % apply_reg_limits = tvs_opts(sensorIndex) % config % apply_reg_limits
<span class="linenos"> 606</span>          tvs_opts_scatt(sensorIndex) % config % verbose = .true.
<span class="linenos"> 607</span>          tvs_opts_scatt(sensorIndex) % config % fix_hgpl= tvs_opts(sensorIndex) % config % fix_hgpl
<span class="linenos"> 608</span>          ! other option may be considered:
<span class="linenos"> 609</span>          !real(jprb)    :: cc_threshold          = 1.E-3_jprb    !&lt; Minimum effective cloud fraction threshold to consider scattering
<span class="linenos"> 610</span>          !real(jprb)    :: ice_polarisation      = 1.40_jprb     !&lt; Polarised scattering factor for ice hydrometeors (&lt;0 = no polarisation)
<span class="linenos"> 611</span>          !logical(jplm) :: ozone_data            = .false.       !&lt; Switch to enable input of O3 profile
<span class="linenos"> 612</span>                                                                  ! because standard RTTOV coefficients in the MW have no ozone sensitivity
<span class="linenos"> 613</span>          !logical(jplm) :: rad_down_lin_tau      = .true.        !&lt; Linear-in-tau or layer-mean for downwelling radiances
<span class="linenos"> 614</span>          !logical(jplm) :: hydro_cfrac_tlad      = .true.        !&lt; Switch for hydrometeor TL/AD sensitivity to effective cfrac
<span class="linenos"> 615</span>          !logical(jplm) :: zero_hydro_tlad       = .false.       !&lt; Switch for hydrometeor TL/AD sensitivity in layers with zero
<span class="linenos"> 616</span>                                                                  !   hydrometeor concentration
<span class="linenos"> 617</span>        end if
<span class="linenos"> 618</span>        
<span class="linenos"> 619</span>
<span class="linenos"> 620</span>        errorStatus = errorStatus_success
<span class="linenos"> 621</span>        call utl_tmg_start(16,&#39;----RttovSetup&#39;)
<span class="linenos"> 622</span>        write(*,*) &#39; sensorIndex,tvs_nchan(sensorIndex)&#39;,  sensorIndex,tvs_nchan(sensorIndex)
<span class="linenos"> 623</span>        if ( tvs_mpiTask0ReadCoeffs ) then
<span class="linenos"> 624</span>          call tvs_rttov_read_coefs(errorStatus, tvs_coefs(sensorIndex), tvs_opts(sensorIndex), &amp; 
<span class="linenos"> 625</span>               tvs_ichan(1:tvs_nchan(sensorIndex),sensorIndex), tvs_listSensors(:,sensorIndex))
<span class="linenos"> 626</span>        else
<span class="linenos"> 627</span>          call rttov_read_coefs (                               &amp;
<span class="linenos"> 628</span>               errorStatus,                                     &amp;! out
<span class="linenos"> 629</span>               tvs_coefs(sensorIndex),                          &amp;
<span class="linenos"> 630</span>               tvs_opts(sensorIndex),                           &amp;
<span class="linenos"> 631</span>               instrument= tvs_listSensors(:,sensorIndex),      &amp;! in
<span class="linenos"> 632</span>               channels=  tvs_ichan(1:tvs_nchan(sensorIndex),sensorIndex) )     ! in option
<span class="linenos"> 633</span>        end if
<span class="linenos"> 634</span>        if (errorStatus /= errorStatus_success) then
<span class="linenos"> 635</span>          write(*,*) &#39;rttov_read_coefs: fatal error reading coefficients&#39;,errorStatus,sensorIndex,tvs_listSensors(1:3,sensorIndex)
<span class="linenos"> 636</span>          call utl_abort(&#39;tvs_setupAlloc&#39;)
<span class="linenos"> 637</span>        end if
<span class="linenos"> 638</span>       
<span class="linenos"> 639</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos"> 640</span>          hydrotableFilename = &#39;hydrotable_&#39; // trim(platform_name(tvs_platforms(sensorIndex))) // &#39;_&#39; // &amp;
<span class="linenos"> 641</span>               trim(inst_name(tvs_instruments(sensorIndex))) // &#39;.dat&#39;
<span class="linenos"> 642</span>          call rttov_read_scattcoeffs(errorStatus, tvs_opts_scatt(sensorIndex), tvs_coefs(sensorIndex), &amp;
<span class="linenos"> 643</span>               tvs_coef_scatt(sensorIndex), file_coef=hydrotableFilename)
<span class="linenos"> 644</span>          if (errorStatus /= errorStatus_success) then
<span class="linenos"> 645</span>            write(*,*) &#39;rttov_read_scattcoeffs: fatal error reading RTTOV-SCATT coefficients&#39;, hydrotableFilename
<span class="linenos"> 646</span>            call utl_abort(&#39;tvs_setupAlloc&#39;)
<span class="linenos"> 647</span>          end if
<span class="linenos"> 648</span>        end if
<span class="linenos"> 649</span>        call utl_tmg_stop(16)
<span class="linenos"> 650</span>
<span class="linenos"> 651</span>        tvs_opts(sensorIndex) % rt_all % ozone_data = ( tvs_coefs(sensorIndex) % coef % nozone &gt; 0 ) ! profil d&#39;ozone disponible
<span class="linenos"> 652</span>
<span class="linenos"> 653</span>        ! Ensure the options and coefficients are consistent
<span class="linenos"> 654</span>        call rttov_user_options_checkinput(errorStatus, tvs_opts(sensorIndex), tvs_coefs(sensorIndex))
<span class="linenos"> 655</span>        if (errorStatus /= errorStatus_success) then
<span class="linenos"> 656</span>          write(*,*) &#39;error in rttov options&#39;, errorStatus
<span class="linenos"> 657</span>          call utl_abort(&#39;tvs_setupAlloc&#39;)
<span class="linenos"> 658</span>        end if
<span class="linenos"> 659</span>       
<span class="linenos"> 660</span>      end do
<span class="linenos"> 661</span>
<span class="linenos"> 662</span>
<span class="linenos"> 663</span>      !   4. Memory allocations for radiative tranfer model variables
<span class="linenos"> 664</span>
<span class="linenos"> 665</span>      ! Radiance by profile
<span class="linenos"> 666</span>
<span class="linenos"> 667</span>      allocate( tvs_radiance(tvs_nobtov) ,stat= allocStatus(1))
<span class="linenos"> 668</span>
<span class="linenos"> 669</span>      call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_setupAlloc radiances 1&#39;)
<span class="linenos"> 670</span>  
<span class="linenos"> 671</span>      do tovsIndex = 1, tvs_nobtov
<span class="linenos"> 672</span>        sensorIndex = tvs_lsensor(tovsIndex)
<span class="linenos"> 673</span>        if (sensorIndex &gt; -1) then
<span class="linenos"> 674</span>          ! allocate BT equivalent to total direct, tl and ad radiance output
<span class="linenos"> 675</span>          allocate( tvs_radiance(tovsIndex)  % bt  ( tvs_nchan(sensorIndex) ) ,stat= allocStatus(1))
<span class="linenos"> 676</span>          tvs_radiance(tovsIndex)  % bt  ( : ) = 0.d0
<span class="linenos"> 677</span>          call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_setupAlloc radiances 2&#39;)
<span class="linenos"> 678</span>          nullify (tvs_radiance(tovsIndex)  % clear )
<span class="linenos"> 679</span>        end if
<span class="linenos"> 680</span>      end do
<span class="linenos"> 681</span>
<span class="linenos"> 682</span>    end if
<span class="linenos"> 683</span>  
<span class="linenos"> 684</span>    write(*,*) &#39;Leaving tvs_setupAlloc&#39;
<span class="linenos"> 685</span>
<span class="linenos"> 686</span>  end subroutine tvs_setupAlloc
<span class="linenos"> 687</span>
<span class="linenos"> 688</span>  !--------------------------------------------------------------------------
<span class="linenos"> 689</span>  ! tvs_getProfile
<span class="linenos"> 690</span>  !--------------------------------------------------------------------------
<span class="linenos"> 691</span>  subroutine tvs_getProfile(profiles, profileType, cld_profiles_opt)
<span class="linenos"> 692</span>    !:Purpose: sets profiles as a pointer of type rttov_profile
<span class="linenos"> 693</span>    !           based on profileType equal to nl or tlad. 
<span class="linenos"> 694</span>    ! 
<span class="linenos"> 695</span>    implicit none
<span class="linenos"> 696</span>
<span class="linenos"> 697</span>    !Arguments:
<span class="linenos"> 698</span>    type(rttov_profile), pointer, intent(inout)       :: profiles(:)
<span class="linenos"> 699</span>    type(rttov_profile_cloud), pointer, intent(inout), optional :: cld_profiles_opt(:)
<span class="linenos"> 700</span>    character(len=*), intent(in)                      :: profileType
<span class="linenos"> 701</span>
<span class="linenos"> 702</span>    select case( trim( profileType) )
<span class="linenos"> 703</span>      case(&#39;nl&#39;)
<span class="linenos"> 704</span>        profiles =&gt; tvs_profiles_nl
<span class="linenos"> 705</span>        if (present(cld_profiles_opt)) cld_profiles_opt =&gt; tvs_cld_profiles_nl
<span class="linenos"> 706</span>      case(&#39;tlad&#39;)
<span class="linenos"> 707</span>        profiles =&gt; tvs_profiles_tlad
<span class="linenos"> 708</span>        if (present(cld_profiles_opt)) cld_profiles_opt =&gt; tvs_cld_profiles_tlad
<span class="linenos"> 709</span>      case default
<span class="linenos"> 710</span>        call utl_abort(&#39;tvs_getProfile: invalid profileType &#39; // profileType )
<span class="linenos"> 711</span>    end select
<span class="linenos"> 712</span>
<span class="linenos"> 713</span>  end subroutine tvs_getProfile
<span class="linenos"> 714</span>
<span class="linenos"> 715</span>  !--------------------------------------------------------------------------
<span class="linenos"> 716</span>  ! tvs_allocTransmission
<span class="linenos"> 717</span>  !--------------------------------------------------------------------------
<span class="linenos"> 718</span>  subroutine tvs_allocTransmission(nlevels)
<span class="linenos"> 719</span>
<span class="linenos"> 720</span>    !:Purpose: Allocate the global rttov transmission structure used
<span class="linenos"> 721</span>    !           when this is needed for some purpose (e.g. used in 
<span class="linenos"> 722</span>    !           LETKF to determine peak pressure level of each radiance
<span class="linenos"> 723</span>    !           channel for vertical localization).
<span class="linenos"> 724</span>    !
<span class="linenos"> 725</span>    implicit none
<span class="linenos"> 726</span>
<span class="linenos"> 727</span>    ! Arguments:
<span class="linenos"> 728</span>    integer, intent(in) :: nlevels 
<span class="linenos"> 729</span>    ! Locals:
<span class="linenos"> 730</span>    integer :: allocStatus(2), jo, isens, nc
<span class="linenos"> 731</span>
<span class="linenos"> 732</span>    allocStatus(:) = 0
<span class="linenos"> 733</span>    allocate( tvs_transmission(tvs_nobtov), stat=allocStatus(1))
<span class="linenos"> 734</span>    call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_allocTransmission&#39;)
<span class="linenos"> 735</span>
<span class="linenos"> 736</span>    do jo = 1, tvs_nobtov
<span class="linenos"> 737</span>      isens = tvs_lsensor(jo)
<span class="linenos"> 738</span>      nc = tvs_nchan(isens)
<span class="linenos"> 739</span>      ! allocate transmittance from surface and from pressure levels
<span class="linenos"> 740</span>      allocate( tvs_transmission(jo) % tau_total(nc),     stat= allocStatus(1))
<span class="linenos"> 741</span>      allocate( tvs_transmission(jo) % tau_levels(nlevels,nc), stat= allocStatus(2))
<span class="linenos"> 742</span>      call utl_checkAllocationStatus(allocStatus, &#39; tvs_allocTransmission&#39;)
<span class="linenos"> 743</span>    end do
<span class="linenos"> 744</span>
<span class="linenos"> 745</span>  end subroutine tvs_allocTransmission
<span class="linenos"> 746</span>
<span class="linenos"> 747</span>
<span class="linenos"> 748</span>
<span class="linenos"> 749</span>  !--------------------------------------------------------------------------
<span class="linenos"> 750</span>  ! tvs_setup
<span class="linenos"> 751</span>  !--------------------------------------------------------------------------
<span class="linenos"> 752</span>  subroutine tvs_setup
<span class="linenos"> 753</span>    !
<span class="linenos"> 754</span>    !:Purpose: to read namelist NAMTOV, initialize the observation error covariance and setup RTTOV-12.
<span class="linenos"> 755</span>    !
<span class="linenos"> 756</span>
<span class="linenos"> 757</span>    implicit none
<span class="linenos"> 758</span>    ! Locals:
<span class="linenos"> 759</span>    integer  sensorIndex, ierr, nulnam
<span class="linenos"> 760</span>    integer, external :: fclos, fnom
<span class="linenos"> 761</span>    integer :: instrumentIndex, numMWInstrumToUseCLW, numMWInstrumToUseHydrometeors
<span class="linenos"> 762</span>
<span class="linenos"> 763</span>    ! Namelist variables: (local)
<span class="linenos"> 764</span>    character(len=8)  :: crtmodl ! For now, must equal &#39;RTTOV&#39;
<span class="linenos"> 765</span>    integer :: nsensors ! MUST NOT BE INCLUDED IN NAMELIST!
<span class="linenos"> 766</span>    character(len=15) :: csatid(tvs_maxNumberOfSensors)        ! List of satellite names
<span class="linenos"> 767</span>    character(len=15) :: cinstrumentid(tvs_maxNumberOfSensors) ! List of incstrument names
<span class="linenos"> 768</span>    logical :: ldbgtov  ! Choose to print simulated and observed Tb to listing
<span class="linenos"> 769</span>    logical :: useO3Climatology ! Choose to use ozone climatology (otherwise model field)
<span class="linenos"> 770</span>    logical :: regLimitExtrap ! Choose to use RTTOV reg_limit_extrap option
<span class="linenos"> 771</span>    logical :: doAzimuthCorrection(tvs_maxNumberOfSensors) ! Choose to apply correction to azimuth angle
<span class="linenos"> 772</span>    logical :: isAzimuthValid(tvs_maxNumberOfSensors) ! Indicate if azimuth angle is valid
<span class="linenos"> 773</span>    logical :: userDefinedDoAzimuthCorrection ! Indicate if user defined azimuth correction is to be used
<span class="linenos"> 774</span>    logical :: userDefinedIsAzimuthValid ! Indicate if user defined azimuth angle is valid
<span class="linenos"> 775</span>    logical :: mpiTask0ReadCoeffs ! Choose to read coeffs only on task 0 and broadcast
<span class="linenos"> 776</span>    logical :: mwInstrumUsingCLW_tl ! Choose to use CLW increment in TL/AD if exists as state variable
<span class="linenos"> 777</span>    logical :: mwInstrumUsingHydrometeors_tl ! Choose to all hydomet variables in TL/AD if exist as state variables
<span class="linenos"> 778</span>    real(8) :: cloudScaleFactor  ! Scale factor applied to model produced clouds to account for bias
<span class="linenos"> 779</span>    character(len=15) :: instrumentNamesUsingCLW(tvs_maxNumberOfSensors) ! List of inst names using CLW
<span class="linenos"> 780</span>    character(len=15) :: instrumentNamesUsingHydrometeors(tvs_maxNumberOfSensors) ! List of inst name using full set of hydromet variables
<span class="linenos"> 781</span>    logical :: mwAllskyAssim ! High-level key to activate all-sky treatment of MW radiances
<span class="linenos"> 782</span>
<span class="linenos"> 783</span>    namelist /NAMTOV/ nsensors, csatid, cinstrumentid
<span class="linenos"> 784</span>    namelist /NAMTOV/ ldbgtov,useO3Climatology
<span class="linenos"> 785</span>    namelist /NAMTOV/ useUofWIREmiss, crtmodl
<span class="linenos"> 786</span>    namelist /NAMTOV/ useMWEmissivityAtlas, mWAtlasId
<span class="linenos"> 787</span>    namelist /NAMTOV/ mwInstrumUsingCLW_tl, instrumentNamesUsingCLW
<span class="linenos"> 788</span>    namelist /NAMTOV/ mwInstrumUsingHydrometeors_tl, instrumentNamesUsingHydrometeors
<span class="linenos"> 789</span>    namelist /NAMTOV/ regLimitExtrap, doAzimuthCorrection, userDefinedDoAzimuthCorrection
<span class="linenos"> 790</span>    namelist /NAMTOV/ isAzimuthValid, userDefinedIsAzimuthValid, cloudScaleFactor 
<span class="linenos"> 791</span>    namelist /NAMTOV/ mwAllskyAssim, mpiTask0ReadCoeffs
<span class="linenos"> 792</span>
<span class="linenos"> 793</span>    ! return if the NAMTOV does not exist
<span class="linenos"> 794</span>    if ( .not. utl_isNamelistPresent(&#39;NAMTOV&#39;,&#39;./flnml&#39;) ) then
<span class="linenos"> 795</span>      write(*,*)
<span class="linenos"> 796</span>      write(*,*) &#39;tvs_setup: Namelist block NAMTOV is missing in the namelist.&#39;
<span class="linenos"> 797</span>      write(*,*) &#39;           Skipping tvs_setup.&#39;
<span class="linenos"> 798</span>      return
<span class="linenos"> 799</span>    end if
<span class="linenos"> 800</span> 
<span class="linenos"> 801</span>    !   1.1 Default values for namelist variables
<span class="linenos"> 802</span>
<span class="linenos"> 803</span>    nsensors = MPC_missingValue_INT
<span class="linenos"> 804</span>    csatid(:) = &#39;***UNDEFINED***&#39;
<span class="linenos"> 805</span>    cinstrumentid(:) = &#39;***UNDEFINED***&#39;
<span class="linenos"> 806</span>    doAzimuthCorrection(:) = .false.
<span class="linenos"> 807</span>    isAzimuthValid(:) = .false.
<span class="linenos"> 808</span>    ldbgtov = .false.
<span class="linenos"> 809</span>    useO3Climatology = .true.
<span class="linenos"> 810</span>    userDefinedDoAzimuthCorrection = .false.
<span class="linenos"> 811</span>    userDefinedIsAzimuthValid = .false.
<span class="linenos"> 812</span>    crtmodl = &#39;RTTOV&#39;
<span class="linenos"> 813</span>    useUofWIREmiss = .false.
<span class="linenos"> 814</span>    useMWEmissivityAtlas = .false.
<span class="linenos"> 815</span>    mWAtlasId = 1 !Default to TELSEM-2
<span class="linenos"> 816</span>    mwInstrumUsingCLW_tl = .false.
<span class="linenos"> 817</span>    mwInstrumUsingHydrometeors_tl = .false.
<span class="linenos"> 818</span>    instrumentNamesUsingCLW(:) = &#39;***UNDEFINED***&#39;
<span class="linenos"> 819</span>    instrumentNamesUsingHydrometeors(:) = &#39;***UNDEFINED***&#39;
<span class="linenos"> 820</span>    regLimitExtrap = .true.
<span class="linenos"> 821</span>    cloudScaleFactor = 0.5D0
<span class="linenos"> 822</span>    mwAllskyAssim = .false.
<span class="linenos"> 823</span>    mpiTask0ReadCoeffs = .true.
<span class="linenos"> 824</span>
<span class="linenos"> 825</span>    !   1.2 Read the NAMELIST NAMTOV to modify them
<span class="linenos"> 826</span> 
<span class="linenos"> 827</span>    nulnam = 0
<span class="linenos"> 828</span>    ierr = fnom(nulnam,&#39;./flnml&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos"> 829</span>    read(nulnam, nml=namtov, iostat=ierr)
<span class="linenos"> 830</span>    if (ierr /= 0) call utl_abort(&#39;tvs_setup: Error reading namelist NAMTOV&#39;)
<span class="linenos"> 831</span>
<span class="linenos"> 832</span>    if (mmpi_myid == 0) write(*,nml=namtov)
<span class="linenos"> 833</span>    ierr = fclos(nulnam)
<span class="linenos"> 834</span>
<span class="linenos"> 835</span>    !  1.3 Transfer namelist variables to module variables
<span class="linenos"> 836</span>    if (nsensors /= MPC_missingValue_INT) then
<span class="linenos"> 837</span>      call utl_abort(&#39;tvs_setup: check namelist section NAMTOV; nsensors should be removed as it is&#39; // &amp;
<span class="linenos"> 838</span>          &#39; now computed by Midas from cinstrumentid and csatid arrays&#39;)
<span class="linenos"> 839</span>    end if
<span class="linenos"> 840</span>    
<span class="linenos"> 841</span>    tvs_nsensors = 0
<span class="linenos"> 842</span>    sensor_loop:do sensorIndex = 1, tvs_maxNumberOfSensors
<span class="linenos"> 843</span>      if (cinstrumentid(sensorIndex) /= &quot;***UNDEFINED***&quot; .and. &amp;
<span class="linenos"> 844</span>          csatid(sensorIndex) /= &quot;***UNDEFINED***&quot; ) then
<span class="linenos"> 845</span>        tvs_nsensors = tvs_nsensors + 1
<span class="linenos"> 846</span>      else
<span class="linenos"> 847</span>        exit sensor_loop
<span class="linenos"> 848</span>      end if
<span class="linenos"> 849</span>    end do sensor_loop
<span class="linenos"> 850</span>    
<span class="linenos"> 851</span>    tvs_debug = ldbgtov
<span class="linenos"> 852</span>    radiativeTransferCode = crtmodl
<span class="linenos"> 853</span>    tvs_useO3Climatology = useO3Climatology
<span class="linenos"> 854</span>    tvs_instrumentName(:) = cinstrumentid(:)
<span class="linenos"> 855</span>    tvs_satelliteName(:) = csatid(:)
<span class="linenos"> 856</span>    tvs_mwInstrumUsingCLW_tl = mwInstrumUsingCLW_tl
<span class="linenos"> 857</span>    tvs_regLimitExtrap = regLimitExtrap
<span class="linenos"> 858</span>    tvs_userDefinedDoAzimuthCorrection = userDefinedDoAzimuthCorrection
<span class="linenos"> 859</span>    tvs_userDefinedIsAzimuthValid = userDefinedIsAzimuthValid
<span class="linenos"> 860</span>    tvs_doAzimuthCorrection(:) =  doAzimuthCorrection(:)
<span class="linenos"> 861</span>    tvs_isAzimuthValid(:) =  isAzimuthValid(:)
<span class="linenos"> 862</span>    tvs_cloudScaleFactor = cloudScaleFactor 
<span class="linenos"> 863</span>    tvs_mwAllskyAssim = mwAllskyAssim
<span class="linenos"> 864</span>    tvs_mpiTask0ReadCoeffs = mpiTask0ReadCoeffs
<span class="linenos"> 865</span>
<span class="linenos"> 866</span>    !  1.4 Validate namelist values
<span class="linenos"> 867</span>    
<span class="linenos"> 868</span>    if ( tvs_nsensors == 0 ) then
<span class="linenos"> 869</span>      if(mmpi_myid==0) then 
<span class="linenos"> 870</span>        write(*,*) &#39; =====================================================&#39;
<span class="linenos"> 871</span>        write(*,*) &#39; tvs_setup: Number of sensors is zero, skipping setup&#39;
<span class="linenos"> 872</span>        write(*,*) &#39; =====================================================&#39;
<span class="linenos"> 873</span>      end if
<span class="linenos"> 874</span>      return
<span class="linenos"> 875</span>    end if
<span class="linenos"> 876</span>
<span class="linenos"> 877</span>    if ( radiativeTransferCode /= &#39;RTTOV&#39; ) then
<span class="linenos"> 878</span>      write(*,&#39;(A)&#39;) &#39; Invalid radiation model name&#39;
<span class="linenos"> 879</span>      call utl_abort(&#39;tvs_setup&#39;)
<span class="linenos"> 880</span>    end if
<span class="linenos"> 881</span>
<span class="linenos"> 882</span>    if ( tvs_nsensors &gt; tvs_maxNumberOfSensors ) then
<span class="linenos"> 883</span>      write(*,&#39;(A)&#39;) &#39; Number of sensors (tvs_nsensors) is greater than maximum allowed (tvs_maxNumberOfSensors)&#39;
<span class="linenos"> 884</span>      call utl_abort(&#39;tvs_setup&#39;)
<span class="linenos"> 885</span>    end if
<span class="linenos"> 886</span>
<span class="linenos"> 887</span>    !  1.5 Print the content of this NAMELIST
<span class="linenos"> 888</span>
<span class="linenos"> 889</span>    if(mmpi_myid == 0) then
<span class="linenos"> 890</span>      write(*,&#39;(A)&#39;) 
<span class="linenos"> 891</span>      write(*,&#39;(3X,A)&#39;) &#39;- Parameters used for TOVS processing (read in NAMTOV)&#39;
<span class="linenos"> 892</span>      write(*,&#39;(3X,A)&#39;) &#39;  ----------------------------------------------------&#39;
<span class="linenos"> 893</span>      write(*,&#39;(6X,A,2X,L1)&#39;) &#39;TOVS debug                           : &#39;, tvs_debug
<span class="linenos"> 894</span>      write(*,&#39;(6X,A,2X,L1)&#39;) &#39;Use of UW IR land emissivity atlases : &#39;, useUofWIREmiss
<span class="linenos"> 895</span>      write(*,&#39;(6X,A,2X,L1)&#39;) &#39;Use of MW land emissivity atlases    : &#39;, useMWEmissivityAtlas
<span class="linenos"> 896</span>      if (useMWEmissivityAtlas) then
<span class="linenos"> 897</span>        write(*,&#39;(6X,A,2X,I1)&#39;) &#39;MW atlas Id                          : &#39;, mWAtlasId
<span class="linenos"> 898</span>      end if
<span class="linenos"> 899</span>      write(*,&#39;(6X,A,2X,L1)&#39;) &#39;Use of reg_limit_extrap              : &#39;, regLimitExtrap
<span class="linenos"> 900</span>      write(*,&#39;(6X,A,2X,A)&#39;)  &#39;Radiative transfer model             : &#39;, radiativeTransferCode
<span class="linenos"> 901</span>      write(*,&#39;(6X,A,2X,I3)&#39;) &#39;Number of sensors                    : &#39;, tvs_nsensors
<span class="linenos"> 902</span>      write(*,&quot;(6X,&#39;Satellite ids          : &#39;,10A10)&quot;) (tvs_satelliteName(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos"> 903</span>      write(*,&quot;(6X,&#39;Instrument ids         : &#39;,10A10)&quot;) (tvs_instrumentName(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos"> 904</span>      write(*,&#39;(A)&#39;) 
<span class="linenos"> 905</span>      write(*,&#39;(A)&#39;) 
<span class="linenos"> 906</span>      write(*,&#39;(A)&#39;) 
<span class="linenos"> 907</span>      write(*,&#39;(3X,A)&#39;) &#39;- Reading and initialization in preparation to the TOVS processing&#39;
<span class="linenos"> 908</span>      write(*,&#39;(5X,A)&#39;) &#39;----------------------------------------------------------------&#39;
<span class="linenos"> 909</span>    end if
<span class="linenos"> 910</span>
<span class="linenos"> 911</span>    !  1.6 Set up platform, satellite, instrument and channel mapping
<span class="linenos"> 912</span>
<span class="linenos"> 913</span>    call sensors()
<span class="linenos"> 914</span>
<span class="linenos"> 915</span>    ! Get the name and number of instruments to use CLW
<span class="linenos"> 916</span>    instrumentIdsUsingCLW(:) = -1
<span class="linenos"> 917</span>    do instrumentIndex = 1, tvs_nsensors
<span class="linenos"> 918</span>      instrumentIdsUsingCLW(instrumentIndex) = tvs_getInstrumentId(instrumentNamesUsingCLW(instrumentIndex))
<span class="linenos"> 919</span>      if ( instrumentNamesUsingCLW(instrumentIndex) /= &#39;***UNDEFINED***&#39; ) then
<span class="linenos"> 920</span>        if ( instrumentIdsUsingCLW(instrumentIndex) == -1 ) then
<span class="linenos"> 921</span>          write(*,*) instrumentIndex, instrumentNamesUsingCLW(instrumentIndex)
<span class="linenos"> 922</span>          call utl_abort(&#39;tvs_setup: Unknown instrument name to use CLW&#39;)
<span class="linenos"> 923</span>        end if
<span class="linenos"> 924</span>      else
<span class="linenos"> 925</span>        numMWInstrumToUseCLW = instrumentIndex - 1
<span class="linenos"> 926</span>        exit
<span class="linenos"> 927</span>      end if
<span class="linenos"> 928</span>    end do
<span class="linenos"> 929</span>
<span class="linenos"> 930</span>    ! Get the name and number of instruments to use hydrometeors
<span class="linenos"> 931</span>    instrumentIdsUsingHydrometeors(:) = -1
<span class="linenos"> 932</span>    do instrumentIndex = 1, tvs_nsensors
<span class="linenos"> 933</span>      instrumentIdsUsingHydrometeors(instrumentIndex) = &amp;
<span class="linenos"> 934</span>                  tvs_getInstrumentId(instrumentNamesUsingHydrometeors(instrumentIndex))
<span class="linenos"> 935</span>      if ( instrumentNamesUsingHydrometeors(instrumentIndex) /= &#39;***UNDEFINED***&#39; ) then
<span class="linenos"> 936</span>        if ( instrumentIdsUsingHydrometeors(instrumentIndex) == -1 ) then
<span class="linenos"> 937</span>          write(*,*) instrumentIndex, instrumentNamesUsingHydrometeors(instrumentIndex)
<span class="linenos"> 938</span>          call utl_abort(&#39;tvs_setup: Unknown instrument name to use hydrometeors&#39;)
<span class="linenos"> 939</span>        end if
<span class="linenos"> 940</span>      else
<span class="linenos"> 941</span>        numMWInstrumToUseHydrometeors = instrumentIndex - 1
<span class="linenos"> 942</span>        exit
<span class="linenos"> 943</span>      end if
<span class="linenos"> 944</span>    end do
<span class="linenos"> 945</span>
<span class="linenos"> 946</span>    ! check instrument is either using CLW or hydrometeors for non-ATMS instruments
<span class="linenos"> 947</span>    do instrumentIndex = 1, numMWInstrumToUseHydrometeors
<span class="linenos"> 948</span>      if (numMWInstrumToUseCLW == 0) exit
<span class="linenos"> 949</span>
<span class="linenos"> 950</span>      if (any(instrumentIdsUsingCLW(1:numMWInstrumToUseCLW) == &amp;
<span class="linenos"> 951</span>              instrumentIdsUsingHydrometeors(instrumentIndex))) then
<span class="linenos"> 952</span>        write(*,*) instrumentIndex, instrumentNamesUsingHydrometeors(instrumentIndex)
<span class="linenos"> 953</span>        call utl_abort(&#39;tvs_setup: all-sky TtHu for this intrument is not assimilated yet&#39;)
<span class="linenos"> 954</span>      end if
<span class="linenos"> 955</span>    end do
<span class="linenos"> 956</span>
<span class="linenos"> 957</span>    tvs_numMWInstrumUsingCLW = numMWInstrumToUseCLW
<span class="linenos"> 958</span>    tvs_numMWInstrumUsingHydrometeors = numMWInstrumToUsehydrometeors
<span class="linenos"> 959</span>
<span class="linenos"> 960</span>    if ( mmpi_myid == 0 ) then
<span class="linenos"> 961</span>      write(*,*) &#39;tvs_setup: Instrument IDs to use CLW: &#39;, instrumentIdsUsingCLW(1:numMWInstrumToUseCLW)
<span class="linenos"> 962</span>      write(*,*) &#39;tvs_setup: Number of instruments to use CLW: &#39;, numMWInstrumToUseCLW
<span class="linenos"> 963</span>
<span class="linenos"> 964</span>      write(*,*) &#39;tvs_setup: Instrument IDs to use hydrometeors: &#39;, &amp;
<span class="linenos"> 965</span>                             instrumentIdsUsingHydrometeors(1:numMWInstrumToUseHydrometeors)
<span class="linenos"> 966</span>      write(*,*) &#39;tvs_setup: Number of instruments to use hydrometeors: &#39;, &amp;
<span class="linenos"> 967</span>                             numMWInstrumToUseHydrometeors
<span class="linenos"> 968</span>    end if
<span class="linenos"> 969</span>
<span class="linenos"> 970</span>  end subroutine tvs_setup
<span class="linenos"> 971</span>
<span class="linenos"> 972</span>  !--------------------------------------------------------------------------
<span class="linenos"> 973</span>  ! tvs_cleanup
<span class="linenos"> 974</span>  !--------------------------------------------------------------------------
<span class="linenos"> 975</span>  subroutine tvs_cleanup
<span class="linenos"> 976</span>    !
<span class="linenos"> 977</span>    !:Purpose: release memory used by RTTOV-12.
<span class="linenos"> 978</span>    !
<span class="linenos"> 979</span>    implicit none
<span class="linenos"> 980</span>    integer :: allocStatus(8)
<span class="linenos"> 981</span>    integer :: iSensor,iObs,nChans,nl
<span class="linenos"> 982</span>
<span class="linenos"> 983</span>    Write(*,*) &#39;tvs_cleanup: Starting&#39;
<span class="linenos"> 984</span>
<span class="linenos"> 985</span>    allocStatus(:) = 0
<span class="linenos"> 986</span>
<span class="linenos"> 987</span>    if ( radiativeTransferCode == &#39;RTTOV&#39; ) then
<span class="linenos"> 988</span>
<span class="linenos"> 989</span>      !___ radiance by profile
<span class="linenos"> 990</span>
<span class="linenos"> 991</span>      do iObs = 1, tvs_nobtov
<span class="linenos"> 992</span>        iSensor = tvs_lsensor(iObs)
<span class="linenos"> 993</span>        nchans = tvs_nchan(isensor)
<span class="linenos"> 994</span>        ! deallocate BT equivalent to total direct, tl and ad radiance output
<span class="linenos"> 995</span>        deallocate( tvs_radiance(iObs)  % bt ,stat= allocStatus(1))
<span class="linenos"> 996</span>        call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_cleanup radiances 1&#39;,.false.)
<span class="linenos"> 997</span>      end do
<span class="linenos"> 998</span>
<span class="linenos"> 999</span>      deallocate( tvs_radiance ,stat= allocStatus(1))
<span class="linenos">1000</span>      call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_cleanup radiances 2&#39;)
<span class="linenos">1001</span>
<span class="linenos">1002</span>      do iObs = 1, tvs_nobtov
<span class="linenos">1003</span>        iSensor = tvs_lsensor(iObs)
<span class="linenos">1004</span>        nl = tvs_coefs(iSensor) % coef % nlevels
<span class="linenos">1005</span>        ! deallocate model profiles atmospheric arrays with RTTOV levels dimension
<span class="linenos">1006</span>        call rttov_alloc_prof(allocStatus(1),1,tvs_profiles_nl(iObs),nl, &amp;    ! 1 = nprofiles un profil a la fois
<span class="linenos">1007</span>             tvs_opts(iSensor),asw=0,coefs=tvs_coefs(iSensor),init=.false. ) ! asw =0 deallocation
<span class="linenos">1008</span>        call rttov_alloc_prof(allocStatus(2),1,tvs_profiles_tlad(iObs),nl, &amp;    ! 1 = nprofiles un profil a la fois
<span class="linenos">1009</span>             tvs_opts(iSensor),asw=0,coefs=tvs_coefs(iSensor),init=.false. ) ! asw =0 deallocation
<span class="linenos">1010</span>        call utl_checkAllocationStatus(allocStatus(1:2), &#39;profiles deallocation in tvs_cleanup&#39;,.false.)
<span class="linenos">1011</span>      end do
<span class="linenos">1012</span>
<span class="linenos">1013</span>      deallocate(tvs_profiles_nl,   stat=allocStatus(1) )
<span class="linenos">1014</span>      deallocate(tvs_profiles_tlad, stat=allocStatus(2) )
<span class="linenos">1015</span>      call utl_checkAllocationStatus(allocStatus(1:2), &#39; tvs_setupAlloc tvs_profiles_nl/tlad&#39;)
<span class="linenos">1016</span>
<span class="linenos">1017</span>      do iSensor = tvs_nsensors,1,-1
<span class="linenos">1018</span>        call rttov_dealloc_coefs(allocStatus(1),  tvs_coefs(iSensor) )
<span class="linenos">1019</span>        Write(*,*) &#39;Deallocating coefficient structure for instrument&#39;, iSensor
<span class="linenos">1020</span>        call utl_checkAllocationStatus(allocStatus(1:1), &#39; rttov_dealloc_coefs in tvs_cleanup&#39;, .false.)
<span class="linenos">1021</span>      end do
<span class="linenos">1022</span>
<span class="linenos">1023</span>      deallocate (tvs_coefs       ,stat= allocStatus(1))
<span class="linenos">1024</span>      deallocate (tvs_listSensors ,stat= allocStatus(2))
<span class="linenos">1025</span>      deallocate (tvs_opts        ,stat= allocStatus(3))
<span class="linenos">1026</span>
<span class="linenos">1027</span>      call utl_checkAllocationStatus(allocStatus(1:3), &#39; tvs_cleanup&#39;, .false.)
<span class="linenos">1028</span>
<span class="linenos">1029</span>    end if
<span class="linenos">1030</span>
<span class="linenos">1031</span>    deallocate (tvs_nchan,          stat= allocStatus(1))
<span class="linenos">1032</span>    deallocate (tvs_ichan,          stat= allocStatus(2))
<span class="linenos">1033</span>    deallocate (tvs_lsensor,        stat= allocStatus(3))
<span class="linenos">1034</span>    deallocate (tvs_headerIndex,    stat= allocStatus(4))
<span class="linenos">1035</span>    deallocate (tvs_tovsIndex,      stat= allocStatus(5))
<span class="linenos">1036</span>    deallocate (tvs_isReallyPresent,stat= allocStatus(6))
<span class="linenos">1037</span>    deallocate (tvs_nchanMpiGlobal, stat= allocStatus(7))
<span class="linenos">1038</span>    deallocate (tvs_ichanMpiGlobal, stat= allocStatus(8))
<span class="linenos">1039</span>
<span class="linenos">1040</span>    call utl_checkAllocationStatus(allocStatus, &#39; tvs_cleanup&#39;, .false.)
<span class="linenos">1041</span>
<span class="linenos">1042</span>    Write(*,*) &#39;tvs_cleanup: Finished&#39;
<span class="linenos">1043</span>
<span class="linenos">1044</span>  end subroutine tvs_cleanup
<span class="linenos">1045</span>
<span class="linenos">1046</span>  !--------------------------------------------------------------------------
<span class="linenos">1047</span>  ! tvs_deallocateProfilesNlTlAd
<span class="linenos">1048</span>  !--------------------------------------------------------------------------
<span class="linenos">1049</span>  subroutine tvs_deallocateProfilesNlTlAd
<span class="linenos">1050</span>    !
<span class="linenos">1051</span>    !:Purpose: release memory used by RTTOV-12.
<span class="linenos">1052</span>    !
<span class="linenos">1053</span>    implicit none
<span class="linenos">1054</span>    integer :: allocStatus(8)
<span class="linenos">1055</span>
<span class="linenos">1056</span>    Write(*,*) &#39;tvs_deallocateProfilesNlTlAd: Starting&#39;
<span class="linenos">1057</span>
<span class="linenos">1058</span>    allocStatus(:) = 0
<span class="linenos">1059</span>
<span class="linenos">1060</span>    if ( radiativeTransferCode == &#39;RTTOV&#39; ) then
<span class="linenos">1061</span>      if ( allocated(tvs_profiles_nl) ) deallocate(tvs_profiles_nl, stat=allocStatus(1))
<span class="linenos">1062</span>      if ( allocated(tvs_profiles_tlad) ) deallocate(tvs_profiles_tlad, stat=allocStatus(2))
<span class="linenos">1063</span>      call utl_checkAllocationStatus(allocStatus(1:2), &#39; tvs_profiles_nl tvs_profiles_tlad&#39;, .false.)
<span class="linenos">1064</span>    end if
<span class="linenos">1065</span>
<span class="linenos">1066</span>    Write(*,*) &#39;tvs_deallocateProfilesNlTlAd: Finished&#39;
<span class="linenos">1067</span>
<span class="linenos">1068</span>  end subroutine tvs_deallocateProfilesNlTlAd
<span class="linenos">1069</span>
<span class="linenos">1070</span>  !--------------------------------------------------------------------------
<span class="linenos">1071</span>  ! sensors
<span class="linenos">1072</span>  !--------------------------------------------------------------------------
<span class="linenos">1073</span>  subroutine sensors
<span class="linenos">1074</span>    !
<span class="linenos">1075</span>    !:Purpose: Initialisation of the RTTOV-10 platform, satellite
<span class="linenos">1076</span>    !          and instrument ID&#39;s. Also set burp to RTTOV channel
<span class="linenos">1077</span>    !          mapping offset.
<span class="linenos">1078</span>    !          To verify and transfom the sensor information contained in the
<span class="linenos">1079</span>    !          NAMTOV namelist into the variables required by RTTTOV-7:
<span class="linenos">1080</span>    !          platform, satellite and instrument ID&#39;s.
<span class="linenos">1081</span>    !
<span class="linenos">1082</span>    implicit none
<span class="linenos">1083</span>
<span class="linenos">1084</span>    ! Locals:
<span class="linenos">1085</span>    integer sensorIndex, instrumentIndex, platformIndex
<span class="linenos">1086</span>    integer ipos1, ipos2
<span class="linenos">1087</span>    integer numerosat, ierr, kindex, nulnam
<span class="linenos">1088</span>    character(len=15) :: tempocsatid
<span class="linenos">1089</span>    logical, save :: first=.true.
<span class="linenos">1090</span>    integer, save :: ioffset1b(0:ninst-1)
<span class="linenos">1091</span>    character(len=15) :: tempo_inst
<span class="linenos">1092</span>    integer, external :: fnom, fclos
<span class="linenos">1093</span>
<span class="linenos">1094</span>    ! namelist variables
<span class="linenos">1095</span>    character(len=8) :: listinstrum(0:ninst-1) ! List of instrument names
<span class="linenos">1096</span>    integer          :: listoffset(0:ninst-1)  ! Corresponding list of channel offset values
<span class="linenos">1097</span>    namelist /NAMCHANOFFSET/ listoffset, listinstrum
<span class="linenos">1098</span>
<span class="linenos">1099</span>    !  1.0 Go through sensors and set RTTOV-10 variables
<span class="linenos">1100</span>
<span class="linenos">1101</span>    do sensorIndex=1, tvs_nsensors
<span class="linenos">1102</span>      tvs_platforms  (sensorIndex) = -1
<span class="linenos">1103</span>      tvs_satellites (sensorIndex) = -1
<span class="linenos">1104</span>      tvs_instruments(sensorIndex) = -1
<span class="linenos">1105</span>      tvs_channelOffset(sensorIndex) = -1
<span class="linenos">1106</span>    end do
<span class="linenos">1107</span>
<span class="linenos">1108</span>    if (first) then
<span class="linenos">1109</span>      if ( utl_isNamelistPresent(&#39;NAMCHANOFFSET&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1110</span>        call utl_abort(&#39;sensors: NAMCHANOFFSET namelist section should be now in flnml_static !&#39;)
<span class="linenos">1111</span>      end if
<span class="linenos">1112</span>      ! read the namelist
<span class="linenos">1113</span>      nulnam = 0
<span class="linenos">1114</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1115</span>      if (ierr /= 0) then
<span class="linenos">1116</span>        write(*,*) &#39;Error while opening flnml_static namelist file !&#39;
<span class="linenos">1117</span>        call utl_abort(&#39;sensors&#39;)
<span class="linenos">1118</span>      end if
<span class="linenos">1119</span>      listoffset(:) = 0
<span class="linenos">1120</span>      listinstrum(:) = &#39;XXXXXXXX&#39;
<span class="linenos">1121</span>      read(nulnam,NAMCHANOFFSET, iostat=ierr)
<span class="linenos">1122</span>      if (ierr /= 0) then
<span class="linenos">1123</span>        write(*,*) &#39;Error while reading NAMCHANOFFSET namelist section in flnml_static file !&#39;
<span class="linenos">1124</span>        call utl_abort(&#39;sensors&#39;)
<span class="linenos">1125</span>      end if
<span class="linenos">1126</span>      do instrumentIndex=0, ninst - 1
<span class="linenos">1127</span>        if ( listinstrum(instrumentIndex) /= &#39;XXXXXXXX&#39; ) then
<span class="linenos">1128</span>          ioffset1b( tvs_getInstrumentId( listinstrum(instrumentIndex) ) )  = listoffset(instrumentIndex)
<span class="linenos">1129</span>        end if
<span class="linenos">1130</span>      end do
<span class="linenos">1131</span>      ierr = fclos(nulnam)
<span class="linenos">1132</span>      first = .false.
<span class="linenos">1133</span>    end if
<span class="linenos">1134</span>
<span class="linenos">1135</span>    !  1.1 Set platforms and satellites
<span class="linenos">1136</span>
<span class="linenos">1137</span>    ! N.B.: Special cases for satellites TERRA and AQUA.
<span class="linenos">1138</span>    !       For consistency with the RTTOV-10 nomenclature, rename:
<span class="linenos">1139</span>    !       TERRA  to  eos1
<span class="linenos">1140</span>    !       AQUA   to  eos2
<span class="linenos">1141</span>    !       NPP    to  jpss0
<span class="linenos">1142</span>    !       JPSS    to  jpss0
<span class="linenos">1143</span>    !       HMWARI    to  himawari
<span class="linenos">1144</span>    !       FY-3C    to  FY3-3
<span class="linenos">1145</span>    do sensorIndex = 1, tvs_nsensors
<span class="linenos">1146</span>      if    ( tvs_satelliteName(sensorIndex) == &#39;TERRA&#39; ) then
<span class="linenos">1147</span>        tempocsatid = &#39;eos1&#39;
<span class="linenos">1148</span>      else if ( tvs_satelliteName(sensorIndex) == &#39;AQUA&#39;  ) then
<span class="linenos">1149</span>        tempocsatid = &#39;eos2&#39;
<span class="linenos">1150</span>      else if ( tvs_satelliteName(sensorIndex) == &#39;NPP&#39;  ) then
<span class="linenos">1151</span>        tempocsatid = &#39;jpss0&#39;
<span class="linenos">1152</span>      else if ( tvs_satelliteName(sensorIndex) == &#39;JPSS&#39;  ) then
<span class="linenos">1153</span>        tempocsatid = &#39;jpss0&#39;
<span class="linenos">1154</span>      else if ( tvs_satelliteName(sensorIndex)(1:6) == &#39;HMWARI&#39;  ) then
<span class="linenos">1155</span>        tempocsatid = &#39;himawari&#39; // trim(tvs_satelliteName(sensorIndex) (7:15))
<span class="linenos">1156</span>      else if ( tvs_satelliteName(sensorIndex) == &#39;FY-3C&#39;  ) then
<span class="linenos">1157</span>        TEMPOCSATID = &#39;FY3-3&#39;
<span class="linenos">1158</span>      else
<span class="linenos">1159</span>        call up2low(tvs_satelliteName(sensorIndex),tempocsatid)
<span class="linenos">1160</span>      end if
<span class="linenos">1161</span>      do platformIndex = 1, nplatforms
<span class="linenos">1162</span>        ipos1 = len_trim(platform_name(platformIndex))
<span class="linenos">1163</span>        ipos2 = index(tempocsatid,platform_name(platformIndex)(1:ipos1))
<span class="linenos">1164</span>        if ( ipos2 == 1 ) then
<span class="linenos">1165</span>          tvs_platforms(sensorIndex) = platformIndex
<span class="linenos">1166</span>          kindex = platformIndex
<span class="linenos">1167</span>        end if
<span class="linenos">1168</span>      end do
<span class="linenos">1169</span>      if ( tvs_platforms(sensorIndex) &lt; 0 ) then
<span class="linenos">1170</span>        write(*,&#39;(A)&#39;) &#39; Satellite &#39; // trim(tempocsatid) // &#39; not supported.&#39;
<span class="linenos">1171</span>        call utl_abort(&#39;SENSORS&#39;)
<span class="linenos">1172</span>      else
<span class="linenos">1173</span>        ipos1 = len_trim(platform_name(kindex))
<span class="linenos">1174</span>        ipos2 = len_trim(tempocsatid)
<span class="linenos">1175</span>        read(tempocsatid(ipos1+1:ipos2),*,IOSTAT=ierr) numerosat
<span class="linenos">1176</span>        numerosat = abs ( numerosat )
<span class="linenos">1177</span>        if ( ierr /= 0) then
<span class="linenos">1178</span>          write(*,&#39;(A,1x,i6,1x,i3,1x,i3,1x,A15)&#39;) &#39;Problem while reading satellite number&#39;, &amp;
<span class="linenos">1179</span>               ierr, ipos1, ipos2, tempocsatid
<span class="linenos">1180</span>          call utl_abort(&#39;SENSORS&#39;)
<span class="linenos">1181</span>        else
<span class="linenos">1182</span>          tvs_satellites(sensorIndex) = numerosat
<span class="linenos">1183</span>        end if
<span class="linenos">1184</span>      end if
<span class="linenos">1185</span>    end do
<span class="linenos">1186</span>
<span class="linenos">1187</span>    !   1.2 Set instruments,
<span class="linenos">1188</span>    !     also set channel offset, which is in fact a channel mapping between
<span class="linenos">1189</span>    !     the channel number in BURP files and the channel number used in
<span class="linenos">1190</span>    !     RTTOV-10.
<span class="linenos">1191</span>
<span class="linenos">1192</span>    do sensorIndex = 1, tvs_nsensors
<span class="linenos">1193</span>      if ( tvs_instrumentName(sensorIndex)(1:10) == &#39;GOESIMAGER&#39;) then !cas particulier
<span class="linenos">1194</span>        tvs_instruments(sensorIndex) = inst_id_goesim
<span class="linenos">1195</span>      else if ( tvs_satelliteName(sensorIndex)(1:5) == &#39;MTSAT&#39;) then !autre cas particulier
<span class="linenos">1196</span>        tvs_instruments(sensorIndex) = inst_id_gmsim
<span class="linenos">1197</span>      else 
<span class="linenos">1198</span>        call up2low(tvs_instrumentName(sensorIndex),tempo_inst)
<span class="linenos">1199</span>        do instrumentIndex = 0, ninst -1 
<span class="linenos">1200</span>          if ( trim(tempo_inst) == trim(inst_name(instrumentIndex))) then
<span class="linenos">1201</span>            tvs_instruments(sensorIndex) = instrumentIndex
<span class="linenos">1202</span>          end if
<span class="linenos">1203</span>        end do
<span class="linenos">1204</span>      end if
<span class="linenos">1205</span>      if ( tvs_instruments(sensorIndex) &lt; 0 ) then
<span class="linenos">1206</span>        write(*,&#39;(A)&#39;) &#39; INSTRUMENT &#39;// trim( tvs_instrumentName(sensorIndex)) // &#39; not supported.&#39;
<span class="linenos">1207</span>        call utl_abort(&#39;SENSORS&#39;)
<span class="linenos">1208</span>      end if
<span class="linenos">1209</span>      tvs_channelOffset(sensorIndex) = ioffset1b(tvs_instruments(sensorIndex))
<span class="linenos">1210</span>    end do
<span class="linenos">1211</span>
<span class="linenos">1212</span>    !    1.3 Print the RTTOV-12 related variables
<span class="linenos">1213</span>
<span class="linenos">1214</span>    if (mmpi_myid == 0) then
<span class="linenos">1215</span>      write(*,*)
<span class="linenos">1216</span>      write(*,&#39;(3X,A)&#39;) &#39;- SENSORS. Variables prepared for RTTOV-12:&#39;
<span class="linenos">1217</span>      write(*,&#39;(3X,A)&#39;) &#39;  ----------------------------------------&#39;
<span class="linenos">1218</span>      write(*,*)
<span class="linenos">1219</span>      write(*,&#39;(6X,A,I3)&#39;)   &#39;Number of sensors       : &#39;, tvs_nsensors
<span class="linenos">1220</span>      write(*,&quot;(&#39;Platform numbers        : &#39;,6X,10I3)&quot;)  (tvs_platforms(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos">1221</span>      write(*,&quot;(&#39;Satellite numbers       : &#39;,6X,10I3)&quot;)  (tvs_satellites(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos">1222</span>      write(*,&quot;(&#39;Instrument numbers      : &#39;,6X,10I3)&quot;)  (tvs_instruments(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos">1223</span>      write(*,&quot;(&#39;Channel mapping offsets : &#39;,6X,10I3)&quot;)  (tvs_channelOffset(sensorIndex), sensorIndex=1,tvs_nsensors)
<span class="linenos">1224</span>    end if
<span class="linenos">1225</span>
<span class="linenos">1226</span>  end subroutine sensors
<span class="linenos">1227</span>
<span class="linenos">1228</span>
<span class="linenos">1229</span>  !--------------------------------------------------------------------------
<span class="linenos">1230</span>  !  tvs_getAllIdBurpTovs
<span class="linenos">1231</span>  !--------------------------------------------------------------------------
<span class="linenos">1232</span>  subroutine tvs_getAllIdBurpTovs(idatypListSize, idatypList)
<span class="linenos">1233</span>    !
<span class="linenos">1234</span>    !:Purpose: Function to return a list of all idatyp (a.k.a. codtyp) values
<span class="linenos">1235</span>    !           for all possible radiance observations (according to the namelist)
<span class="linenos">1236</span>    !
<span class="linenos">1237</span>    implicit none
<span class="linenos">1238</span>
<span class="linenos">1239</span>    ! Argument:
<span class="linenos">1240</span>    integer :: idatypListSize
<span class="linenos">1241</span>    integer :: idatypList(:)
<span class="linenos">1242</span>    
<span class="linenos">1243</span>    ! Locals:
<span class="linenos">1244</span>    logical, save :: first=.true.
<span class="linenos">1245</span>    integer, save :: ninst_tovs
<span class="linenos">1246</span>    integer :: nulnam, ierr, instrumentIndex 
<span class="linenos">1247</span>    integer, external :: fnom, fclos
<span class="linenos">1248</span>    integer, save :: list_inst(ninst)
<span class="linenos">1249</span>
<span class="linenos">1250</span>    ! namelist variables
<span class="linenos">1251</span>    character(len=22) :: inst_names(ninst) ! List of instrument names for all radiance types
<span class="linenos">1252</span>    namelist /namtovsinst/ inst_names
<span class="linenos">1253</span>
<span class="linenos">1254</span>    if (tvs_nsensors == 0) then
<span class="linenos">1255</span>      ! no tovs data will be read, therefore false
<span class="linenos">1256</span>      idatypList(:) = MPC_missingValue_int
<span class="linenos">1257</span>      idatypListSize = 0      
<span class="linenos">1258</span>      return
<span class="linenos">1259</span>    end if
<span class="linenos">1260</span>
<span class="linenos">1261</span>    if (first) then
<span class="linenos">1262</span>      if ( utl_isNamelistPresent(&#39;NAMTOVSINST&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1263</span>        call utl_abort(&#39;tvs_getAllIdBurpTovs: NAMTOVSINST namelist section should be now in flnml_static !&#39;)
<span class="linenos">1264</span>      end if
<span class="linenos">1265</span>      nulnam = 0
<span class="linenos">1266</span>      ninst_tovs = 0
<span class="linenos">1267</span>      list_inst(:) = -1
<span class="linenos">1268</span>      inst_names(:) = &#39;XXXXXX&#39;
<span class="linenos">1269</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1270</span>      read(nulnam, nml=namtovsinst, iostat=ierr)
<span class="linenos">1271</span>      if (ierr /= 0) call utl_abort(&#39;tvs_getAllIdBurpTovs: Error reading NAMTOVSINST namelist section in flnml_static file&#39;)
<span class="linenos">1272</span>      if (mmpi_myid == 0) write(*,nml=namtovsinst)
<span class="linenos">1273</span>      ierr = fclos(nulnam)
<span class="linenos">1274</span>      do instrumentIndex=1, ninst
<span class="linenos">1275</span>        if (inst_names(instrumentIndex) == &#39;XXXXXX&#39; ) then
<span class="linenos">1276</span>          ninst_tovs = instrumentIndex - 1
<span class="linenos">1277</span>          exit
<span class="linenos">1278</span>        else
<span class="linenos">1279</span>          list_inst(instrumentIndex) = codtyp_get_codtyp( inst_names(instrumentIndex) )
<span class="linenos">1280</span>          if (list_inst(instrumentIndex) &lt; 0) then
<span class="linenos">1281</span>            write(*,*) inst_names(instrumentIndex)
<span class="linenos">1282</span>            call utl_abort(&#39;tvs_isIdBurpTovs: unknown instrument in namtovsinst namelist&#39;)
<span class="linenos">1283</span>          end if
<span class="linenos">1284</span>        end if
<span class="linenos">1285</span>      end do
<span class="linenos">1286</span>      if ( ninst_tovs == 0 ) call utl_abort(&#39;tvs_getAllIdBurpTovs: Empty namtovsinst namelist&#39;)
<span class="linenos">1287</span>      first = .false.
<span class="linenos">1288</span>    end if
<span class="linenos">1289</span>
<span class="linenos">1290</span>    idatypList(:) = MPC_missingValue_int
<span class="linenos">1291</span>    idatypList(1:ninst_tovs) = list_inst(1:ninst_tovs)
<span class="linenos">1292</span>    idatypListSize = ninst_tovs
<span class="linenos">1293</span>
<span class="linenos">1294</span>  end subroutine tvs_getAllIdBurpTovs
<span class="linenos">1295</span>
<span class="linenos">1296</span>  !--------------------------------------------------------------------------
<span class="linenos">1297</span>  !  tvs_isIdBurpTovs
<span class="linenos">1298</span>  !--------------------------------------------------------------------------
<span class="linenos">1299</span>  logical function tvs_isIdBurpTovs(idatyp)
<span class="linenos">1300</span>    !
<span class="linenos">1301</span>    !:Purpose: Function to check if the given idatyp (a.k.a. codtyp) 
<span class="linenos">1302</span>    !           corresponds to a radiance
<span class="linenos">1303</span>    !
<span class="linenos">1304</span>    implicit none
<span class="linenos">1305</span>
<span class="linenos">1306</span>    ! Argument:
<span class="linenos">1307</span>    integer, intent(in) :: idatyp
<span class="linenos">1308</span>    
<span class="linenos">1309</span>    ! Locals:
<span class="linenos">1310</span>    logical, save :: first=.true.
<span class="linenos">1311</span>    integer, save :: ninst_tovs
<span class="linenos">1312</span>    integer :: nulnam, ierr, instrumentIndex 
<span class="linenos">1313</span>    integer, external :: fnom, fclos
<span class="linenos">1314</span>    integer, save :: list_inst(ninst)
<span class="linenos">1315</span>
<span class="linenos">1316</span>    ! namelist variables
<span class="linenos">1317</span>    character(len=22) :: inst_names(ninst) ! List of instrument names for all radiance types
<span class="linenos">1318</span>    namelist /namtovsinst/ inst_names
<span class="linenos">1319</span>
<span class="linenos">1320</span>    if (tvs_nsensors == 0) then
<span class="linenos">1321</span>      ! no tovs data will be read, therefore false
<span class="linenos">1322</span>      tvs_isIdBurpTovs = .false.
<span class="linenos">1323</span>      return
<span class="linenos">1324</span>    end if
<span class="linenos">1325</span>
<span class="linenos">1326</span>    if (first) then
<span class="linenos">1327</span>       if ( utl_isNamelistPresent(&#39;NAMTOVSINST&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1328</span>        call utl_abort(&#39;tvs_isIdBurpTovs: NAMTOVSINST namelist section should be now in flnml_static !&#39;)
<span class="linenos">1329</span>      end if
<span class="linenos">1330</span>      nulnam = 0
<span class="linenos">1331</span>      ninst_tovs = 0
<span class="linenos">1332</span>      list_inst(:) = -1
<span class="linenos">1333</span>      inst_names(:) = &#39;XXXXXX&#39;
<span class="linenos">1334</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1335</span>      read(nulnam, nml=namtovsinst, iostat=ierr)
<span class="linenos">1336</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isIdBurpTovs: Error reading NAMTOVSINST namelist section in flnml_static file&#39;)
<span class="linenos">1337</span>      if (mmpi_myid == 0) write(*,nml=namtovsinst)
<span class="linenos">1338</span>      ierr = fclos(nulnam)
<span class="linenos">1339</span>      do instrumentIndex=1, ninst
<span class="linenos">1340</span>        if (inst_names(instrumentIndex) == &#39;XXXXXX&#39; ) then
<span class="linenos">1341</span>          ninst_tovs= instrumentIndex - 1
<span class="linenos">1342</span>          exit
<span class="linenos">1343</span>        else
<span class="linenos">1344</span>          list_inst(instrumentIndex) = codtyp_get_codtyp( inst_names(instrumentIndex) )
<span class="linenos">1345</span>          if (list_inst(instrumentIndex) &lt; 0) then
<span class="linenos">1346</span>            write(*,*) inst_names(instrumentIndex)
<span class="linenos">1347</span>            call utl_abort(&#39;tvs_isIdBurpTovs: unknown instrument in namtovsinst namelist&#39;)
<span class="linenos">1348</span>          end if
<span class="linenos">1349</span>        end if
<span class="linenos">1350</span>      end do
<span class="linenos">1351</span>      if ( ninst_tovs == 0 ) call utl_abort(&#39;tvs_isIdBurpTovs: Empty namtovsinst namelist&#39;)
<span class="linenos">1352</span>      first = .false.
<span class="linenos">1353</span>    end if
<span class="linenos">1354</span>
<span class="linenos">1355</span>    tvs_isIdBurpTovs = .false.
<span class="linenos">1356</span>
<span class="linenos">1357</span>    do instrumentIndex = 1, ninst_tovs
<span class="linenos">1358</span>      if (idatyp == list_inst(instrumentIndex) ) then
<span class="linenos">1359</span>        tvs_isIdBurpTovs = .true.
<span class="linenos">1360</span>        exit
<span class="linenos">1361</span>      end if
<span class="linenos">1362</span>    end do
<span class="linenos">1363</span>
<span class="linenos">1364</span>  end function tvs_isIdBurpTovs
<span class="linenos">1365</span>
<span class="linenos">1366</span>  !--------------------------------------------------------------------------
<span class="linenos">1367</span>  !  tvs_isIdBurpHyperSpectral
<span class="linenos">1368</span>  !--------------------------------------------------------------------------
<span class="linenos">1369</span>  logical function tvs_isIdBurpHyperSpectral(idatyp)
<span class="linenos">1370</span>    !
<span class="linenos">1371</span>    !:Purpose: Function to check if the given idatyp (a.k.a. codtyp) 
<span class="linenos">1372</span>    !           corresponds to a hyper-spectral infrared radiance
<span class="linenos">1373</span>    !
<span class="linenos">1374</span>    implicit none
<span class="linenos">1375</span>
<span class="linenos">1376</span>    ! Argument:
<span class="linenos">1377</span>    integer, intent(in) :: idatyp
<span class="linenos">1378</span>    
<span class="linenos">1379</span>    ! Locals:
<span class="linenos">1380</span>    logical, save :: first=.true.
<span class="linenos">1381</span>    integer, save :: ninst_hyper
<span class="linenos">1382</span>    integer :: nulnam, ierr, instrumentIndex 
<span class="linenos">1383</span>    integer, external :: fnom, fclos
<span class="linenos">1384</span>    integer, save :: list_inst(ninst)
<span class="linenos">1385</span>
<span class="linenos">1386</span>    ! namelist variables
<span class="linenos">1387</span>    character(len=22) :: name_inst(ninst) ! List of instrument names for hyperspectral IR
<span class="linenos">1388</span>    namelist /namhyper/ name_inst
<span class="linenos">1389</span>
<span class="linenos">1390</span>    if (tvs_nsensors == 0) then
<span class="linenos">1391</span>      ! no tovs data will be read, therefore false
<span class="linenos">1392</span>      tvs_isIdBurpHyperSpectral = .false.
<span class="linenos">1393</span>      return
<span class="linenos">1394</span>    end if
<span class="linenos">1395</span>
<span class="linenos">1396</span>    if (first) then
<span class="linenos">1397</span>      if ( utl_isNamelistPresent(&#39;NAMHYPER&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1398</span>        call utl_abort(&#39;tvs_isIdBurpHyperSpectral: NAMHYPER namelist section should be now in flnml_static !&#39;)
<span class="linenos">1399</span>      end if
<span class="linenos">1400</span>      nulnam = 0
<span class="linenos">1401</span>      ninst_hyper = 0
<span class="linenos">1402</span>      list_inst(:) = -1
<span class="linenos">1403</span>      name_inst(:) = &#39;XXXXXX&#39;
<span class="linenos">1404</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1405</span>      read(nulnam, nml=namhyper, iostat=ierr)
<span class="linenos">1406</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isIdBurpHyperSpectral: Error reading NAMHYPER namelist section in flnml_static file&#39;)
<span class="linenos">1407</span>      if (mmpi_myid == 0) write(*,nml=namhyper)
<span class="linenos">1408</span>      ierr = fclos(nulnam)
<span class="linenos">1409</span>      do instrumentIndex=1, ninst
<span class="linenos">1410</span>        if (name_inst(instrumentIndex) == &#39;XXXXXX&#39; ) then
<span class="linenos">1411</span>          ninst_hyper = instrumentIndex - 1
<span class="linenos">1412</span>          exit
<span class="linenos">1413</span>        else
<span class="linenos">1414</span>          list_inst(instrumentIndex) = codtyp_get_codtyp( name_inst(instrumentIndex) )
<span class="linenos">1415</span>          if (list_inst(instrumentIndex) &lt; 0) then
<span class="linenos">1416</span>            write(*,*) name_inst(instrumentIndex)
<span class="linenos">1417</span>            call utl_abort(&#39;tvs_isIdBurpHyperSpectral: unknown instrument in namhyper namelist&#39;)
<span class="linenos">1418</span>          end if
<span class="linenos">1419</span>        end if
<span class="linenos">1420</span>      end do
<span class="linenos">1421</span>      if ( ninst_hyper == 0 ) call utl_abort(&#39;tvs_isIdBurpHyperSpectral: Empty namhyper namelist&#39;)
<span class="linenos">1422</span>      first = .false.
<span class="linenos">1423</span>    end if
<span class="linenos">1424</span>
<span class="linenos">1425</span>    tvs_isIdBurpHyperSpectral = .false.
<span class="linenos">1426</span>
<span class="linenos">1427</span>    do instrumentIndex = 1, ninst_hyper
<span class="linenos">1428</span>      if (idatyp == list_inst(instrumentIndex) ) then
<span class="linenos">1429</span>        tvs_isIdBurpHyperSpectral = .true.
<span class="linenos">1430</span>        exit
<span class="linenos">1431</span>      end if
<span class="linenos">1432</span>    end do
<span class="linenos">1433</span>
<span class="linenos">1434</span>  end function tvs_isIdBurpHyperSpectral
<span class="linenos">1435</span>
<span class="linenos">1436</span>  !--------------------------------------------------------------------------
<span class="linenos">1437</span>  !  tvs_isIdBurpInst
<span class="linenos">1438</span>  !--------------------------------------------------------------------------
<span class="linenos">1439</span>  logical function tvs_isIdBurpInst(idburp,cinst)
<span class="linenos">1440</span>    !
<span class="linenos">1441</span>    !:Purpose: function to check if the provided idburp (a.k.a. codtyp) corresponds to instrument cinst
<span class="linenos">1442</span>    !
<span class="linenos">1443</span>    implicit none
<span class="linenos">1444</span>
<span class="linenos">1445</span>    ! Arguments:
<span class="linenos">1446</span>    integer,          intent(in) :: idburp ! Input codtyp
<span class="linenos">1447</span>    character(len=*), intent(in) :: cinst  ! Input instrument name
<span class="linenos">1448</span>
<span class="linenos">1449</span>    if (tvs_nsensors == 0) then
<span class="linenos">1450</span>      ! no tovs data will be read, therefore false
<span class="linenos">1451</span>      tvs_isIdBurpInst = .false.
<span class="linenos">1452</span>      return
<span class="linenos">1453</span>    end if
<span class="linenos">1454</span>
<span class="linenos">1455</span>    tvs_isIdBurpInst = ( idburp == codtyp_get_codtyp(cinst) )
<span class="linenos">1456</span>
<span class="linenos">1457</span>  end function tvs_isIdBurpInst
<span class="linenos">1458</span>
<span class="linenos">1459</span>  !--------------------------------------------------------------------------
<span class="linenos">1460</span>  !  tvs_getPlatformId
<span class="linenos">1461</span>  !--------------------------------------------------------------------------
<span class="linenos">1462</span>  integer function tvs_getPlatformId(name)
<span class="linenos">1463</span>    !
<span class="linenos">1464</span>    !:Purpose: return RTTOV platform id (&gt;0) from platform name.
<span class="linenos">1465</span>    !           -1 if not found
<span class="linenos">1466</span>    implicit none
<span class="linenos">1467</span>
<span class="linenos">1468</span>    !Argument:
<span class="linenos">1469</span>    character(len=*), intent(in) :: name !Platform name
<span class="linenos">1470</span>    !Locals:
<span class="linenos">1471</span>    integer           :: platformIndex, length, ipos
<span class="linenos">1472</span>    character(len=64) :: tempo_name
<span class="linenos">1473</span>
<span class="linenos">1474</span>    tvs_getPlatformId = -1
<span class="linenos">1475</span>    length = len_trim(name)
<span class="linenos">1476</span>    call up2low(name(1:length),tempo_name(1:length))
<span class="linenos">1477</span>
<span class="linenos">1478</span>    if ( index(tempo_name(1:length),&#39;npp&#39;) /= 0 ) then
<span class="linenos">1479</span>      tvs_getPlatformId = platform_id_jpss
<span class="linenos">1480</span>    else if ( index(tempo_name(1:length),&#39;hmwari&#39;) /= 0 ) then
<span class="linenos">1481</span>      tvs_getPlatformId = platform_id_himawari
<span class="linenos">1482</span>    else
<span class="linenos">1483</span>      do platformIndex = 1, nplatforms
<span class="linenos">1484</span>        ipos = index(tempo_name(1:length),trim(platform_name(platformIndex)))
<span class="linenos">1485</span>        if (ipos == 1) then
<span class="linenos">1486</span>          tvs_getPlatformId = platformIndex
<span class="linenos">1487</span>          exit
<span class="linenos">1488</span>        end if
<span class="linenos">1489</span>      end do
<span class="linenos">1490</span>    end if
<span class="linenos">1491</span>
<span class="linenos">1492</span>  end function tvs_getPlatformId
<span class="linenos">1493</span>
<span class="linenos">1494</span>  !--------------------------------------------------------------------------
<span class="linenos">1495</span>  !  tvs_getInstrumentId
<span class="linenos">1496</span>  !--------------------------------------------------------------------------
<span class="linenos">1497</span>  integer function tvs_getInstrumentId(name)
<span class="linenos">1498</span>    !
<span class="linenos">1499</span>    !:Purpose: return RTTOV instrument id from intrument name. 0 is a valid answer.
<span class="linenos">1500</span>    !           -1 if not found
<span class="linenos">1501</span>    !
<span class="linenos">1502</span>    implicit none
<span class="linenos">1503</span>
<span class="linenos">1504</span>    !Argument:
<span class="linenos">1505</span>    character(len=*), intent(in) :: name ! Instrument name
<span class="linenos">1506</span>
<span class="linenos">1507</span>    !Locals:
<span class="linenos">1508</span>    integer           :: instrumentIndex, length
<span class="linenos">1509</span>    character(len=64) :: tempo_name
<span class="linenos">1510</span>
<span class="linenos">1511</span>    tvs_getInstrumentId = -1
<span class="linenos">1512</span>    length = len_trim(name)
<span class="linenos">1513</span>    call up2low(name(1:length),tempo_name(1:length))
<span class="linenos">1514</span>    if ( trim(tempo_name(1:length)) == &#39;goesim&#39; ) then
<span class="linenos">1515</span>      tvs_getInstrumentId = inst_id_goesim
<span class="linenos">1516</span>    else if ( trim(tempo_name(1:length)) == &#39;gmsim&#39; ) then
<span class="linenos">1517</span>      tvs_getInstrumentId = inst_id_gmsim
<span class="linenos">1518</span>    else if ( trim(tempo_name(1:length)) == &#39;mtsatim&#39; ) then
<span class="linenos">1519</span>      tvs_getInstrumentId = inst_id_mtsatim
<span class="linenos">1520</span>    else
<span class="linenos">1521</span>      do instrumentIndex = 0, ninst - 1
<span class="linenos">1522</span>        if (trim(inst_name(instrumentIndex)) == tempo_name(1:length) ) then
<span class="linenos">1523</span>          tvs_getInstrumentId = instrumentIndex
<span class="linenos">1524</span>          exit
<span class="linenos">1525</span>        end if
<span class="linenos">1526</span>      end do
<span class="linenos">1527</span>    end if
<span class="linenos">1528</span>  end function tvs_getInstrumentId
<span class="linenos">1529</span>
<span class="linenos">1530</span>  !--------------------------------------------------------------------------
<span class="linenos">1531</span>  !  tvs_isInstrumHyperSpectral
<span class="linenos">1532</span>  !--------------------------------------------------------------------------
<span class="linenos">1533</span>  logical function tvs_isInstrumHyperSpectral(instrum)
<span class="linenos">1534</span>    !
<span class="linenos">1535</span>    !:Purpose: given an RTTOV instrument code return if it is an hyperspectral one
<span class="linenos">1536</span>    !           information from namelist NAMHYPER
<span class="linenos">1537</span>    !
<span class="linenos">1538</span>    implicit none
<span class="linenos">1539</span>
<span class="linenos">1540</span>    ! Argument:
<span class="linenos">1541</span>    integer, intent(in) :: instrum     ! input Rttov instrument code
<span class="linenos">1542</span>
<span class="linenos">1543</span>    ! Locals:
<span class="linenos">1544</span>    integer, parameter :: maxsize = 100
<span class="linenos">1545</span>    integer :: nulnam, ierr, instrumentIndex 
<span class="linenos">1546</span>    integer, save :: list_inst(maxsize), ninst_hir
<span class="linenos">1547</span>    logical, save :: first = .true.
<span class="linenos">1548</span>    integer, external :: fclos, fnom
<span class="linenos">1549</span>
<span class="linenos">1550</span>    ! namelist variables
<span class="linenos">1551</span>    character (len=8) :: name_inst(maxsize) ! List of instrument names for hyperspectral IR
<span class="linenos">1552</span>    namelist /NAMHYPER/ name_inst
<span class="linenos">1553</span>    
<span class="linenos">1554</span>    if (first) then
<span class="linenos">1555</span>      if ( utl_isNamelistPresent(&#39;NAMHYPER&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1556</span>        call utl_abort(&#39;tvs_isInstrumHyperSpectral: NAMHYPER namelist section should be now in flnml_static !&#39;)
<span class="linenos">1557</span>      end if
<span class="linenos">1558</span>      nulnam = 0
<span class="linenos">1559</span>      ninst_hir = 0
<span class="linenos">1560</span>      name_inst(:) = &#39;XXXXXXX&#39;
<span class="linenos">1561</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1562</span>      read(nulnam,nml=namhyper, iostat=ierr)
<span class="linenos">1563</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isInstrumHyperSpectral: Error reading namelist section NAMHYPER in flnm_static file&#39;)
<span class="linenos">1564</span>      if (mmpi_myid == 0) write(*,nml=namhyper)
<span class="linenos">1565</span>      ierr = fclos(nulnam)
<span class="linenos">1566</span>      list_inst(:) = -1
<span class="linenos">1567</span>      do instrumentIndex=1, maxsize
<span class="linenos">1568</span>        list_inst(instrumentIndex) = tvs_getInstrumentId( name_inst(instrumentIndex) )
<span class="linenos">1569</span>        if (name_inst(instrumentIndex) /= &#39;XXXXXXX&#39;) then
<span class="linenos">1570</span>          if (list_inst(instrumentIndex) == -1) then
<span class="linenos">1571</span>            write(*,*) instrumentIndex,name_inst(instrumentIndex)
<span class="linenos">1572</span>            call utl_abort(&#39;tvs_isInstrumHyperSpectral: Unknown instrument name&#39;)
<span class="linenos">1573</span>          end if
<span class="linenos">1574</span>        else
<span class="linenos">1575</span>          ninst_hir = instrumentIndex - 1
<span class="linenos">1576</span>          exit
<span class="linenos">1577</span>        end if
<span class="linenos">1578</span>      end do
<span class="linenos">1579</span>      first = .false.
<span class="linenos">1580</span>      if (ninst_hir == 0) then
<span class="linenos">1581</span>        write(*,*) &#39;tvs_isInstrumHyperSpectral: Warning : empty namhyper namelist !&#39;
<span class="linenos">1582</span>      end if
<span class="linenos">1583</span>    end if
<span class="linenos">1584</span>    tvs_isInstrumHyperSpectral = .false.
<span class="linenos">1585</span>    do instrumentIndex =1, ninst_hir
<span class="linenos">1586</span>      if ( instrum == list_inst(instrumentIndex)) then
<span class="linenos">1587</span>        tvs_isInstrumHyperSpectral = .true.
<span class="linenos">1588</span>        exit
<span class="linenos">1589</span>      end if
<span class="linenos">1590</span>    end do
<span class="linenos">1591</span>
<span class="linenos">1592</span>  end function tvs_isInstrumHyperSpectral
<span class="linenos">1593</span>
<span class="linenos">1594</span>  !--------------------------------------------------------------------------
<span class="linenos">1595</span>  !  tvs_isNameHyperSpectral
<span class="linenos">1596</span>  !--------------------------------------------------------------------------
<span class="linenos">1597</span>  logical function tvs_isNameHyperSpectral(cinstrum)
<span class="linenos">1598</span>    !
<span class="linenos">1599</span>    !:Purpose: given an instrument name
<span class="linenos">1600</span>    !           returns if it is an hyperspectral one
<span class="linenos">1601</span>    !           (information from namelist NAMHYPER)
<span class="linenos">1602</span>    implicit none
<span class="linenos">1603</span>    !Arguments:
<span class="linenos">1604</span>    character(len=*), intent(in) :: cinstrum
<span class="linenos">1605</span>    !Locals:
<span class="linenos">1606</span>    integer, parameter :: maxsize = 20
<span class="linenos">1607</span>    integer :: nulnam, ierr, i 
<span class="linenos">1608</span>    integer, save :: ninst_hir
<span class="linenos">1609</span>    logical, save :: lfirst = .true.
<span class="linenos">1610</span>    integer, external :: fclos, fnom
<span class="linenos">1611</span>    character (len=8) :: name2
<span class="linenos">1612</span>
<span class="linenos">1613</span>    ! namelist variables
<span class="linenos">1614</span>    character (len=8),save  :: name_inst(maxsize) ! List of instrument names for hyperspectral IR
<span class="linenos">1615</span>    namelist /NAMHYPER/ name_inst
<span class="linenos">1616</span>
<span class="linenos">1617</span>    if (lfirst) then
<span class="linenos">1618</span>      nulnam = 0
<span class="linenos">1619</span>      ninst_hir = 0
<span class="linenos">1620</span>      name_inst(:) = &#39;XXXXXXX&#39;
<span class="linenos">1621</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1622</span>      read(nulnam,nml=namhyper, iostat=ierr)
<span class="linenos">1623</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isNameHyperSpectral: Error reading NAMHYPER namelist section in flnml_static file&#39;)
<span class="linenos">1624</span>      if (mmpi_myid == 0) write(*,nml=namhyper)
<span class="linenos">1625</span>      ierr = fclos(nulnam)
<span class="linenos">1626</span>      do i=1, maxsize
<span class="linenos">1627</span>        if (name_inst(i) == &#39;XXXXXXX&#39;) then
<span class="linenos">1628</span>          ninst_hir = i -1
<span class="linenos">1629</span>          exit
<span class="linenos">1630</span>        end if
<span class="linenos">1631</span>      end do
<span class="linenos">1632</span>      lfirst = .false.
<span class="linenos">1633</span>      if (ninst_hir == 0) then
<span class="linenos">1634</span>        write(*,*) &#39;tvs_isNameHyperSpectral: Warning : empty namhyper namelist !&#39;
<span class="linenos">1635</span>      end if
<span class="linenos">1636</span>    end if
<span class="linenos">1637</span>
<span class="linenos">1638</span>    tvs_isNameHyperSpectral = .false.
<span class="linenos">1639</span>
<span class="linenos">1640</span>    call up2low(cinstrum, name2)
<span class="linenos">1641</span>
<span class="linenos">1642</span>    do i=1, ninst_hir
<span class="linenos">1643</span>      if ( trim(name2) == name_inst(i)) then
<span class="linenos">1644</span>        tvs_isNameHyperSpectral = .true.
<span class="linenos">1645</span>        exit
<span class="linenos">1646</span>      end if
<span class="linenos">1647</span>    end do
<span class="linenos">1648</span>
<span class="linenos">1649</span>  end function tvs_isNameHyperSpectral
<span class="linenos">1650</span>
<span class="linenos">1651</span>  !--------------------------------------------------------------------------
<span class="linenos">1652</span>  !  tvs_isInstrumGeostationary
<span class="linenos">1653</span>  !--------------------------------------------------------------------------
<span class="linenos">1654</span>  logical function tvs_isInstrumGeostationary(instrum)
<span class="linenos">1655</span>    !
<span class="linenos">1656</span>    !:Purpose: given an RTTOV instrument code return if it is a Geostationnary Imager
<span class="linenos">1657</span>    !           information from namelist NAMGEO
<span class="linenos">1658</span>    !
<span class="linenos">1659</span>    implicit none
<span class="linenos">1660</span>
<span class="linenos">1661</span>    ! Argument:
<span class="linenos">1662</span>    integer, intent(in) :: instrum ! input Rttov instrument code
<span class="linenos">1663</span>
<span class="linenos">1664</span>    ! Locals:
<span class="linenos">1665</span>    integer, parameter :: maxsize = 100
<span class="linenos">1666</span>    integer :: nulnam, ierr, instrumentIndex 
<span class="linenos">1667</span>    integer, save :: list_inst(maxsize), ninst_geo
<span class="linenos">1668</span>    logical, save :: first = .true.
<span class="linenos">1669</span>    integer, external :: fnom, fclos
<span class="linenos">1670</span>
<span class="linenos">1671</span>    ! namelist variables
<span class="linenos">1672</span>    character(len=8) :: name_inst(maxsize) ! List of instrument names for geostationary
<span class="linenos">1673</span>    namelist /NAMGEO/ name_inst
<span class="linenos">1674</span>
<span class="linenos">1675</span>    if (first) then
<span class="linenos">1676</span>      if ( utl_isNamelistPresent(&#39;NAMGEO&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1677</span>        call utl_abort(&#39;tvs_isInstrumGeostationary: NAMGEO namelist section should be now in flnml_static !&#39;)
<span class="linenos">1678</span>      end if
<span class="linenos">1679</span>      nulnam = 0
<span class="linenos">1680</span>      ninst_geo = 0
<span class="linenos">1681</span>      name_inst(:) = &#39;XXXXXX&#39;
<span class="linenos">1682</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1683</span>      read(nulnam,nml=namgeo, iostat=ierr)
<span class="linenos">1684</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isInstrumGeostationary: Error reading namelist section NAMGEO in flnml_static file&#39;)
<span class="linenos">1685</span>      if (mmpi_myid == 0) write(*,nml=namgeo)
<span class="linenos">1686</span>      ierr = fclos(nulnam)
<span class="linenos">1687</span>      list_inst(:) = -1
<span class="linenos">1688</span>      do instrumentIndex=1, maxsize
<span class="linenos">1689</span>        list_inst(instrumentIndex) = tvs_getInstrumentId( name_inst(instrumentIndex) )
<span class="linenos">1690</span>        if (name_inst(instrumentIndex) /= &#39;XXXXXX&#39;) then
<span class="linenos">1691</span>          if (list_inst(instrumentIndex) == -1) then
<span class="linenos">1692</span>            write(*,*) instrumentIndex,name_inst(instrumentIndex)
<span class="linenos">1693</span>            call utl_abort(&#39;tvs_isInstrumGeostationary: Unknown instrument name&#39;)
<span class="linenos">1694</span>          end if
<span class="linenos">1695</span>        else
<span class="linenos">1696</span>          ninst_geo = instrumentIndex - 1
<span class="linenos">1697</span>          exit
<span class="linenos">1698</span>        end if
<span class="linenos">1699</span>      end do
<span class="linenos">1700</span>      first = .false.
<span class="linenos">1701</span>      if (ninst_geo == 0) then
<span class="linenos">1702</span>        write(*,*) &#39;tvs_isInstrumGeostationary: Warning : empty namgeo namelist !&#39;
<span class="linenos">1703</span>      end if
<span class="linenos">1704</span>    end if
<span class="linenos">1705</span>    tvs_isInstrumGeostationary = .false.
<span class="linenos">1706</span>    do instrumentIndex=1, ninst_geo
<span class="linenos">1707</span>      if ( instrum == list_inst(instrumentIndex)) then
<span class="linenos">1708</span>        tvs_isInstrumGeostationary = .true.
<span class="linenos">1709</span>        exit
<span class="linenos">1710</span>      end if
<span class="linenos">1711</span>    end do
<span class="linenos">1712</span>    
<span class="linenos">1713</span>  end function tvs_isInstrumGeostationary
<span class="linenos">1714</span>
<span class="linenos">1715</span>  !--------------------------------------------------------------------------
<span class="linenos">1716</span>  !  tvs_isInstrumUsingCLW
<span class="linenos">1717</span>  !--------------------------------------------------------------------------
<span class="linenos">1718</span>  function tvs_isInstrumUsingCLW(instrumId) result(idExist)
<span class="linenos">1719</span>    !
<span class="linenos">1720</span>    !:Purpose: given an RTTOV instrument code return if it is in the list to use CLW
<span class="linenos">1721</span>    !
<span class="linenos">1722</span>    implicit none
<span class="linenos">1723</span>
<span class="linenos">1724</span>    ! Argument:
<span class="linenos">1725</span>    integer, intent(in) :: instrumId     ! input Rttov instrument code
<span class="linenos">1726</span>    logical             :: idExist
<span class="linenos">1727</span>
<span class="linenos">1728</span>    ! Locals:
<span class="linenos">1729</span>    integer :: instrumentIndex 
<span class="linenos">1730</span>
<span class="linenos">1731</span>    idExist = .false.
<span class="linenos">1732</span>    do instrumentIndex = 1, tvs_numMWInstrumUsingCLW
<span class="linenos">1733</span>      if ( instrumId == instrumentIdsUsingCLW(instrumentIndex) ) then
<span class="linenos">1734</span>        idExist = .true.
<span class="linenos">1735</span>        exit
<span class="linenos">1736</span>      end if
<span class="linenos">1737</span>    end do
<span class="linenos">1738</span>
<span class="linenos">1739</span>  end function tvs_isInstrumUsingCLW
<span class="linenos">1740</span>
<span class="linenos">1741</span>  !--------------------------------------------------------------------------
<span class="linenos">1742</span>  !  tvs_isInstrumUsingHydrometeors
<span class="linenos">1743</span>  !--------------------------------------------------------------------------
<span class="linenos">1744</span>  function tvs_isInstrumUsingHydrometeors(instrumId) result(idExist)
<span class="linenos">1745</span>    !
<span class="linenos">1746</span>    !:Purpose: given an RTTOV instrument code return if it is in the list to use Hydrometeors
<span class="linenos">1747</span>    !
<span class="linenos">1748</span>    implicit none
<span class="linenos">1749</span>
<span class="linenos">1750</span>    ! Argument:
<span class="linenos">1751</span>    integer, intent(in) :: instrumId     ! input Rttov instrument code
<span class="linenos">1752</span>    logical             :: idExist
<span class="linenos">1753</span>
<span class="linenos">1754</span>    ! Locals:
<span class="linenos">1755</span>    integer :: instrumentIndex 
<span class="linenos">1756</span>
<span class="linenos">1757</span>    idExist = .false.
<span class="linenos">1758</span>    do instrumentIndex = 1, tvs_numMWInstrumUsingHydrometeors
<span class="linenos">1759</span>      if ( instrumId == instrumentIdsUsingHydrometeors(instrumentIndex) ) then
<span class="linenos">1760</span>        idExist = .true.
<span class="linenos">1761</span>        exit
<span class="linenos">1762</span>      end if
<span class="linenos">1763</span>    end do
<span class="linenos">1764</span>
<span class="linenos">1765</span>  end function tvs_isInstrumUsingHydrometeors
<span class="linenos">1766</span>
<span class="linenos">1767</span>  !--------------------------------------------------------------------------
<span class="linenos">1768</span>  !  tvs_isInstrumAllskyTtAssim
<span class="linenos">1769</span>  !--------------------------------------------------------------------------
<span class="linenos">1770</span>  function tvs_isInstrumAllskyTtAssim(instrumId) result(allskyTtAssim)
<span class="linenos">1771</span>    !
<span class="linenos">1772</span>    !:Purpose: determine if all-sky temperature-channel assimilation is asked for the instrument.
<span class="linenos">1773</span>    !
<span class="linenos">1774</span>    implicit none
<span class="linenos">1775</span>
<span class="linenos">1776</span>    ! Argument:
<span class="linenos">1777</span>    integer, intent(in) :: instrumId     ! input Rttov instrument code
<span class="linenos">1778</span>    logical             :: allskyTtAssim
<span class="linenos">1779</span>
<span class="linenos">1780</span>    allskyTtAssim = (tvs_mwAllskyAssim .and. tvs_isInstrumUsingCLW(instrumId))
<span class="linenos">1781</span>
<span class="linenos">1782</span>  end function tvs_isInstrumAllskyTtAssim
<span class="linenos">1783</span>
<span class="linenos">1784</span>  !--------------------------------------------------------------------------
<span class="linenos">1785</span>  !  tvs_isInstrumAllskyHuAssim
<span class="linenos">1786</span>  !--------------------------------------------------------------------------
<span class="linenos">1787</span>  function tvs_isInstrumAllskyHuAssim(instrumId) result(allskyHuAssim)
<span class="linenos">1788</span>    !
<span class="linenos">1789</span>    !:Purpose: determine if all-sky humidity-channel assimilation is asked for the instrument.
<span class="linenos">1790</span>    !
<span class="linenos">1791</span>    implicit none
<span class="linenos">1792</span>
<span class="linenos">1793</span>    ! Argument:
<span class="linenos">1794</span>    integer, intent(in) :: instrumId     ! input Rttov instrument code
<span class="linenos">1795</span>    logical             :: allskyHuAssim
<span class="linenos">1796</span>
<span class="linenos">1797</span>    allskyHuAssim = (tvs_mwAllskyAssim .and. tvs_isInstrumUsingHydrometeors(instrumId))
<span class="linenos">1798</span>
<span class="linenos">1799</span>  end function tvs_isInstrumAllskyHuAssim
<span class="linenos">1800</span>
<span class="linenos">1801</span>  !--------------------------------------------------------------------------
<span class="linenos">1802</span>  !  tvs_mapInstrum
<span class="linenos">1803</span>  !--------------------------------------------------------------------------
<span class="linenos">1804</span>  subroutine tvs_mapInstrum(instrumburp,instrum)
<span class="linenos">1805</span>    !
<span class="linenos">1806</span>    !:Purpose:  Map burp satellite instrument (element #2019) to RTTOV-7 instrument.
<span class="linenos">1807</span>    !            A negative value is returned, if no match in found.
<span class="linenos">1808</span>    !
<span class="linenos">1809</span>    !:Table of  RTTOV-7 instrument identifier:
<span class="linenos">1810</span>    !
<span class="linenos">1811</span>    ! ==================  =====================  ==================
<span class="linenos">1812</span>    ! Instrument          Instrument identifier  Sensor type
<span class="linenos">1813</span>    ! ==================  =====================  ==================
<span class="linenos">1814</span>    !               HIRS               0                     ir
<span class="linenos">1815</span>    !                MSU               1                     mw
<span class="linenos">1816</span>    !                SSU               2                     ir
<span class="linenos">1817</span>    !              AMSUA               3                     mw
<span class="linenos">1818</span>    !              AMSUB               4                     mw
<span class="linenos">1819</span>    !              AVHRR               5                     ir
<span class="linenos">1820</span>    !               SSMI               6                     mw
<span class="linenos">1821</span>    !              VTPR1               7                     ir
<span class="linenos">1822</span>    !              VTPR2               8                     ir
<span class="linenos">1823</span>    !                TMI               9                     mw
<span class="linenos">1824</span>    !              SSMIS              10                     mw
<span class="linenos">1825</span>    !               AIRS              11                     ir
<span class="linenos">1826</span>    !              MODIS              13                     ir
<span class="linenos">1827</span>    !               ATSR              14                     ir
<span class="linenos">1828</span>    !                MHS              15                     mw
<span class="linenos">1829</span>    !               ATMS              19                     mw
<span class="linenos">1830</span>    !              MVIRI              20                     ir
<span class="linenos">1831</span>    !             SEVIRI              21                     ir
<span class="linenos">1832</span>    !         GOESIMAGER              22                     ir
<span class="linenos">1833</span>    !        GOESSOUNDER              23                     ir
<span class="linenos">1834</span>    !   GMS/MTSAT IMAGER              24                     ir
<span class="linenos">1835</span>    !          FY2-VISSR              25                     ir
<span class="linenos">1836</span>    !          FY1-MVISR              26                     ir
<span class="linenos">1837</span>    !                AHI              56                     ir
<span class="linenos">1838</span>    ! ==================  =====================  ==================
<span class="linenos">1839</span>    implicit none
<span class="linenos">1840</span>    !Arguments:
<span class="linenos">1841</span>    integer, intent(in)  :: instrumburp  ! burp satellite instrument (element #2019)
<span class="linenos">1842</span>    integer, intent(out) :: instrum      ! RTTOV-7 instrument ID numbers (e.g. 3 for  AMSUA)
<span class="linenos">1843</span>  
<span class="linenos">1844</span>    !Locals:  
<span class="linenos">1845</span>    integer instrumentIndex, numinstburp
<span class="linenos">1846</span>    integer, parameter :: mxinstrumburp   = 100
<span class="linenos">1847</span>    logical, save :: first = .true.
<span class="linenos">1848</span>    integer :: nulnam, ier
<span class="linenos">1849</span>    integer, external :: fnom, fclos
<span class="linenos">1850</span>
<span class="linenos">1851</span>    ! namelist variables
<span class="linenos">1852</span>    integer, save ::   listburp(mxinstrumburp)           ! List of instrument ID values from obs file
<span class="linenos">1853</span>    character(len=8), save :: listinstrum(mxinstrumburp) ! List of instrument names
<span class="linenos">1854</span>    namelist /NAMINST/ listburp, listinstrum
<span class="linenos">1855</span>
<span class="linenos">1856</span>    !      Table of BURP satellite sensor identifier element #002019
<span class="linenos">1857</span>
<span class="linenos">1858</span>    !   1.0 Find instrument
<span class="linenos">1859</span>
<span class="linenos">1860</span>    if (first) then
<span class="linenos">1861</span>      if ( utl_isNamelistPresent(&#39;NAMINST&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1862</span>        call utl_abort(&#39;tvs_mapInstrum: NAMINST namelist section should be now in flnml_static !&#39;)
<span class="linenos">1863</span>      end if
<span class="linenos">1864</span>      
<span class="linenos">1865</span>      ! set the default values
<span class="linenos">1866</span>      listburp(:) = -1
<span class="linenos">1867</span>      listinstrum(:) = &#39;XXXXXXXX&#39;
<span class="linenos">1868</span>
<span class="linenos">1869</span>      ! read the namelist
<span class="linenos">1870</span>      nulnam = 0
<span class="linenos">1871</span>      ier = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1872</span>      if (ier /= 0) then
<span class="linenos">1873</span>        write(*,*) &#39;Error while opening flnml_static namelist file !&#39;
<span class="linenos">1874</span>        call utl_abort(&#39;tvs_mapInstrum&#39;)
<span class="linenos">1875</span>      end if
<span class="linenos">1876</span>      read(nulnam,NAMINST,iostat=ier)
<span class="linenos">1877</span>      if (ier /= 0) then
<span class="linenos">1878</span>        write(*,*) &#39;Error while reading NAMINST namelist section in flnml_static file !&#39;
<span class="linenos">1879</span>        call utl_abort(&#39;tvs_mapInstrum&#39;)
<span class="linenos">1880</span>      end if
<span class="linenos">1881</span>      ier = fclos(nulnam)
<span class="linenos">1882</span>
<span class="linenos">1883</span>      ! figure out how many valid elements in the lists
<span class="linenos">1884</span>      do instrumentIndex=1, mxinstrumburp
<span class="linenos">1885</span>        if(listburp(instrumentIndex) == -1) then
<span class="linenos">1886</span>          numinstburp = instrumentIndex - 1
<span class="linenos">1887</span>          exit
<span class="linenos">1888</span>        end if
<span class="linenos">1889</span>      end do
<span class="linenos">1890</span>      if (numinstburp &gt; mxinstrumburp) then
<span class="linenos">1891</span>        call utl_abort(&#39;tvs_mapInstrum: exceeded maximum number of platforms&#39;)
<span class="linenos">1892</span>      end if
<span class="linenos">1893</span>      write(*,*) &#39;tvs_mapInstrum: number of satellites found in namelist = &#39;,numinstburp
<span class="linenos">1894</span>      write(*,*) &#39;tvs_mapInstrum: listburp   = &#39;,listburp(1:numinstburp)
<span class="linenos">1895</span>      write(*,*) &#39;tvs_mapInstrum: listinstrum    = &#39;,listinstrum(1:numinstburp)
<span class="linenos">1896</span>      first=.false.
<span class="linenos">1897</span>    end if
<span class="linenos">1898</span>
<span class="linenos">1899</span>    instrum = -1
<span class="linenos">1900</span>    do instrumentIndex=1, mxinstrumburp
<span class="linenos">1901</span>      if ( instrumburp == listburp(instrumentIndex) ) then
<span class="linenos">1902</span>        instrum = tvs_getInstrumentId( listinstrum(instrumentIndex) )
<span class="linenos">1903</span>        exit
<span class="linenos">1904</span>      end if
<span class="linenos">1905</span>    end do
<span class="linenos">1906</span>
<span class="linenos">1907</span>  end subroutine tvs_mapInstrum
<span class="linenos">1908</span>
<span class="linenos">1909</span>  !--------------------------------------------------------------------------
<span class="linenos">1910</span>  !  tvs_isNameGeostationary
<span class="linenos">1911</span>  !--------------------------------------------------------------------------
<span class="linenos">1912</span>  logical function tvs_isNameGeostationary(cinstrum)
<span class="linenos">1913</span>    !:Purpose: given an instrument name following BUFR convention
<span class="linenos">1914</span>    !           returns if it is a Geostationnary Imager
<span class="linenos">1915</span>    !           (information from namelist NAMGEOBUFR)
<span class="linenos">1916</span>    implicit none
<span class="linenos">1917</span>    !Arguments:
<span class="linenos">1918</span>    character(len=*), intent(in) :: cinstrum
<span class="linenos">1919</span>    !Locals:
<span class="linenos">1920</span>    integer, parameter :: maxsize = 100
<span class="linenos">1921</span>    integer :: nulnam, ierr, i 
<span class="linenos">1922</span>    integer, save :: ninst_geo
<span class="linenos">1923</span>    logical, save :: lfirst = .true.
<span class="linenos">1924</span>    integer, external :: fnom, fclos
<span class="linenos">1925</span>
<span class="linenos">1926</span>    ! namelist variables
<span class="linenos">1927</span>    character (len=8),save :: name_inst(maxsize) ! List of instrument names for geostationary
<span class="linenos">1928</span>    namelist /NAMGEOBUFR/ name_inst
<span class="linenos">1929</span>
<span class="linenos">1930</span>    if (lfirst) then
<span class="linenos">1931</span>      if ( utl_isNamelistPresent(&#39;NAMGEOBUFR&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">1932</span>        call utl_abort(&#39;tvs_isNameGeostationary: NAMGEOBUFR namelist section should be now in flnml_static !&#39;)
<span class="linenos">1933</span>      end if
<span class="linenos">1934</span>      nulnam = 0
<span class="linenos">1935</span>      ninst_geo = 0
<span class="linenos">1936</span>      name_inst(:) = &#39;XXXXXXXX&#39;
<span class="linenos">1937</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">1938</span>      read(nulnam,nml=namgeobufr, iostat=ierr)
<span class="linenos">1939</span>      if (ierr /= 0) call utl_abort(&#39;tvs_isNameGeostationary: Error reading namelist section NAMGEOBUFR in flnml_static_file&#39;)
<span class="linenos">1940</span>      if (mmpi_myid == 0) write(*,nml=namgeobufr)
<span class="linenos">1941</span>      ierr = fclos(nulnam)
<span class="linenos">1942</span>      do i=1, maxsize
<span class="linenos">1943</span>        if (name_inst(i) == &#39;XXXXXXXX&#39;) then
<span class="linenos">1944</span>          ninst_geo = i - 1
<span class="linenos">1945</span>          exit
<span class="linenos">1946</span>        end if
<span class="linenos">1947</span>      end do
<span class="linenos">1948</span>      lfirst = .false.
<span class="linenos">1949</span>      if (ninst_geo == 0) then
<span class="linenos">1950</span>        write(*,*) &#39;tvs_isNameGeostationary: Warning : empty namgeobufr namelist !&#39; 
<span class="linenos">1951</span>      end if
<span class="linenos">1952</span>    end if
<span class="linenos">1953</span>    
<span class="linenos">1954</span>    tvs_isNameGeostationary = .false.
<span class="linenos">1955</span>    do i=1, ninst_geo
<span class="linenos">1956</span>      if ( trim(cinstrum) == trim(name_inst(i)) ) then
<span class="linenos">1957</span>        tvs_isNameGeostationary= .true.
<span class="linenos">1958</span>        exit
<span class="linenos">1959</span>      end if
<span class="linenos">1960</span>    end do
<span class="linenos">1961</span>    
<span class="linenos">1962</span>  end function tvs_isNameGeostationary
<span class="linenos">1963</span>
<span class="linenos">1964</span>  !--------------------------------------------------------------------------
<span class="linenos">1965</span>  !  tvs_mapSat
<span class="linenos">1966</span>  !--------------------------------------------------------------------------
<span class="linenos">1967</span>  subroutine tvs_mapSat(isatBURP,iplatform,isat)
<span class="linenos">1968</span>    !
<span class="linenos">1969</span>    !:Purpose:  Map burp satellite identifier (element #1007)
<span class="linenos">1970</span>    !            to RTTOV-7 platform and satellite.
<span class="linenos">1971</span>    !            Negative values are returned, if no match in found.
<span class="linenos">1972</span>    !
<span class="linenos">1973</span>    !:Table of  RTTOV-7 platform identifier:
<span class="linenos">1974</span>    !
<span class="linenos">1975</span>    ! ========          ===========================
<span class="linenos">1976</span>    ! Platform          RTTOV-7 platform identifier
<span class="linenos">1977</span>    ! ========          ===========================
<span class="linenos">1978</span>    !     NOAA               1
<span class="linenos">1979</span>    !     DMSP               2
<span class="linenos">1980</span>    ! METEOSAT               3
<span class="linenos">1981</span>    !     GOES               4
<span class="linenos">1982</span>    !      GMS               5
<span class="linenos">1983</span>    !      FY2               6
<span class="linenos">1984</span>    !     TRMM               7
<span class="linenos">1985</span>    !      ERS               8
<span class="linenos">1986</span>    !      EOS               9
<span class="linenos">1987</span>    !    METOP              10
<span class="linenos">1988</span>    !  ENVISAT              11
<span class="linenos">1989</span>    !      MSG              12
<span class="linenos">1990</span>    !      FY1              13
<span class="linenos">1991</span>    !    ADEOS              14
<span class="linenos">1992</span>    !    MTSAT              15
<span class="linenos">1993</span>    ! CORIOLIS              16
<span class="linenos">1994</span>    !      NPP              17
<span class="linenos">1995</span>    ! ========          ===========================
<span class="linenos">1996</span>    !
<span class="linenos">1997</span>    !:Example: 
<span class="linenos">1998</span>    !          NOAA15, which has a burp satellite identifier value of 206,
<span class="linenos">1999</span>    !          is mapped into the following:
<span class="linenos">2000</span>    !          RTTOV-7 platform  =  1,
<span class="linenos">2001</span>    !          RTTOV-7 satellite = 15.
<span class="linenos">2002</span>    !
<span class="linenos">2003</span>    !:Arguments:
<span class="linenos">2004</span>    !     :isatBURP: BURP satellite identifier
<span class="linenos">2005</span>    !     :iplatform: RTTOV-7 platform ID numbers (e.g. 1 for  NOAA)
<span class="linenos">2006</span>    !     :isat: RTTOV-7 satellite ID numbers (e.g. 15)
<span class="linenos">2007</span>    !
<span class="linenos">2008</span>
<span class="linenos">2009</span>    implicit none
<span class="linenos">2010</span>    
<span class="linenos">2011</span>    ! Arguments:
<span class="linenos">2012</span>    integer, intent(in)  :: isatburp   ! BURP satellite identifier
<span class="linenos">2013</span>    integer, intent(out) :: iplatform  ! RTTOV-7 platform ID numbers (e.g. 1 for  NOAA)
<span class="linenos">2014</span>    integer, intent(out) :: isat       ! RTTOV-7 satellite ID numbers (e.g. 15)
<span class="linenos">2015</span>
<span class="linenos">2016</span>    ! Locals:
<span class="linenos">2017</span>    integer           :: satelliteIndex, ierr, nulnam
<span class="linenos">2018</span>    logical, save     :: first=.true.
<span class="linenos">2019</span>    integer, external :: fnom, fclos
<span class="linenos">2020</span>    integer, parameter:: mxsatburp = 100
<span class="linenos">2021</span>    integer, save     :: numsatburp
<span class="linenos">2022</span>
<span class="linenos">2023</span>    ! namelist variables
<span class="linenos">2024</span>    integer, save          :: listburp(mxsatburp) ! Table of BURP satellite identifier element #001007
<span class="linenos">2025</span>    character(len=8), save :: listplat(mxsatburp) ! Table of RTTOV platform identifier
<span class="linenos">2026</span>    integer, save          :: listsat (mxsatburp) ! Table of RTTOV satellite identifier
<span class="linenos">2027</span>
<span class="linenos">2028</span>    namelist /NAMSAT/ listburp, listplat, listsat
<span class="linenos">2029</span>
<span class="linenos">2030</span>    !     Fill tables from namelist at the first call 
<span class="linenos">2031</span>    if (first) then
<span class="linenos">2032</span>      if ( utl_isNamelistPresent(&#39;NAMSAT&#39;, &#39;./flnml&#39;) ) then
<span class="linenos">2033</span>        call utl_abort(&#39;tvs_mapSat: NAMSAT namelist section should be now in flnml_static !&#39;)
<span class="linenos">2034</span>      end if
<span class="linenos">2035</span>      ! set the default values
<span class="linenos">2036</span>      listburp(:) = -1
<span class="linenos">2037</span>      listsat(:) = -1
<span class="linenos">2038</span>      listplat(:) = &#39;XXXXXXXX&#39;
<span class="linenos">2039</span>      ! read the namelist
<span class="linenos">2040</span>      nulnam = 0
<span class="linenos">2041</span>      ierr = fnom(nulnam,&#39;./flnml_static&#39;,&#39;FTN+SEQ+R/O&#39;,0)
<span class="linenos">2042</span>      if (ierr /= 0) then
<span class="linenos">2043</span>        write(*,*) &#39;Error while opening namelist flnml_static file !&#39;
<span class="linenos">2044</span>        call utl_abort(&#39;tvs_mapSat&#39;)
<span class="linenos">2045</span>      end if
<span class="linenos">2046</span>      read(nulnam, NAMSAT, iostat = ierr)
<span class="linenos">2047</span>      if (ierr /= 0) then
<span class="linenos">2048</span>        write(*,*) &#39;Error while reading NAMSAT namelist section in flnml_static file !&#39;
<span class="linenos">2049</span>        call utl_abort(&#39;tvs_mapSat&#39;)
<span class="linenos">2050</span>      end if
<span class="linenos">2051</span>      ierr = fclos(nulnam)
<span class="linenos">2052</span>
<span class="linenos">2053</span>      !  Figure out how many valid elements in the lists
<span class="linenos">2054</span>      do satelliteIndex=1, mxsatburp
<span class="linenos">2055</span>        if(listburp(satelliteIndex) == -1) then
<span class="linenos">2056</span>          numsatburp = satelliteIndex - 1
<span class="linenos">2057</span>          exit
<span class="linenos">2058</span>        end if
<span class="linenos">2059</span>      end do
<span class="linenos">2060</span>      if(numsatburp &gt;= mxsatburp) then
<span class="linenos">2061</span>        call utl_abort(&#39;tvs_mapSat: exceeded maximum number of platforms&#39;)
<span class="linenos">2062</span>      end if
<span class="linenos">2063</span>      write(*,*) &#39;tvs_mapSat: number of satellites found in namelist = &#39;,numsatburp
<span class="linenos">2064</span>      write(*,*) &#39;tvs_mapSat: listburp   = &#39;,listburp(1:numsatburp)
<span class="linenos">2065</span>      write(*,*) &#39;tvs_mapSat: listsat    = &#39;,listsat(1:numsatburp)
<span class="linenos">2066</span>      write(*,*) &#39;tvs_mapSat: listplat   = &#39;,listplat(1:numsatburp)
<span class="linenos">2067</span>      first = .false.
<span class="linenos">2068</span>    end if
<span class="linenos">2069</span>
<span class="linenos">2070</span>    !   Find platform and satellite
<span class="linenos">2071</span>
<span class="linenos">2072</span>    iplatform = -1
<span class="linenos">2073</span>    isat      = -1
<span class="linenos">2074</span>    do satelliteIndex=1, numsatburp
<span class="linenos">2075</span>      if ( isatburp == listburp(satelliteIndex) ) then
<span class="linenos">2076</span>        iplatform = tvs_getPlatformId( listplat(satelliteIndex) )
<span class="linenos">2077</span>        isat = listsat (satelliteIndex)
<span class="linenos">2078</span>        exit
<span class="linenos">2079</span>      end if
<span class="linenos">2080</span>    end do
<span class="linenos">2081</span>
<span class="linenos">2082</span>  end subroutine tvs_mapSat
<span class="linenos">2083</span>
<span class="linenos">2084</span>  !--------------------------------------------------------------------------
<span class="linenos">2085</span>  !  tvs_getChanProf
<span class="linenos">2086</span>  !--------------------------------------------------------------------------
<span class="linenos">2087</span>  subroutine tvs_getChanprof(sensorTovsIndexes, obsSpaceData, chanprof, lchannel_subset_opt, iptobs_cma_opt)
<span class="linenos">2088</span>    ! 
<span class="linenos">2089</span>    !:Purpose: subroutine to initialize the chanprof structure used by RTTOV
<span class="linenos">2090</span>    !
<span class="linenos">2091</span>    implicit none
<span class="linenos">2092</span>
<span class="linenos">2093</span>    ! Arguments:
<span class="linenos">2094</span>    integer, intent(in)              :: sensorTovsIndexes(:)
<span class="linenos">2095</span>    type(struct_obs), intent(in)     :: obsSpaceData
<span class="linenos">2096</span>    type(rttov_chanprof), intent(out):: chanprof(:)
<span class="linenos">2097</span>    logical, intent(out), optional   :: lchannel_subset_opt(:,:)
<span class="linenos">2098</span>    integer, intent(out), optional   :: iptobs_cma_opt(:)
<span class="linenos">2099</span>
<span class="linenos">2100</span>    ! Locals:
<span class="linenos">2101</span>    integer :: count, profileIndex, headerIndex, istart, iend, bodyIndex, channelNumber, iobs
<span class="linenos">2102</span>    integer :: ChannelIndex
<span class="linenos">2103</span>
<span class="linenos">2104</span>    ! Build the list of channels/profiles indices
<span class="linenos">2105</span>    count = 0
<span class="linenos">2106</span>    if (present( lchannel_subset_opt )) lchannel_subset_opt(:,:) = .false.
<span class="linenos">2107</span>         
<span class="linenos">2108</span>    do profileIndex = 1, size(sensorTovsIndexes)
<span class="linenos">2109</span>      iobs = sensorTovsIndexes(profileIndex)
<span class="linenos">2110</span>      headerIndex = tvs_headerIndex(iobs)
<span class="linenos">2111</span>      if (headerIndex &gt; 0) then
<span class="linenos">2112</span>        istart = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)
<span class="linenos">2113</span>        iend= obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex) + istart - 1
<span class="linenos">2114</span>        do bodyIndex = istart, iend
<span class="linenos">2115</span>          if (obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex) == obs_assimilated) then
<span class="linenos">2116</span>            call tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos">2117</span>                                                channelNumber, channelIndex )
<span class="linenos">2118</span>            if (channelIndex &gt;0) then
<span class="linenos">2119</span>              count =  count + 1
<span class="linenos">2120</span>              chanprof(count)%prof = profileIndex
<span class="linenos">2121</span>              chanprof(count)%chan = channelIndex
<span class="linenos">2122</span>              if (present(iptobs_cma_opt)) iptobs_cma_opt(count) = bodyIndex
<span class="linenos">2123</span>              if (present( lchannel_subset_opt )) lchannel_subset_opt(profileIndex,channelIndex) = .true.
<span class="linenos">2124</span>            else
<span class="linenos">2125</span>              write(*,*) &#39;tvs_getChanProf: strange channel number&#39;,channelNumber
<span class="linenos">2126</span>            end if
<span class="linenos">2127</span>          end if
<span class="linenos">2128</span>        end do
<span class="linenos">2129</span>      end if
<span class="linenos">2130</span>    end do
<span class="linenos">2131</span>  
<span class="linenos">2132</span>  end subroutine tvs_getChanprof
<span class="linenos">2133</span>
<span class="linenos">2134</span>  !--------------------------------------------------------------------------
<span class="linenos">2135</span>  !  tvs_countRadiances
<span class="linenos">2136</span>  !--------------------------------------------------------------------------
<span class="linenos">2137</span>  integer function tvs_countRadiances(sensorTovsIndexes, obsSpaceData, assim_flag_val_opt)
<span class="linenos">2138</span>    !
<span class="linenos">2139</span>    !:Purpose: to count radiances selected for assimilation
<span class="linenos">2140</span>    !
<span class="linenos">2141</span>    implicit none
<span class="linenos">2142</span>    integer, intent(in)          :: sensorTovsIndexes(:)
<span class="linenos">2143</span>    type(struct_obs)             :: obsSpaceData
<span class="linenos">2144</span>    integer, intent(in),optional :: assim_flag_val_opt
<span class="linenos">2145</span>    
<span class="linenos">2146</span>
<span class="linenos">2147</span>    integer :: profileIndex, headerIndex, istart, iend, bodyIndex, iobs, assim_flag_val
<span class="linenos">2148</span>
<span class="linenos">2149</span>    if (present(assim_flag_val_opt)) then
<span class="linenos">2150</span>      assim_flag_val = assim_flag_val_opt
<span class="linenos">2151</span>    else
<span class="linenos">2152</span>      assim_flag_val = 1
<span class="linenos">2153</span>    end if
<span class="linenos">2154</span>
<span class="linenos">2155</span>    tvs_countRadiances = 0
<span class="linenos">2156</span>    do profileIndex = 1, size(sensorTovsIndexes)
<span class="linenos">2157</span>      iobs = sensorTovsIndexes(profileIndex)
<span class="linenos">2158</span>      headerIndex = tvs_headerIndex(iobs)
<span class="linenos">2159</span>      if (headerIndex &gt; 0) then
<span class="linenos">2160</span>        istart = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)
<span class="linenos">2161</span>        iend = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex) + istart - 1
<span class="linenos">2162</span>        do bodyIndex = istart, iend
<span class="linenos">2163</span>          if(obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex) == obs_assimilated) tvs_countRadiances  = tvs_countRadiances + 1
<span class="linenos">2164</span>        end do
<span class="linenos">2165</span>      end if
<span class="linenos">2166</span>    end do
<span class="linenos">2167</span>
<span class="linenos">2168</span>  end function tvs_countRadiances
<span class="linenos">2169</span>
<span class="linenos">2170</span>  !--------------------------------------------------------------------------
<span class="linenos">2171</span>  !  tvs_ChangedStypValue(obsspacedata, headerIndex)
<span class="linenos">2172</span>  !--------------------------------------------------------------------------
<span class="linenos">2173</span>  integer function tvs_ChangedStypValue(obsSpaceData, headerIndex)
<span class="linenos">2174</span>    !
<span class="linenos">2175</span>    !:Purpose: to obtain new STYP value given observed STYP and TTYP value
<span class="linenos">2176</span>    !
<span class="linenos">2177</span>    implicit none
<span class="linenos">2178</span>    ! Arguments:
<span class="linenos">2179</span>    integer, intent(in)          :: headerIndex
<span class="linenos">2180</span>    type(struct_obs)             :: obsSpaceData
<span class="linenos">2181</span>    
<span class="linenos">2182</span>    ! Locals:
<span class="linenos">2183</span>    integer :: terrainType
<span class="linenos">2184</span>    integer :: landSea 
<span class="linenos">2185</span>
<span class="linenos">2186</span>    terrainType = obs_headElem_i(obsSpaceData,OBS_TTYP,headerIndex)
<span class="linenos">2187</span>    landSea     = obs_headElem_i(obsSpaceData,OBS_STYP,headerIndex)
<span class="linenos">2188</span>
<span class="linenos">2189</span>    if ( terrainType ==  0 ) then
<span class="linenos">2190</span>      tvs_ChangedStypValue = surftype_seaice
<span class="linenos">2191</span>    else
<span class="linenos">2192</span>      tvs_ChangedStypValue = landSea
<span class="linenos">2193</span>    end if
<span class="linenos">2194</span>
<span class="linenos">2195</span>  end function tvs_ChangedStypValue
<span class="linenos">2196</span>
<span class="linenos">2197</span>  !--------------------------------------------------------------------------
<span class="linenos">2198</span>  !  tvs_getHIREmissivities
<span class="linenos">2199</span>  !--------------------------------------------------------------------------
<span class="linenos">2200</span>  subroutine tvs_getHIREmissivities(sensorTovsIndexes, obsSpaceData, surfem)
<span class="linenos">2201</span>    !
<span class="linenos">2202</span>    !:Purpose: to get emissivity for Hyperspectral Infrared Sounders (AIRS, IASI, CrIS, ...)
<span class="linenos">2203</span>    !
<span class="linenos">2204</span>    implicit none
<span class="linenos">2205</span>
<span class="linenos">2206</span>    !Arguments:
<span class="linenos">2207</span>    integer, intent(in)          :: sensorTovsIndexes(:)
<span class="linenos">2208</span>    type(struct_obs), intent(in) :: obsSpaceData
<span class="linenos">2209</span>    real(8), intent(out)         :: surfem(:)
<span class="linenos">2210</span>
<span class="linenos">2211</span>    integer :: count, profileIndex, iobs, istart, iend, bodyIndex, headerIndex
<span class="linenos">2212</span>
<span class="linenos">2213</span>    count = 0 
<span class="linenos">2214</span>    surfem(:) = 0.98d0
<span class="linenos">2215</span>    do profileIndex = 1, size(sensorTovsIndexes)
<span class="linenos">2216</span>      iobs = sensorTovsIndexes(profileIndex)
<span class="linenos">2217</span>      headerIndex = tvs_headerIndex(iobs)
<span class="linenos">2218</span>      if (headerIndex &gt; 0 ) then
<span class="linenos">2219</span>        istart = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)
<span class="linenos">2220</span>        iend = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex) + istart - 1
<span class="linenos">2221</span>        do bodyIndex = istart, iend
<span class="linenos">2222</span>          if(obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex) == obs_assimilated) then
<span class="linenos">2223</span>            count = count + 1
<span class="linenos">2224</span>            surfem ( count ) = obs_bodyElem_r(obsSpaceData,OBS_SEM,bodyIndex)
<span class="linenos">2225</span>          end if
<span class="linenos">2226</span>        end do
<span class="linenos">2227</span>      end if
<span class="linenos">2228</span>    end do
<span class="linenos">2229</span>
<span class="linenos">2230</span>  end subroutine tvs_getHIREmissivities
<span class="linenos">2231</span>
<span class="linenos">2232</span>  !--------------------------------------------------------------------------
<span class="linenos">2233</span>  !  tvs_getOtherEmissivities
<span class="linenos">2234</span>  !--------------------------------------------------------------------------
<span class="linenos">2235</span>  subroutine tvs_getOtherEmissivities(chanprof, sensorTovsIndexes, sensorType, instrument, surfem, calcemis)
<span class="linenos">2236</span>    !
<span class="linenos">2237</span>    !:Purpose: to get emissivity for microwave sounders and infrared geostationary imagers
<span class="linenos">2238</span>    !
<span class="linenos">2239</span>    implicit none
<span class="linenos">2240</span>
<span class="linenos">2241</span>    ! Arguments:
<span class="linenos">2242</span>    type(rttov_chanprof), intent(in) :: chanprof(:)
<span class="linenos">2243</span>    integer, intent(in)              :: sensorTovsIndexes(:)
<span class="linenos">2244</span>    integer, intent(in)              :: sensorType
<span class="linenos">2245</span>    integer, intent(in)              :: instrument
<span class="linenos">2246</span>    real(8), intent(out)             :: surfem(:)
<span class="linenos">2247</span>    logical, intent(out)             :: calcemis(:)
<span class="linenos">2248</span>    
<span class="linenos">2249</span>    ! Locals:
<span class="linenos">2250</span>    integer :: radiance_index, profileIndex, iobs, surfaceType
<span class="linenos">2251</span>
<span class="linenos">2252</span>    do radiance_index = 1, size(chanprof)
<span class="linenos">2253</span>      profileIndex = chanprof(radiance_index)%prof
<span class="linenos">2254</span>      iobs = sensorTovsIndexes(profileIndex)
<span class="linenos">2255</span>      surfaceType = tvs_profiles_nl(iobs) % skin % surftype
<span class="linenos">2256</span>      if ( sensorType == sensor_id_mw ) then
<span class="linenos">2257</span>        if ( surfaceType == surftype_land .or. &amp;
<span class="linenos">2258</span>             surfaceType == surftype_seaice     ) then
<span class="linenos">2259</span>          calcemis(radiance_index) = .false.
<span class="linenos">2260</span>          surfem (radiance_index) = 0.75d0
<span class="linenos">2261</span>        else
<span class="linenos">2262</span>          calcemis(radiance_index) = .true.
<span class="linenos">2263</span>          surfem (radiance_index) = 0.d0
<span class="linenos">2264</span>        end if
<span class="linenos">2265</span>      else if ( tvs_isInstrumHyperSpectral(instrument) ) then
<span class="linenos">2266</span>        calcemis(radiance_index) = .false. 
<span class="linenos">2267</span>      else if ( tvs_isInstrumGeostationary(instrument) ) then
<span class="linenos">2268</span>        calcemis(radiance_index) = .true.
<span class="linenos">2269</span>        surfem (radiance_index) = 0.d0
<span class="linenos">2270</span>      else
<span class="linenos">2271</span>        write(*,*) sensorType,instrument
<span class="linenos">2272</span>        call utl_abort(&#39;tvs_getOtherEmissivities. invalid sensor type or unknown IR instrument&#39;)
<span class="linenos">2273</span>      end if
<span class="linenos">2274</span>    end do
<span class="linenos">2275</span>   
<span class="linenos">2276</span>  end subroutine tvs_getOtherEmissivities
<span class="linenos">2277</span>  
<span class="linenos">2278</span>  !--------------------------------------------------------------------------
<span class="linenos">2279</span>  !  tvs_fillProfiles
<span class="linenos">2280</span>  !--------------------------------------------------------------------------
<span class="linenos">2281</span>  subroutine tvs_fillProfiles(columnTrl, obsSpaceData, datestamp, profileType, beSilent)
<span class="linenos">2282</span>    !
<span class="linenos">2283</span>    !:Purpose:  to fill in tvs_profiles_nl structure before call to non-linear, 
<span class="linenos">2284</span>    !            tangent-linear or adjoint of RTTOV
<span class="linenos">2285</span>    !
<span class="linenos">2286</span>    implicit none
<span class="linenos">2287</span>
<span class="linenos">2288</span>    ! Arguments:
<span class="linenos">2289</span>    type(struct_columnData), intent(in)    :: columnTrl    ! Column structure
<span class="linenos">2290</span>    type(struct_obs),        intent(inout) :: obsSpaceData ! obsSpaceData structure
<span class="linenos">2291</span>    integer,                 intent(in)    :: datestamp    ! CMC date stamp
<span class="linenos">2292</span>    character (len=*), intent(in)          :: profileType
<span class="linenos">2293</span>    logical,                 intent(in)    :: beSilent     ! To control verbosity
<span class="linenos">2294</span>
<span class="linenos">2295</span>    ! Locals:
<span class="linenos">2296</span>    integer :: instrum, iplatform
<span class="linenos">2297</span>    integer :: nobmax
<span class="linenos">2298</span>    integer :: sensorIndex, tovsIndex
<span class="linenos">2299</span>    integer :: profileCount, headerIndex
<span class="linenos">2300</span>    integer :: profileIndex, levelIndex
<span class="linenos">2301</span>    integer :: ilowlvl_M,ilowlvl_T,nlv_M,nlv_T
<span class="linenos">2302</span>    integer :: Vcode
<span class="linenos">2303</span>    integer :: ierr,day,month,year,ijour,itime
<span class="linenos">2304</span>    integer :: allocStatus(13)
<span class="linenos">2305</span>    
<span class="linenos">2306</span>    integer,external ::  omp_get_num_threads
<span class="linenos">2307</span>    integer,external ::  newdate
<span class="linenos">2308</span>
<span class="linenos">2309</span>    integer, allocatable :: sensorTovsIndexes(:)
<span class="linenos">2310</span>    integer, allocatable :: sensorHeaderIndexes(:)
<span class="linenos">2311</span>  
<span class="linenos">2312</span>    type(struct_vco), pointer :: vco
<span class="linenos">2313</span>
<span class="linenos">2314</span>    real(8), allocatable :: pressure (:,:)
<span class="linenos">2315</span>    real(8), allocatable :: latitudes(:)
<span class="linenos">2316</span>    real(8), allocatable :: ozone(:,:)
<span class="linenos">2317</span>    character(len=4)     :: ozoneVarName
<span class="linenos">2318</span>    real(8), allocatable :: clw   (:,:)
<span class="linenos">2319</span>    real(8), allocatable :: ciw   (:,:)
<span class="linenos">2320</span>    real(8), allocatable :: rainflux  (:,:)
<span class="linenos">2321</span>    real(8), allocatable :: snowflux  (:,:)
<span class="linenos">2322</span>    real(8), allocatable :: cloudFraction(:,:)
<span class="linenos">2323</span>    logical, allocatable :: surfTypeIsWater(:)
<span class="linenos">2324</span>    logical :: runObsOperatorWithClw
<span class="linenos">2325</span>    logical :: runObsOperatorWithHydrometeors
<span class="linenos">2326</span>    type(rttov_profile), pointer :: profiles(:)
<span class="linenos">2327</span>    type(rttov_profile_cloud), pointer :: cld_profiles(:)
<span class="linenos">2328</span>    real(8), pointer :: column_ptr(:)
<span class="linenos">2329</span>    real(8) :: zmax, wind
<span class="linenos">2330</span>
<span class="linenos">2331</span>    if ( .not. beSilent ) write(*,*) &#39;tvs_fillProfiles: Starting&#39;
<span class="linenos">2332</span>  
<span class="linenos">2333</span>    if (tvs_nobtov == 0) return    ! exit if there are no tovs data
<span class="linenos">2334</span>
<span class="linenos">2335</span>    if ( tvs_numMWInstrumUsingCLW &gt; 0 .and. .not. col_varExist(columnTrl,&#39;LWCR&#39;) ) then
<span class="linenos">2336</span>      call utl_abort(&#39;tvs_fillProfiles: if number of instrument to use CLW greater than zero, &#39; // &amp;
<span class="linenos">2337</span>                     &#39;the LWCR variable must be included as an analysis variable in NAMSTATE. &#39;)
<span class="linenos">2338</span>    end if
<span class="linenos">2339</span>    if (tvs_numMWInstrumUsingHydrometeors &gt; 0) then
<span class="linenos">2340</span>      if (.not. (col_varExist(columnTrl,&#39;LWCR&#39;) .and. col_varExist(columnTrl,&#39;IWCR&#39;))) then
<span class="linenos">2341</span>        call utl_abort(&#39;tvs_fillProfiles: if number of instrument to use hydrometeors greater than zero, &#39; // &amp;
<span class="linenos">2342</span>                       &#39;the LWCR/IWCR variables must be included as an analysis variable in NAMSTATE. &#39;)
<span class="linenos">2343</span>      end if
<span class="linenos">2344</span>      if (.not. beSilent .and. .not. (col_varExist(columnTrl,&#39;RF&#39;) .and. col_varExist(columnTrl,&#39;SF&#39;) .and. &amp;
<span class="linenos">2345</span>          col_varExist(columnTrl,&#39;CLDR&#39;))) then
<span class="linenos">2346</span>        write(*,*) &#39;tvs_fillProfiles: one of RF/SF/CLDR does not exist in NAMSTATE&#39;
<span class="linenos">2347</span>      end if
<span class="linenos">2348</span>    end if
<span class="linenos">2349</span>
<span class="linenos">2350</span>    if ( (tvs_numMWInstrumUsingCLW == 0 .and. tvs_numMWInstrumUsingHydrometeors == 0 .and. &amp;
<span class="linenos">2351</span>            tvs_mwAllskyAssim) .or. &amp;
<span class="linenos">2352</span>         (tvs_numMWInstrumUsingCLW  &gt; 0 .and. tvs_numMWInstrumUsingHydrometeors == 0 .and. &amp;
<span class="linenos">2353</span>            .not. tvs_mwAllskyAssim) .or. &amp;
<span class="linenos">2354</span>         (tvs_numMWInstrumUsingCLW == 0 .and. tvs_numMWInstrumUsingHydrometeors  &gt; 0 .and. &amp;
<span class="linenos">2355</span>            .not. tvs_mwAllskyAssim) ) then
<span class="linenos">2356</span>      call utl_abort(&#39;tvs_fillProfiles: number of instrument to use CLW/hydrometeors do not match &#39; // &amp;
<span class="linenos">2357</span>                     &#39;all-sky namelist variable.&#39;)
<span class="linenos">2358</span>    end if
<span class="linenos">2359</span>
<span class="linenos">2360</span>    if (.not. tvs_useO3Climatology .and. .not. col_varExist(columnTrl,&#39;TO3&#39;) .and. &amp;
<span class="linenos">2361</span>        .not. col_varExist(columnTrl,&#39;O3L&#39;) ) then
<span class="linenos">2362</span>      call utl_abort(&#39;tvs_fillProfiles: if tvs_useO3Climatology is set to .false. the ozone variable &#39; // &amp;
<span class="linenos">2363</span>                     &#39;must be included as an analysis variable in NAMSTATE. &#39;)
<span class="linenos">2364</span>    else if (.not.tvs_useO3Climatology) then 
<span class="linenos">2365</span>      if (col_varExist(columnTrl,&#39;TO3&#39;) ) then
<span class="linenos">2366</span>        ozoneVarName = &#39;TO3&#39;
<span class="linenos">2367</span>      else
<span class="linenos">2368</span>        ozoneVarName = &#39;O3L&#39;
<span class="linenos">2369</span>      end if
<span class="linenos">2370</span>    end if
<span class="linenos">2371</span>
<span class="linenos">2372</span>    allocStatus(:) = 0
<span class="linenos">2373</span>
<span class="linenos">2374</span>    if ( profileType == &#39;nl&#39; ) then
<span class="linenos">2375</span>      if ( .not. allocated( tvs_profiles_nl) ) then
<span class="linenos">2376</span>        allocate(tvs_profiles_nl(tvs_nobtov) , stat=allocStatus(1) )
<span class="linenos">2377</span>        if (tvs_numMWInstrumUsingHydrometeors  &gt; 0) then
<span class="linenos">2378</span>          allocate(tvs_cld_profiles_nl(tvs_nobtov) , stat=allocStatus(2))
<span class="linenos">2379</span>        end if
<span class="linenos">2380</span>        call utl_checkAllocationStatus(allocStatus(1:2), &#39; tvs_fillProfiles tvs_profiles_nl&#39;)
<span class="linenos">2381</span>      end if
<span class="linenos">2382</span>    else if ( profileType == &#39;tlad&#39; ) then
<span class="linenos">2383</span>      if ( .not. allocated( tvs_profiles_tlad) ) then
<span class="linenos">2384</span>        allocate(tvs_profiles_tlad(tvs_nobtov) , stat=allocStatus(1) )
<span class="linenos">2385</span>        if (tvs_numMWInstrumUsingHydrometeors  &gt; 0) then
<span class="linenos">2386</span>          allocate(tvs_cld_profiles_tlad(tvs_nobtov) , stat=allocStatus(2))
<span class="linenos">2387</span>        end if
<span class="linenos">2388</span>        call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_fillProfiles tvs_profiles_tlad&#39;)
<span class="linenos">2389</span>      else
<span class="linenos">2390</span>        return
<span class="linenos">2391</span>      end if
<span class="linenos">2392</span>    else
<span class="linenos">2393</span>      write(*,*) &#39;Invalid  profileType &#39;, profileType
<span class="linenos">2394</span>      call utl_abort(&#39;tvs_fillProfiles&#39;)
<span class="linenos">2395</span>    end if
<span class="linenos">2396</span>
<span class="linenos">2397</span>    if ( .not. beSilent ) write(*,*) &#39;tvs_fillProfiles: profileType is &#39;, profileType
<span class="linenos">2398</span>
<span class="linenos">2399</span>    call tvs_getProfile(profiles, profileType, cld_profiles)
<span class="linenos">2400</span>
<span class="linenos">2401</span>!
<span class="linenos">2402</span>!     1.    Set index for model&#39;s lowest level and model top
<span class="linenos">2403</span>!     .     ------------------------------------------------
<span class="linenos">2404</span>    
<span class="linenos">2405</span>    nlv_M = col_getNumLev(columnTrl,&#39;MM&#39;)
<span class="linenos">2406</span>    nlv_T = col_getNumLev(columnTrl,&#39;TH&#39;)
<span class="linenos">2407</span>
<span class="linenos">2408</span>    if (  col_getPressure(columnTrl,1,1,&#39;TH&#39;) &lt; col_getPressure(columnTrl,nlv_T,1,&#39;TH&#39;) ) then
<span class="linenos">2409</span>      ilowlvl_M = nlv_M
<span class="linenos">2410</span>      ilowlvl_T = nlv_T
<span class="linenos">2411</span>    else
<span class="linenos">2412</span>      ilowlvl_M = 1
<span class="linenos">2413</span>      ilowlvl_T = 1
<span class="linenos">2414</span>    end if
<span class="linenos">2415</span>
<span class="linenos">2416</span>    vco =&gt; col_getVco(columnTrl)
<span class="linenos">2417</span>    Vcode = vco%Vcode
<span class="linenos">2418</span>
<span class="linenos">2419</span>    ierr = newdate(datestamp,ijour,itime,-3)
<span class="linenos">2420</span>    if (ierr &lt; 0) then
<span class="linenos">2421</span>      write(*,*) &#39;Invalid datestamp &#39;,datestamp,ijour,itime,ierr
<span class="linenos">2422</span>      call utl_abort(&#39;tvs_fillProfiles&#39;)
<span class="linenos">2423</span>    end if
<span class="linenos">2424</span>    year= ijour / 10000
<span class="linenos">2425</span>    month = mod(ijour / 100,100)
<span class="linenos">2426</span>    day = mod(ijour,100)
<span class="linenos">2427</span>
<span class="linenos">2428</span>    !  1.2   Read ozone climatology
<span class="linenos">2429</span>
<span class="linenos">2430</span>    if (tvs_useO3Climatology) call ozo_read_climatology(datestamp)
<span class="linenos">2431</span>
<span class="linenos">2432</span>    !     2.  Fill profiles structure
<span class="linenos">2433</span>    
<span class="linenos">2434</span>    ! loop over all instruments
<span class="linenos">2435</span>    sensor_loop: do sensorIndex=1, tvs_nsensors
<span class="linenos">2436</span>
<span class="linenos">2437</span>      runObsOperatorWithClw = (col_varExist(columnTrl,&#39;LWCR&#39;) .and. tvs_numMWInstrumUsingCLW /= 0 .and. &amp; 
<span class="linenos">2438</span>                               tvs_isInstrumUsingCLW(tvs_instruments(sensorIndex)))
<span class="linenos">2439</span>
<span class="linenos">2440</span>      runObsOperatorWithHydrometeors = (col_varExist(columnTrl,&#39;LWCR&#39;) .and. col_varExist(columnTrl,&#39;IWCR&#39;) .and. &amp;
<span class="linenos">2441</span>                                        tvs_isInstrumUsingHydrometeors(tvs_instruments(sensorIndex)))
<span class="linenos">2442</span>
<span class="linenos">2443</span>      if (runObsOperatorWithClw .and. runObsOperatorWithHydrometeors) then
<span class="linenos">2444</span>        call utl_abort(&#39;tvs_fillProfiles: this instrument is mentioned in using CLW and hydrometeors.&#39;)
<span class="linenos">2445</span>      end if
<span class="linenos">2446</span>
<span class="linenos">2447</span>      ! first loop over all obs.
<span class="linenos">2448</span>      profileCount = 0
<span class="linenos">2449</span>      bobs1: do tovsIndex = 1, tvs_nobtov
<span class="linenos">2450</span>        if (tvs_lsensor(tovsIndex) == sensorIndex) then
<span class="linenos">2451</span>          profileCount = profileCount + 1
<span class="linenos">2452</span>          NOBMAX = tovsIndex
<span class="linenos">2453</span>        end if
<span class="linenos">2454</span>      end do bobs1
<span class="linenos">2455</span>
<span class="linenos">2456</span>      if (profileCount == 0) cycle sensor_loop
<span class="linenos">2457</span>
<span class="linenos">2458</span>      if (tvs_coefs(sensorIndex)%coef%fmv_model_ver &gt;= 9) then
<span class="linenos">2459</span>        zmax = zenmaxv9
<span class="linenos">2460</span>      else
<span class="linenos">2461</span>        zmax = zenmax
<span class="linenos">2462</span>      end if
<span class="linenos">2463</span>      
<span class="linenos">2464</span>      allocStatus(:) = 0
<span class="linenos">2465</span>      allocate (sensorTovsIndexes(profileCount),                     stat = allocStatus(1) )
<span class="linenos">2466</span>      allocate (sensorHeaderIndexes(profileCount),                   stat = allocStatus(2) )
<span class="linenos">2467</span>      allocate (latitudes(profileCount),                             stat = allocStatus(3) )
<span class="linenos">2468</span>      allocate (ozone(nlv_T,profileCount),                           stat = allocStatus(4) ) 
<span class="linenos">2469</span>      allocate (pressure(nlv_T,profileCount),                        stat = allocStatus(5) )
<span class="linenos">2470</span>      if (runObsOperatorWithClw .or. runObsOperatorWithHydrometeors) then
<span class="linenos">2471</span>        allocate (clw       (nlv_T,profileCount),stat= allocStatus(6))
<span class="linenos">2472</span>        clw(:,:) = qlim_getMinValueCloud(&#39;LWCR&#39;)
<span class="linenos">2473</span>      end if
<span class="linenos">2474</span>      if (runObsOperatorWithHydrometeors) then
<span class="linenos">2475</span>        allocate (ciw       (nlv_T,profileCount),stat= allocStatus(7))
<span class="linenos">2476</span>        allocate (rainFlux  (nlv_T,profileCount),stat= allocStatus(8))
<span class="linenos">2477</span>        allocate (snowFlux  (nlv_T,profileCount),stat= allocStatus(9))
<span class="linenos">2478</span>        allocate (cloudFraction(nlv_T,profileCount),stat= allocStatus(10))
<span class="linenos">2479</span>        ciw(:,:) = qlim_getMinValueCloud(&#39;IWCR&#39;)
<span class="linenos">2480</span>        rainFlux(:,:) = qlim_getMinValueCloud(&#39;RF&#39;)
<span class="linenos">2481</span>        snowFlux(:,:) = qlim_getMinValueCloud(&#39;SF&#39;)
<span class="linenos">2482</span>        cloudFraction(:,:) = qlim_getMinValueCloud(&#39;CLDR&#39;)
<span class="linenos">2483</span>      end if
<span class="linenos">2484</span>      allocate (surfTypeIsWater(profileCount),stat= allocStatus(11)) 
<span class="linenos">2485</span>      surfTypeIsWater(:) = .false.
<span class="linenos">2486</span>
<span class="linenos">2487</span>      call utl_checkAllocationStatus(allocStatus, &#39; tvs_fillProfiles&#39;)
<span class="linenos">2488</span>
<span class="linenos">2489</span>      profileCount = 0
<span class="linenos">2490</span>
<span class="linenos">2491</span>      ! second loop over all obs.
<span class="linenos">2492</span>      bobs2: do tovsIndex = 1, NOBMAX
<span class="linenos">2493</span>        if (tvs_lsensor(tovsIndex) /= sensorIndex) cycle bobs2
<span class="linenos">2494</span>        profileCount = profileCount + 1
<span class="linenos">2495</span>        sensorTovsIndexes(profileCount) = tovsIndex
<span class="linenos">2496</span>        headerIndex = tvs_headerIndex(tovsIndex)
<span class="linenos">2497</span>        sensorHeaderIndexes(profileCount) = headerIndex
<span class="linenos">2498</span>
<span class="linenos">2499</span>        call rttov_alloc_prof(                 &amp;
<span class="linenos">2500</span>             allocStatus(1),                   &amp;
<span class="linenos">2501</span>             1,                                &amp; ! 1 = nprofiles un profil a la fois
<span class="linenos">2502</span>             profiles(tovsIndex:tovsIndex),    &amp;
<span class="linenos">2503</span>             nlv_T,                            &amp; 
<span class="linenos">2504</span>             tvs_opts(sensorIndex),            &amp;
<span class="linenos">2505</span>             asw=1,                            &amp; ! asw =1 allocation
<span class="linenos">2506</span>             coefs=tvs_coefs(sensorIndex),     &amp;
<span class="linenos">2507</span>             init=.true. )                       
<span class="linenos">2508</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos">2509</span>          call rttov_alloc_scatt_prof(            &amp;   
<span class="linenos">2510</span>               allocstatus(2),                    &amp;
<span class="linenos">2511</span>               1,                                 &amp;
<span class="linenos">2512</span>               cld_profiles(tovsIndex:tovsIndex), &amp;
<span class="linenos">2513</span>               nlv_T,                             &amp;
<span class="linenos">2514</span>               nhydro=5,                          &amp; ! depending on what is defined in the Mie tables
<span class="linenos">2515</span>               nhydro_frac=1,                     &amp; ! 1 cloud fraction for all variable or nhydro 1 cloud fraction for each variable
<span class="linenos">2516</span>               asw=1_jpim,                        &amp; ! 1 =&gt; allocate
<span class="linenos">2517</span>               init=.true.,                       &amp; ! initialize profiles to zero
<span class="linenos">2518</span>               flux_conversion=[1,2,0,0,0] )        !flux_conversion  input units: 0 (default) =&gt; kg/kg,
<span class="linenos">2519</span>                                                    ! 1,2 =&gt; kg/m2/s, optional for rain, snow
<span class="linenos">2520</span>        end if
<span class="linenos">2521</span>        call utl_checkAllocationStatus(allocStatus(1:2), &#39; tvs_setupAlloc tvs_fillProfiles&#39;)
<span class="linenos">2522</span>
<span class="linenos">2523</span>        !    extract land/sea/sea-ice flag (0=land, 1=sea, 2=sea-ice)
<span class="linenos">2524</span>        profiles(tovsIndex) % skin % surftype = tvs_ChangedStypValue(obsSpaceData,headerIndex)
<span class="linenos">2525</span>
<span class="linenos">2526</span>        !    extract satellite zenith and azimuth angle, 
<span class="linenos">2527</span>        !    sun zenith angle, cloud fraction, latitude and longitude
<span class="linenos">2528</span>        profiles(tovsIndex) % zenangle   = obs_headElem_r(obsSpaceData,OBS_SZA,headerIndex)
<span class="linenos">2529</span>
<span class="linenos">2530</span>        call validateRttovVariable(profiles(tovsIndex) % zenangle, &quot;satellite zenith angle&quot;, &amp;
<span class="linenos">2531</span>            obsSpaceData, headerIndex, 0.d0, zmax)
<span class="linenos">2532</span> 
<span class="linenos">2533</span>        profiles(tovsIndex) % azangle = tvs_getCorrectedSatelliteAzimuth(obsSpaceData, headerIndex)
<span class="linenos">2534</span>        profiles(tovsIndex) % sunazangle  = obs_headElem_r(obsSpaceData,OBS_SAZ,headerIndex) ! necessaire pour radiation solaire
<span class="linenos">2535</span>        iplatform = tvs_coefs(sensorIndex) % coef % id_platform
<span class="linenos">2536</span>        instrum = tvs_coefs(sensorIndex) % coef % id_inst
<span class="linenos">2537</span>        profiles(tovsIndex) % sunzenangle = obs_headElem_r(obsSpaceData,OBS_SUN,headerIndex)
<span class="linenos">2538</span>        if (tvs_opts(sensorIndex)%rt_ir%addsolar) then
<span class="linenos">2539</span>          call validateRttovVariable(profiles(tovsIndex) % sunzenangle, &quot;sun zenith angle&quot;, &amp;
<span class="linenos">2540</span>              obsSpaceData, headerIndex, 0.d0)
<span class="linenos">2541</span>        end if
<span class="linenos">2542</span>        latitudes(profileCount) = obs_headElem_r(obsSpaceData,OBS_LAT,headerIndex) * MPC_DEGREES_PER_RADIAN_R8
<span class="linenos">2543</span>        !1d-5 was chosen as a threshold because it is the high precision for latitudes in BUFR/BURP files
<span class="linenos">2544</span>        if (latitudes(profileCount) &gt; 90.d0 .and. (latitudes(profileCount)-90.d0) &lt; 1.d-5) latitudes(profileCount) = 90.d0
<span class="linenos">2545</span>        if (latitudes(profileCount) &lt; -90.d0 .and. (-latitudes(profileCount)-90.d0) &lt; 1.d-5) latitudes(profileCount) = -90.d0
<span class="linenos">2546</span>        call validateRttovVariable(latitudes(profileCount), &#39;latitude&#39;, obsSpaceData, headerIndex, -90.d0, 90.d0) 
<span class="linenos">2547</span>        
<span class="linenos">2548</span>        profiles(tovsIndex) % longitude = obs_headElem_r(obsSpaceData,OBS_LON,headerIndex) * MPC_DEGREES_PER_RADIAN_R8
<span class="linenos">2549</span>
<span class="linenos">2550</span>        surfTypeIsWater(profileCount) = ( tvs_ChangedStypValue(obsSpaceData,headerIndex) == surftype_sea )
<span class="linenos">2551</span>
<span class="linenos">2552</span>        do levelIndex = 1, nlv_T
<span class="linenos">2553</span>          pressure(levelIndex,profileCount) = col_getPressure(columnTrl,levelIndex,headerIndex,&#39;TH&#39;) * MPC_MBAR_PER_PA_R8
<span class="linenos">2554</span>          if ((runObsOperatorWithClw .and. surfTypeIsWater(profileCount)) .or. &amp;
<span class="linenos">2555</span>              (runObsOperatorWithHydrometeors .and. surfTypeIsWater(profileCount))) then
<span class="linenos">2556</span>
<span class="linenos">2557</span>            ! cloud liquid water content
<span class="linenos">2558</span>            clw(levelIndex,profileCount) = col_getElem(columnTrl,levelIndex,headerIndex,&#39;LWCR&#39;)
<span class="linenos">2559</span>            if (clw(levelIndex,profileCount) &lt; qlim_getMinValueCloud(&#39;LWCR&#39;) .or. &amp;
<span class="linenos">2560</span>                clw(levelIndex,profileCount) &gt; qlim_getMaxValueCloud(&#39;LWCR&#39;)) then
<span class="linenos">2561</span>              write(*,*) &#39;tvs_fillProfiles: clw=&#39; , clw(:,profileCount) 
<span class="linenos">2562</span>              call utl_abort(&#39;tvs_fillProfiles: columnTrl has clw outside RTTOV bounds&#39;)
<span class="linenos">2563</span>            end if
<span class="linenos">2564</span>
<span class="linenos">2565</span>            clw(levelIndex,profileCount) = clw(levelIndex,profileCount) * tvs_cloudScaleFactor
<span class="linenos">2566</span>          end if
<span class="linenos">2567</span>          if (runObsOperatorWithHydrometeors .and. surfTypeIsWater(profileCount)) then
<span class="linenos">2568</span>            ! cloud ice water content
<span class="linenos">2569</span>            ciw(levelIndex,profileCount) = col_getElem(columnTrl,levelIndex,headerIndex,&#39;IWCR&#39;)
<span class="linenos">2570</span>            if (ciw(levelIndex,profileCount) &lt; qlim_getMinValueCloud(&#39;IWCR&#39;) .or. &amp;
<span class="linenos">2571</span>                ciw(levelIndex,profileCount) &gt; qlim_getMaxValueCloud(&#39;IWCR&#39;)) then
<span class="linenos">2572</span>              write(*,*) &#39;tvs_fillProfiles: ciw=&#39; , ciw(:,profileCount) 
<span class="linenos">2573</span>              call utl_abort(&#39;tvs_fillProfiles: columnTrl has ciw outside RTTOV bounds&#39;)
<span class="linenos">2574</span>            end if
<span class="linenos">2575</span>
<span class="linenos">2576</span>            ! rain flux (zero, if not part of control variables)
<span class="linenos">2577</span>            if (col_varExist(columnTrl,&#39;RF&#39;)) then
<span class="linenos">2578</span>              rainFlux(levelIndex,profileCount) = col_getElem(columnTrl,levelIndex,headerIndex,&#39;RF&#39;)
<span class="linenos">2579</span>            end if
<span class="linenos">2580</span>            if (rainFlux(levelIndex,profileCount) &lt; qlim_getMinValueCloud(&#39;RF&#39;) .or. &amp;
<span class="linenos">2581</span>                rainFlux(levelIndex,profileCount) &gt; qlim_getMaxValueCloud(&#39;RF&#39;)) then
<span class="linenos">2582</span>              write(*,*) &#39;tvs_fillProfiles: rainFlux=&#39; , rainFlux(:,profileCount) 
<span class="linenos">2583</span>              call utl_abort(&#39;tvs_fillProfiles: columnTrl has rain flux outside RTTOV bounds&#39;)
<span class="linenos">2584</span>            end if
<span class="linenos">2585</span>
<span class="linenos">2586</span>            ! snow flux (zero, if not part of control variables)
<span class="linenos">2587</span>            if (col_varExist(columnTrl,&#39;SF&#39;)) then
<span class="linenos">2588</span>              snowFlux(levelIndex,profileCount) = col_getElem(columnTrl,levelIndex,headerIndex,&#39;SF&#39;)
<span class="linenos">2589</span>            end if
<span class="linenos">2590</span>            if (snowFlux(levelIndex,profileCount) &lt; qlim_getMinValueCloud(&#39;SF&#39;) .or. &amp;
<span class="linenos">2591</span>                snowFlux(levelIndex,profileCount) &gt; qlim_getMaxValueCloud(&#39;SF&#39;)) then
<span class="linenos">2592</span>              write(*,*) &#39;tvs_fillProfiles: snowFlux=&#39; , snowFlux(:,profileCount) 
<span class="linenos">2593</span>              call utl_abort(&#39;tvs_fillProfiles: columnTrl has snow flux outside RTTOV bounds&#39;)
<span class="linenos">2594</span>            end if
<span class="linenos">2595</span>
<span class="linenos">2596</span>            ! cloud fraction (zero, if not part of control variables)
<span class="linenos">2597</span>            if (col_varExist(columnTrl,&#39;CLDR&#39;)) then
<span class="linenos">2598</span>              cloudFraction(levelIndex,profileCount) = col_getElem(columnTrl,levelIndex,headerIndex,&#39;CLDR&#39;)
<span class="linenos">2599</span>            end if
<span class="linenos">2600</span>            if (cloudFraction(levelIndex,profileCount) &lt; qlim_getMinValueCloud(&#39;CLDR&#39;) .or. &amp;
<span class="linenos">2601</span>                cloudFraction(levelIndex,profileCount) &gt; qlim_getMaxValueCloud(&#39;CLDR&#39;)) then
<span class="linenos">2602</span>              write(*,*) &#39;tvs_fillProfiles: cloudFraction=&#39; , cloudFraction(:,profileCount) 
<span class="linenos">2603</span>              call utl_abort(&#39;tvs_fillProfiles: columnTrl has cloud fraction outside RTTOV bounds&#39;)
<span class="linenos">2604</span>            end if
<span class="linenos">2605</span>
<span class="linenos">2606</span>            ciw(levelIndex,profileCount) = ciw(levelIndex,profileCount) * tvs_cloudScaleFactor
<span class="linenos">2607</span>            rainFlux(levelIndex,profileCount) = rainFlux(levelIndex,profileCount) * tvs_cloudScaleFactor
<span class="linenos">2608</span>            snowFlux(levelIndex,profileCount) = snowFlux(levelIndex,profileCount) * tvs_cloudScaleFactor
<span class="linenos">2609</span>
<span class="linenos">2610</span>          end if ! runObsOperatorWithHydrometeors .and. surfTypeIsWater
<span class="linenos">2611</span>        end do ! levelIndex
<span class="linenos">2612</span>        
<span class="linenos">2613</span>        if (tvs_coefs(sensorIndex) %coef % nozone &gt; 0 .and. .not. tvs_useO3Climatology) then
<span class="linenos">2614</span>          column_ptr =&gt; col_getColumn(columnTrl, headerIndex, trim(ozoneVarName) )
<span class="linenos">2615</span>          ! Conversion from microgram/km to ppmv (to have the same units as climatology when tvs_useO3Climatology is .true.
<span class="linenos">2616</span>          ! Conversion to kg/kg for use by RTTOV in done later
<span class="linenos">2617</span>          ozone(:,profileCount) = column_ptr(:) * 1.0D-9 * o3Mixratio2ppmv
<span class="linenos">2618</span>        end if
<span class="linenos">2619</span>
<span class="linenos">2620</span>      end do bobs2
<span class="linenos">2621</span>
<span class="linenos">2622</span>      !    2.5  Get ozone profiles (ppmv) from climatology if necessary
<span class="linenos">2623</span>      if (tvs_coefs(sensorIndex) %coef % nozone &gt; 0 .and. tvs_useO3Climatology) then
<span class="linenos">2624</span>        call ozo_get_profile (ozone, latitudes, pressure, nlv_T, profileCount)
<span class="linenos">2625</span>      end if
<span class="linenos">2626</span>
<span class="linenos">2627</span>      !   2.5  Fill profiles structure
<span class="linenos">2628</span>
<span class="linenos">2629</span>      do  profileIndex = 1 , profileCount 
<span class="linenos">2630</span>        tovsIndex = sensorTovsIndexes(profileIndex)
<span class="linenos">2631</span>        headerIndex = sensorHeaderIndexes(profileIndex)
<span class="linenos">2632</span>        profiles(tovsIndex) % gas_units       = gas_unit_specconc ! all gas profiles are supposed to be provided in kg/kg (specific humidity, i.e. mass mixing ratio [kg/kg] over wet air)
<span class="linenos">2633</span>        profiles(tovsIndex) % id              = &#39;&#39; ! profile id, up to 128 characters, to consider for use
<span class="linenos">2634</span>        profiles(tovsIndex) % nlevels         = nlv_T
<span class="linenos">2635</span>        profiles(tovsIndex) % nlayers         = nlv_T - 1
<span class="linenos">2636</span>        profiles(tovsIndex) % date(1)         = year
<span class="linenos">2637</span>        profiles(tovsIndex) % date(2)         = month
<span class="linenos">2638</span>        profiles(tovsIndex) % date(3)         = day
<span class="linenos">2639</span>        profiles(tovsIndex) % latitude        = latitudes(profileIndex)
<span class="linenos">2640</span>        profiles(tovsIndex) % elevation       = 0.001d0 * col_getHeight(columnTrl,ilowlvl_T,headerIndex,&#39;TH&#39;) ! unite km
<span class="linenos">2641</span>        call validateRttovVariable(profiles(tovsIndex) % elevation, &quot;elevation&quot;, obsSpaceData, headerIndex, maximum_opt=elevmax)
<span class="linenos">2642</span>        profiles(tovsIndex) % skin % watertype = watertype_ocean_water !utilise pour calcul rayonnement solaire reflechi seulement
<span class="linenos">2643</span>        profiles(tovsIndex) % skin % t         = col_getElem(columnTrl,1,headerIndex,&#39;TG&#39;)
<span class="linenos">2644</span>        call validateRttovVariable( profiles(tovsIndex) % skin % t, &quot;skin temperature&quot;, obsSpaceData, headerIndex, tmin, tmax) 
<span class="linenos">2645</span>        profiles(tovsIndex) % skin % salinity  = 35.d0 ! for FASTEM-4 only to revise (practical salinity units)
<span class="linenos">2646</span>        profiles(tovsIndex) % skin % fastem(:) = 0.0d0
<span class="linenos">2647</span>        profiles(tovsIndex) % skin % snow_fraction  = 0.d0 ! Surface coverage snow fraction(0-1), used only by IR emissivity atlas
<span class="linenos">2648</span>        profiles(tovsIndex) % skin % soil_moisture  = 0.d0 ! soil moisure (m**3/m**3) not yet used
<span class="linenos">2649</span>        profiles(tovsIndex) % s2m % t          = col_getElem(columnTrl,ilowlvl_T,headerIndex,&#39;TT&#39;)
<span class="linenos">2650</span>        call validateRttovVariable(profiles(tovsIndex) % s2m % t, &#39;2m air temperature&#39;, &amp;
<span class="linenos">2651</span>            obsSpaceData, headerIndex, tmin, tmax) 
<span class="linenos">2652</span>        profiles(tovsIndex) % s2m % p         = col_getElem(columnTrl,1      ,headerIndex,&#39;P0&#39;)*MPC_MBAR_PER_PA_R8
<span class="linenos">2653</span>        call validateRttovVariable(profiles(tovsIndex) % s2m % p, &#39;surface pressure&#39;, &amp;
<span class="linenos">2654</span>            obsSpaceData, headerIndex, pmin, pmax) 
<span class="linenos">2655</span>        profiles(tovsIndex) % s2m % u         = col_getElem(columnTrl,ilowlvl_M,headerIndex,&#39;UU&#39;)
<span class="linenos">2656</span>        profiles(tovsIndex) % s2m % v         = col_getElem(columnTrl,ilowlvl_M,headerIndex,&#39;VV&#39;)
<span class="linenos">2657</span>        wind = sqrt( profiles(tovsIndex) % s2m % u ** 2 + &amp;
<span class="linenos">2658</span>            profiles(tovsIndex) % s2m % v ** 2 )
<span class="linenos">2659</span>        if ( wind &gt; wmax ) then
<span class="linenos">2660</span>          write(*,*) &#39;tvs_fillProfiles: !!! WARNING !!!&#39;
<span class="linenos">2661</span>          write(*,*) &#39;tvs_fillProfiles: INVALID 10m wind speed&#39;
<span class="linenos">2662</span>          write(*,*) &#39;tvs_fillProfiles: headerIndex &#39;, headerIndex, &quot; !&quot;
<span class="linenos">2663</span>          write(*,*) &#39;tvs_fillProfiles: modulus &#39;, wind, &#39; larger than &#39;, wmax, &#39;set to zero !&#39;
<span class="linenos">2664</span>          profiles(tovsIndex) % s2m % u = 0.d0
<span class="linenos">2665</span>          profiles(tovsIndex) % s2m % v = 0.d0
<span class="linenos">2666</span>          call rejectObs(obsSpaceData, headerIndex)
<span class="linenos">2667</span>        end if
<span class="linenos">2668</span>        profiles(tovsIndex) % s2m % o         = 0.0d0 !surface ozone never used
<span class="linenos">2669</span>        profiles(tovsIndex) % s2m % wfetc     = 100000.0d0 ! Wind fetch (in meter for rttov10 ?) used to calculate reflection of solar radiation by sea surface
<span class="linenos">2670</span>        profiles(tovsIndex) % icede_param     = 0
<span class="linenos">2671</span>        profiles(tovsIndex) % Be              = 0.4d0 ! earth magnetic field strength (gauss) (must be non zero)
<span class="linenos">2672</span>        profiles(tovsIndex) % cosbk           = 0.0d0 ! cosine of the angle between the earth magnetic field and wave propagation direction
<span class="linenos">2673</span>        profiles(tovsIndex) % p(:)            = pressure(:,profileIndex)
<span class="linenos">2674</span>        call validateRttovVariable(profiles(tovsIndex) % p(nlv_T), &quot;pressure profile near surface&quot;, obsSpaceData, headerIndex, maximum_opt=2000.d0)
<span class="linenos">2675</span>        call validateRttovVariable(profiles(tovsIndex) % p(1), &quot;pressure profile near top&quot;, obsSpaceData, headerIndex, 0.d0) 
<span class="linenos">2676</span>        !RTTOV scatt needs half pressure levels (see figure 5 of RTTOV 12 User&#39;s Guide)
<span class="linenos">2677</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos">2678</span>          cld_profiles(tovsIndex) % ph (1) = 0.d0
<span class="linenos">2679</span>          cld_profiles(tovsIndex) % cfrac = 0.d0
<span class="linenos">2680</span>          do levelIndex = 1, nlv_T - 1
<span class="linenos">2681</span>            cld_profiles(tovsIndex) % ph (levelIndex+1) = 0.5d0 * (profiles(tovsIndex) % p(levelIndex) + &amp;
<span class="linenos">2682</span>                                                                   profiles(tovsIndex) % p(levelIndex+1))
<span class="linenos">2683</span>          end do
<span class="linenos">2684</span>          cld_profiles(tovsIndex) % ph (nlv_T+1) = profiles(tovsIndex) % s2m % p
<span class="linenos">2685</span>        end if
<span class="linenos">2686</span>        column_ptr =&gt; col_getColumn(columnTrl, headerIndex,&#39;TT&#39; )
<span class="linenos">2687</span>        profiles(tovsIndex) % t(:)   = column_ptr(:)
<span class="linenos">2688</span>        call validateRttovProfile(profiles(tovsIndex) % t, &#39;temparature&#39;, tmin, tmax, obsSpaceData, headerIndex) 
<span class="linenos">2689</span>        if (tvs_coefs(sensorIndex) %coef %nozone &gt; 0) then
<span class="linenos">2690</span>          profiles(tovsIndex) % o3(:) = ozone(:,profileIndex) * o3ppmv2Mixratio ! Climatology output is ppmv over dry air                                                                                                            ! because atmosphere is very dry where there is significant absorption by ozone)
<span class="linenos">2691</span>          if (.not. tvs_useO3Climatology)  then
<span class="linenos">2692</span>            profiles(tovsIndex) % s2m % o  = col_getElem(columnTrl,ilowlvl_T,headerIndex,trim(ozoneVarName)) * 1.0d-9 ! Assumes model ozone in ug/kg
<span class="linenos">2693</span>          end if
<span class="linenos">2694</span>          call validateRttovProfile(profiles(tovsIndex) % o3, &#39;ozone&#39;, o3min, o3max, obsSpaceData, headerIndex)
<span class="linenos">2695</span>        end if
<span class="linenos">2696</span>
<span class="linenos">2697</span>        column_ptr =&gt; col_getColumn(columnTrl, headerIndex,&#39;HU&#39; )
<span class="linenos">2698</span>        profiles(tovsIndex) % q(:)            =  column_ptr(:)
<span class="linenos">2699</span>        call validateRttovProfile(profiles(tovsIndex) % q, &#39;water vapor&#39;, qmin, qmax, obsSpaceData, headerIndex)
<span class="linenos">2700</span>        profiles(tovsIndex) % ctp = 1013.25d0
<span class="linenos">2701</span>        profiles(tovsIndex) % cfraction = 0.d0
<span class="linenos">2702</span>        if (runObsOperatorWithClw) then
<span class="linenos">2703</span>          profiles(tovsIndex) % clw(:) = clw(:,profileIndex)
<span class="linenos">2704</span>        else if (runObsOperatorWithHydrometeors) then
<span class="linenos">2705</span>          cld_profiles(tovsIndex) % hydro(:,1) = rainFlux(:,profileIndex)
<span class="linenos">2706</span>          cld_profiles(tovsIndex) % hydro(:,2) = snowFlux(:,profileIndex)
<span class="linenos">2707</span>          cld_profiles(tovsIndex) % hydro(:,4) = clw(:,profileIndex)
<span class="linenos">2708</span>          cld_profiles(tovsIndex) % hydro(:,5) = ciw(:,profileIndex)
<span class="linenos">2709</span>
<span class="linenos">2710</span>          do levelIndex = 1, nlv_T
<span class="linenos">2711</span>            if (cld_profiles(tovsIndex) % hydro(levelIndex,1) &gt; qlim_getMinValueCloud(&#39;RF&#39;) .or. &amp;
<span class="linenos">2712</span>                cld_profiles(tovsIndex) % hydro(levelIndex,2) &gt; qlim_getMinValueCloud(&#39;SF&#39;) .or. &amp;
<span class="linenos">2713</span>                cld_profiles(tovsIndex) % hydro(levelIndex,4) &gt; qlim_getMinValueCloud(&#39;LWCR&#39;) .or. &amp;
<span class="linenos">2714</span>                cld_profiles(tovsIndex) % hydro(levelIndex,5) &gt; qlim_getMinValueCloud(&#39;IWCR&#39;)) then
<span class="linenos">2715</span>              
<span class="linenos">2716</span>              ! set to overcast cloud, if CLDR not part of control variables
<span class="linenos">2717</span>              if (col_varExist(columnTrl,&#39;CLDR&#39;)) then
<span class="linenos">2718</span>                cld_profiles(tovsIndex) % hydro_frac(levelIndex,1) = cloudFraction(levelIndex,profileIndex)
<span class="linenos">2719</span>              else
<span class="linenos">2720</span>                cld_profiles(tovsIndex) % hydro_frac(levelIndex,1) = 1.0d0
<span class="linenos">2721</span>              end if
<span class="linenos">2722</span>            else
<span class="linenos">2723</span>              cld_profiles(tovsIndex) % hydro_frac(levelIndex,1) = qlim_getMinValueCloud(&#39;CLDR&#39;)  
<span class="linenos">2724</span>            end if
<span class="linenos">2725</span>
<span class="linenos">2726</span>          end do ! levelIndex
<span class="linenos">2727</span>        end if  ! runObsOperatorWithClw
<span class="linenos">2728</span>      end do ! profileIndex
<span class="linenos">2729</span>
<span class="linenos">2730</span>      deallocate (pressure,            stat = allocStatus(2))
<span class="linenos">2731</span>      deallocate (ozone,               stat = allocStatus(3))
<span class="linenos">2732</span>      deallocate (latitudes,           stat = allocStatus(4))
<span class="linenos">2733</span>      deallocate (sensorHeaderIndexes, stat = allocStatus(5))
<span class="linenos">2734</span>      deallocate (sensorTovsIndexes,   stat = allocStatus(6))
<span class="linenos">2735</span>      if (tvs_coefs(sensorIndex) %coef %nozone &gt; 0 .and. .not.tvs_useO3Climatology) then
<span class="linenos">2736</span>        deallocate (ozone,             stat = allocStatus(7))
<span class="linenos">2737</span>      end if
<span class="linenos">2738</span>      if ( allocated(clw) ) then
<span class="linenos">2739</span>        deallocate (clw,      stat= allocStatus(8))
<span class="linenos">2740</span>      end if
<span class="linenos">2741</span>      if ( allocated(ciw) ) then
<span class="linenos">2742</span>        deallocate (ciw,      stat= allocStatus(9))
<span class="linenos">2743</span>        deallocate (rainFlux, stat= allocStatus(10))
<span class="linenos">2744</span>        deallocate (snowFlux, stat= allocStatus(11))
<span class="linenos">2745</span>        deallocate (cloudFraction, stat= allocStatus(12))
<span class="linenos">2746</span>      end if
<span class="linenos">2747</span>      deallocate (surfTypeIsWater,stat= allocStatus(13))
<span class="linenos">2748</span>
<span class="linenos">2749</span>      call utl_checkAllocationStatus(allocStatus, &#39; tvs_fillProfiles&#39;, .false.)
<span class="linenos">2750</span>     
<span class="linenos">2751</span>    end do sensor_loop
<span class="linenos">2752</span>
<span class="linenos">2753</span>  end subroutine tvs_fillProfiles
<span class="linenos">2754</span>
<span class="linenos">2755</span>  !--------------------------------------------------------------------------
<span class="linenos">2756</span>  !  tvs_getCorrectedSatelliteAzimuth
<span class="linenos">2757</span>  !--------------------------------------------------------------------------
<span class="linenos">2758</span>  function tvs_getCorrectedSatelliteAzimuth(obsSpaceData, headerIndex) result(correctedAzimuth)
<span class="linenos">2759</span>    !
<span class="linenos">2760</span>    !:Purpose: get properly corrected satellite Azimuth Angle from obsSpaceData header
<span class="linenos">2761</span>    !
<span class="linenos">2762</span>    implicit none
<span class="linenos">2763</span>    ! Arguments
<span class="linenos">2764</span>    type(struct_obs), intent(in) :: obsSpaceData     ! obsSpaceData structure
<span class="linenos">2765</span>    integer, intent(in)          :: headerIndex      ! location in header
<span class="linenos">2766</span>    real(8)                      :: correctedAzimuth ! corrected azimuth (function result)
<span class="linenos">2767</span>    ! Locals
<span class="linenos">2768</span>    integer :: sensorNo, tovsIndex
<span class="linenos">2769</span>
<span class="linenos">2770</span>    correctedAzimuth = obs_headElem_r(obsSpaceData,OBS_AZA,headerIndex)
<span class="linenos">2771</span>
<span class="linenos">2772</span>    tovsIndex = tvs_tovsIndex (headerIndex)
<span class="linenos">2773</span>    if ( tovsIndex &lt; 0) return
<span class="linenos">2774</span>
<span class="linenos">2775</span>    sensorNo  = tvs_lsensor(tovsIndex)
<span class="linenos">2776</span>
<span class="linenos">2777</span>    if ( .not. tvs_isAzimuthValid(sensorNo) ) then
<span class="linenos">2778</span>      correctedAzimuth = obs_missingValue_R
<span class="linenos">2779</span>      return
<span class="linenos">2780</span>    end if
<span class="linenos">2781</span>
<span class="linenos">2782</span>    if ( tvs_doAzimuthCorrection(sensorNo) ) then
<span class="linenos">2783</span>      ! Correction sur la definition de l&#39;angle.
<span class="linenos">2784</span>      correctedAzimuth = obs_headElem_r(obsSpaceData,OBS_SAZ,headerIndex) + correctedAzimuth
<span class="linenos">2785</span>      if ( correctedAzimuth &gt; 360.d0 ) correctedAzimuth = correctedAzimuth - 360.d0
<span class="linenos">2786</span>    end if
<span class="linenos">2787</span>
<span class="linenos">2788</span>  end function tvs_getCorrectedSatelliteAzimuth
<span class="linenos">2789</span>
<span class="linenos">2790</span>
<span class="linenos">2791</span>  !--------------------------------------------------------------------------
<span class="linenos">2792</span>  !  tvs_rttov
<span class="linenos">2793</span>  !--------------------------------------------------------------------------
<span class="linenos">2794</span>  subroutine tvs_rttov(obsSpaceData, bgckMode, beSilent)
<span class="linenos">2795</span>    !
<span class="linenos">2796</span>    !:Purpose: Interface for RTTOV non linear operator
<span class="linenos">2797</span>    !           tvs_fillProfiles should be called before
<span class="linenos">2798</span>    !
<span class="linenos">2799</span>    implicit none
<span class="linenos">2800</span>
<span class="linenos">2801</span>    ! Arguments
<span class="linenos">2802</span>    type(struct_obs), intent(inout) :: obsSpaceData  ! obsSpaceData structure
<span class="linenos">2803</span>    logical, intent(in)             :: bgckMode       ! flag to transfer transmittances and cloudy overcast radiances in bgck mode 
<span class="linenos">2804</span>    logical, intent(in)             :: beSilent       ! flag to control verbosity
<span class="linenos">2805</span>
<span class="linenos">2806</span>    ! Locals:
<span class="linenos">2807</span>    integer :: nlv_T
<span class="linenos">2808</span>    integer :: btCount
<span class="linenos">2809</span>    integer :: allocStatus(4)
<span class="linenos">2810</span>    integer :: rttov_err_stat ! rttov error return code
<span class="linenos">2811</span>    integer, external :: omp_get_num_threads
<span class="linenos">2812</span>    integer :: nthreads,max_nthreads
<span class="linenos">2813</span>    integer :: sensorId, tovsIndex
<span class="linenos">2814</span>    integer :: channelIndex, channelIndexFound, channelNumber
<span class="linenos">2815</span>    integer :: profileCount
<span class="linenos">2816</span>    integer :: profileIndex, levelIndex, jj, btIndex
<span class="linenos">2817</span>    integer :: instrum
<span class="linenos">2818</span>    integer :: sensorType        ! sensor type (1=infrared; 2=microwave; 3=high resolution,4=polarimetric)
<span class="linenos">2819</span>    integer, allocatable:: sensorTovsIndexes(:)  
<span class="linenos">2820</span>    
<span class="linenos">2821</span>    type (rttov_emissivity), pointer :: emissivity_local(:)    ! emissivity structure with input and output
<span class="linenos">2822</span>    type (rttov_chanprof), pointer :: chanprof(:)
<span class="linenos">2823</span>    type (rttov_chanprof), allocatable :: chanprof1(:)
<span class="linenos">2824</span>    type (rttov_radiance) :: radiancedata_d, radiancedata_d1
<span class="linenos">2825</span>    type (rttov_transmission) :: transmission, transmission1
<span class="linenos">2826</span>    integer              :: asw
<span class="linenos">2827</span>    logical, pointer :: calcemis(:)
<span class="linenos">2828</span>    real(8), allocatable  :: surfem1(:)
<span class="linenos">2829</span>    integer, allocatable  :: frequencies(:)
<span class="linenos">2830</span>    real(8), allocatable  :: uOfWLandWSurfaceEmissivity(:)
<span class="linenos">2831</span>    logical, allocatable  :: lchannel_subset(:,:)
<span class="linenos">2832</span>    integer               :: profileIndex2, tb1, tb2
<span class="linenos">2833</span>    integer :: istart, iend, bodyIndex, headerIndex
<span class="linenos">2834</span>    real(8) :: clearMwRadiance
<span class="linenos">2835</span>    logical :: ifBodyIndexFound
<span class="linenos">2836</span>    logical :: runObsOperatorWithClw
<span class="linenos">2837</span>    logical :: runObsOperatorWithHydrometeors
<span class="linenos">2838</span>
<span class="linenos">2839</span>    if ( .not. beSilent ) write(*,*) &#39;tvs_rttov: Starting&#39;
<span class="linenos">2840</span>    if ( .not. beSilent ) write(*,*) &#39;Memory Used: &#39;,get_max_rss()/1024,&#39;Mb&#39;
<span class="linenos">2841</span>
<span class="linenos">2842</span>    if (tvs_nobtov == 0) return                  ! exit if there are not tovs data
<span class="linenos">2843</span>
<span class="linenos">2844</span>    !   1.  Get number of threads available and allocate memory for some variables
<span class="linenos">2845</span>    !$omp parallel
<span class="linenos">2846</span>    max_nthreads = omp_get_num_threads()
<span class="linenos">2847</span>    !$omp end parallel
<span class="linenos">2848</span>    allocStatus(:) = 0
<span class="linenos">2849</span>    allocate(sensorTovsIndexes(tvs_nobtov),stat=allocStatus(1))
<span class="linenos">2850</span>    call utl_checkAllocationStatus(allocStatus(1:1), &#39; tvs_rttov sensorTovsIndexes&#39;)
<span class="linenos">2851</span>    
<span class="linenos">2852</span>    
<span class="linenos">2853</span>    !   1.1   Read surface information
<span class="linenos">2854</span>    if ( bgckMode ) call EMIS_READ_CLIMATOLOGY
<span class="linenos">2855</span>
<span class="linenos">2856</span>    !   2.  Computation of hx for tovs data only
<span class="linenos">2857</span>
<span class="linenos">2858</span>    ! Loop over all sensors specified by user
<span class="linenos">2859</span>    sensor_loop:do sensorId = 1, tvs_nsensors
<span class="linenos">2860</span>   
<span class="linenos">2861</span>      sensorType = tvs_coefs(sensorId) % coef % id_sensor
<span class="linenos">2862</span>      instrum = tvs_coefs(sensorId) % coef % id_inst
<span class="linenos">2863</span>
<span class="linenos">2864</span>      runObsOperatorWithClw = (tvs_numMWInstrumUsingCLW /= 0 .and. &amp;
<span class="linenos">2865</span>                               tvs_isInstrumUsingCLW(tvs_instruments(sensorId)))
<span class="linenos">2866</span>      runObsOperatorWithHydrometeors = (tvs_numMWInstrumUsingHydrometeors /= 0 .and. &amp;
<span class="linenos">2867</span>                                        tvs_isInstrumUsingHydrometeors(tvs_instruments(sensorId)))
<span class="linenos">2868</span>                                        
<span class="linenos">2869</span>      if (runObsOperatorWithClw .and. runObsOperatorWithHydrometeors) then
<span class="linenos">2870</span>        call utl_abort(&#39;tvs_rttov: this instrument is mentioned in using CLW and hydrometeors.&#39;)
<span class="linenos">2871</span>      end if
<span class="linenos">2872</span>    
<span class="linenos">2873</span>      !  loop over all obs.
<span class="linenos">2874</span>      profileCount = 0
<span class="linenos">2875</span>      obs_loop: do tovsIndex = 1, tvs_nobtov
<span class="linenos">2876</span>        
<span class="linenos">2877</span>        !    Currently processed sensor?
<span class="linenos">2878</span>        if ( tvs_lsensor(tovsIndex) == sensorId ) then
<span class="linenos">2879</span>          profileCount = profileCount + 1
<span class="linenos">2880</span>          sensorTovsIndexes(profileCount) = tovsIndex
<span class="linenos">2881</span>          nlv_T = tvs_profiles_nl(tovsIndex) % nlevels
<span class="linenos">2882</span>        end if
<span class="linenos">2883</span>      end do obs_loop
<span class="linenos">2884</span>      
<span class="linenos">2885</span>      if (profileCount == 0) cycle sensor_loop
<span class="linenos">2886</span>      
<span class="linenos">2887</span>      !    2.1  Calculate the actual number of threads which will be used.
<span class="linenos">2888</span>      
<span class="linenos">2889</span>      nthreads = min(max_nthreads, profileCount )  
<span class="linenos">2890</span>      
<span class="linenos">2891</span>      !    2.2  Prepare all input variables required by rttov.
<span class="linenos">2892</span>      
<span class="linenos">2893</span>      if ( bgckMode .and. tvs_isInstrumHyperSpectral(instrum) ) then
<span class="linenos">2894</span>        btCount = profileCount * tvs_nchan(sensorId)
<span class="linenos">2895</span>      else
<span class="linenos">2896</span>        btCount = tvs_countRadiances(sensorTovsIndexes(1:profileCount), obsSpaceData)
<span class="linenos">2897</span>      end if
<span class="linenos">2898</span>      
<span class="linenos">2899</span>      if (allocated(tvs_bodyIndexFromBtIndex)) deallocate(tvs_bodyIndexFromBtIndex)
<span class="linenos">2900</span>      allocate(tvs_bodyIndexFromBtIndex(btCount))
<span class="linenos">2901</span>
<span class="linenos">2902</span>      if ( btCount == 0 ) cycle sensor_loop
<span class="linenos">2903</span>      tvs_bodyIndexFromBtIndex(:) = -1      
<span class="linenos">2904</span>      allocate ( surfem1          (btCount) ,stat=allocStatus(1))
<span class="linenos">2905</span>
<span class="linenos">2906</span>      asw = 1 ! Allocation
<span class="linenos">2907</span>      call rttov_alloc_direct(            &amp;
<span class="linenos">2908</span>              allocStatus(2),             &amp;
<span class="linenos">2909</span>              asw,                        &amp;
<span class="linenos">2910</span>              nprofiles=profileCount,     &amp; ! (not used)
<span class="linenos">2911</span>              nchanprof=btCount,          &amp;
<span class="linenos">2912</span>              nlevels=nlv_T,              &amp;
<span class="linenos">2913</span>              chanprof=chanprof,          &amp;
<span class="linenos">2914</span>              opts=tvs_opts(sensorId),    &amp;
<span class="linenos">2915</span>              coefs=tvs_coefs(sensorId),  &amp;
<span class="linenos">2916</span>              transmission=transmission,  &amp;
<span class="linenos">2917</span>              radiance=radiancedata_d,    &amp;
<span class="linenos">2918</span>              calcemis=calcemis,          &amp;
<span class="linenos">2919</span>              emissivity=emissivity_local,&amp;
<span class="linenos">2920</span>              init=.true.)
<span class="linenos">2921</span>
<span class="linenos">2922</span>      if (runObsOperatorWithHydrometeors) then
<span class="linenos">2923</span>        allocate ( frequencies(btCount), stat=allocStatus(3))
<span class="linenos">2924</span>      end if
<span class="linenos">2925</span>
<span class="linenos">2926</span>      if (useUofWIREmiss) then
<span class="linenos">2927</span>        allocate ( uOfWLandWSurfaceEmissivity(btCount), stat=allocStatus(4) )
<span class="linenos">2928</span>      end if
<span class="linenos">2929</span>      call utl_checkAllocationStatus(allocStatus, &#39; tvs_rttov&#39;)
<span class="linenos">2930</span>      
<span class="linenos">2931</span>      !     get Hyperspectral IR emissivities
<span class="linenos">2932</span>      if ( tvs_isInstrumHyperSpectral(instrum) ) then
<span class="linenos">2933</span>        surfem1(:) = 0.
<span class="linenos">2934</span>        if ( bgckMode ) then
<span class="linenos">2935</span>          call emis_getIrEmissivity (surfem1,tvs_nchan(sensorId),sensorId,profileCount,btCount,sensorTovsIndexes)
<span class="linenos">2936</span>        else
<span class="linenos">2937</span>          call tvs_getHIREmissivities(sensorTovsIndexes(1:profileCount), obsSpaceData, surfem1)
<span class="linenos">2938</span>        end if
<span class="linenos">2939</span>      end if
<span class="linenos">2940</span>      
<span class="linenos">2941</span>      if ( bgckMode .and. tvs_isInstrumHyperSpectral(instrum) ) then
<span class="linenos">2942</span>        btIndex = 0
<span class="linenos">2943</span>        do profileIndex = 1 , profileCount
<span class="linenos">2944</span>          do  channelIndex = 1,tvs_nchan(sensorId)
<span class="linenos">2945</span>            btIndex = btIndex + 1
<span class="linenos">2946</span>            chanprof(btIndex)%prof = profileIndex
<span class="linenos">2947</span>            chanprof(btIndex)%chan = channelIndex
<span class="linenos">2948</span>          end do
<span class="linenos">2949</span>        end do
<span class="linenos">2950</span>        
<span class="linenos">2951</span>        do profileIndex = 1, profileCount
<span class="linenos">2952</span>          headerIndex = tvs_headerIndex(sensorTovsIndexes(profileIndex))
<span class="linenos">2953</span>          if (headerIndex &gt; 0) then
<span class="linenos">2954</span>            istart = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)
<span class="linenos">2955</span>            iend = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex) + istart - 1
<span class="linenos">2956</span>            do bodyIndex = istart, iend
<span class="linenos">2957</span>              call tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos">2958</span>                  channelNumber, channelIndex )
<span class="linenos">2959</span>              if (channelIndex &gt; 0) then
<span class="linenos">2960</span>                tvs_bodyIndexFromBtIndex((profileIndex-1)*tvs_nchan(sensorId)+channelIndex) = bodyIndex
<span class="linenos">2961</span>              else
<span class="linenos">2962</span>                write(*,*) &#39;tvs_rttov: strange channel number&#39;,channelNumber
<span class="linenos">2963</span>              end if
<span class="linenos">2964</span>            end do
<span class="linenos">2965</span>          end if
<span class="linenos">2966</span>        end do
<span class="linenos">2967</span>        
<span class="linenos">2968</span>      else
<span class="linenos">2969</span>        allocate( lchannel_subset(profileCount,tvs_nchan(sensorId)) )
<span class="linenos">2970</span>        call tvs_getChanprof(sensorTovsIndexes(1:profileCount), obsSpaceData, chanprof, lchannel_subset_opt = lchannel_subset, iptobs_cma_opt = tvs_bodyIndexFromBtIndex)
<span class="linenos">2971</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos">2972</span>          call rttov_scatt_setupindex (  &amp;
<span class="linenos">2973</span>               rttov_err_stat,           &amp;
<span class="linenos">2974</span>               profileCount,             &amp;  ! number of profiles
<span class="linenos">2975</span>               tvs_nchan(sensorId),      &amp;  ! number of channels 
<span class="linenos">2976</span>               tvs_coefs(sensorId),      &amp;  ! coef structure read in from rttov coef file
<span class="linenos">2977</span>               tvs_coef_scatt(sensorId), &amp;  ! 
<span class="linenos">2978</span>               btcount,                  &amp;  ! number of calculated channels
<span class="linenos">2979</span>               chanprof,                 &amp;  ! channels and profile numbers
<span class="linenos">2980</span>               frequencies,              &amp;  ! array, frequency number for each channel
<span class="linenos">2981</span>               lchannel_subset )            ! OPTIONAL array of logical flags to indicate a subset of channels
<span class="linenos">2982</span>        end if
<span class="linenos">2983</span>        deallocate( lchannel_subset )
<span class="linenos">2984</span>      end if
<span class="linenos">2985</span>                 
<span class="linenos">2986</span>      call tvs_getOtherEmissivities(chanprof, sensorTovsIndexes, sensorType, instrum, surfem1, calcemis)
<span class="linenos">2987</span>      
<span class="linenos">2988</span>      if (useUofWIREmiss .and. tvs_isInstrumHyperSpectral(instrum) .and. bgckMode) then
<span class="linenos">2989</span>        if (.not. allocated (tvs_atlas)) allocate(tvs_atlas(tvs_nsensors))
<span class="linenos">2990</span>        if ( .not. tvs_atlas(sensorId)%init) then
<span class="linenos">2991</span>          call rttov_setup_emis_atlas( rttov_err_stat,  &amp;! out
<span class="linenos">2992</span>               tvs_opts(sensorId),                      &amp;! in
<span class="linenos">2993</span>               tvs_profiles_nl(1)%date(2) ,             &amp;! in
<span class="linenos">2994</span>               atlas_type_ir,                           &amp;! in
<span class="linenos">2995</span>               tvs_atlas(sensorId),                     &amp;! in
<span class="linenos">2996</span>               ir_atlas_ang_corr = .false.,             &amp;! in
<span class="linenos">2997</span>               ir_atlas_read_std = .false.,             &amp;! in
<span class="linenos">2998</span>               coefs = tvs_coefs(sensorId)  )
<span class="linenos">2999</span>          if (rttov_err_stat/=0) then
<span class="linenos">3000</span>            write(*,*) &#39;Error in rttov_atlas_setup IR&#39;,rttov_err_stat
<span class="linenos">3001</span>            call utl_abort(&#39;tvs_rttov&#39;)
<span class="linenos">3002</span>          end if
<span class="linenos">3003</span>        end if
<span class="linenos">3004</span>          
<span class="linenos">3005</span>        call rttov_get_emis( rttov_err_stat,                  &amp; ! out
<span class="linenos">3006</span>             tvs_opts(sensorId),                              &amp; ! in
<span class="linenos">3007</span>             chanprof(1:btCount),                             &amp; ! in
<span class="linenos">3008</span>             tvs_profiles_nl(sensorTovsIndexes(1:profileCount)), &amp; ! in
<span class="linenos">3009</span>             tvs_coefs(sensorId),                             &amp; ! in
<span class="linenos">3010</span>             tvs_atlas(sensorId),                             &amp; ! inout
<span class="linenos">3011</span>             uOfWLandWSurfaceEmissivity(1:btCount) )            ! out
<span class="linenos">3012</span>
<span class="linenos">3013</span>        if (rttov_err_stat /= 0) then
<span class="linenos">3014</span>          write(*,*) &#39;Error in rttov_get_emis IR&#39;, rttov_err_stat
<span class="linenos">3015</span>          call utl_abort(&#39;tvs_rttov&#39;)
<span class="linenos">3016</span>        end if
<span class="linenos">3017</span>              
<span class="linenos">3018</span>        do profileIndex=1, profileCount !loop on profiles
<span class="linenos">3019</span>          jj = sensorTovsIndexes(profileIndex)
<span class="linenos">3020</span>          do btIndex=1, btCount !loop on channels
<span class="linenos">3021</span>            if (chanprof(btIndex)%prof==profileIndex) then
<span class="linenos">3022</span>              ! surftype: 0 land, 1 sea, 2 sea-ice
<span class="linenos">3023</span>              ! this logic is primitive and could be improved for example using
<span class="linenos">3024</span>              ! additional criteria based on emissivity_std and emissivity_flg
<span class="linenos">3025</span>              !Definition of emis_flag:
<span class="linenos">3026</span>              ! emis_flag:Flag_0 = &#39;0 = sea, no MOD11 data&#39; ;
<span class="linenos">3027</span>              ! emis_flag:Flag_1 = &#39;1 = land where BF method was applied&#39; ;
<span class="linenos">3028</span>              ! emis_flag:Flag_2 = &#39;2 = land where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4&#39; ;
<span class="linenos">3029</span>              ! emis_flag:Flag_3 = &#39;3 = contains inland water or coastline by the sea/land mask where the BF method was used&#39; ;
<span class="linenos">3030</span>              ! emis_flag:Flag_4 = &#39;4 = contains inland water or coastline by the sea/land mask where data was filled with average original UWiremis bfemis_flag=2 or 3 or 4&#39; ;
<span class="linenos">3031</span>              ! emis_flag:Flag_5 = &#39;5 = contains coastline by land fraction where the BF method was used&#39; ;
<span class="linenos">3032</span>              ! emis_flag:Flag_6 = &#39;6 = contains coastline by land fraction where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4&#39; ;
<span class="linenos">3033</span>              ! other information that could be useful for quality control can be found in the in the profile_qc structure
<span class="linenos">3034</span>              ! Now we have the &#39;traditionnal&#39; emissivity in surfem1(:)
<span class="linenos">3035</span>              ! and University of Wisconsin emissivity in uOfWLandWSurfaceEmissivity(:)
<span class="linenos">3036</span>              if (tvs_profiles_nl(jj)% skin % surftype == surftype_land .and. &amp;
<span class="linenos">3037</span>                   uOfWLandWSurfaceEmissivity(btIndex) &gt; 0.5 ) then
<span class="linenos">3038</span>                emissivity_local(btIndex)%emis_in = uOfWLandWSurfaceEmissivity(btIndex)
<span class="linenos">3039</span>              else
<span class="linenos">3040</span>                emissivity_local(btIndex)%emis_in = surfem1(btIndex)
<span class="linenos">3041</span>              end if
<span class="linenos">3042</span>            end if
<span class="linenos">3043</span>          end do
<span class="linenos">3044</span>        end do
<span class="linenos">3045</span>
<span class="linenos">3046</span>      else if (sensorType == sensor_id_mw) then
<span class="linenos">3047</span>        call tvs_getMWemissivityFromAtlas(surfem1(1:btcount), emissivity_local, sensorId, chanprof, &amp;
<span class="linenos">3048</span>             sensorTovsIndexes(1:profileCount))
<span class="linenos">3049</span>      else
<span class="linenos">3050</span>        emissivity_local(:)%emis_in = surfem1(:)
<span class="linenos">3051</span>      end if
<span class="linenos">3052</span>
<span class="linenos">3053</span>      !   2.3  Compute radiance with rttov_direct
<span class="linenos">3054</span>
<span class="linenos">3055</span>      rttov_err_stat = 0 
<span class="linenos">3056</span>
<span class="linenos">3057</span>      if( bgckMode .and. tvs_isInstrumHyperSpectral(instrum) ) then
<span class="linenos">3058</span>        write(*,*) &#39;for bgck IR: call rttov_parallel_direct for each profile...&#39;
<span class="linenos">3059</span>
<span class="linenos">3060</span>        asw = 1 ! 1 to allocate,0 to deallocate
<span class="linenos">3061</span>        ! allocate transmitance structure for 1 profile
<span class="linenos">3062</span>        call rttov_alloc_transmission(allocStatus(1), transmission1, nlevels=nlv_T, &amp;
<span class="linenos">3063</span>             nchanprof=tvs_nchan(sensorId), asw=asw, init=.true.)
<span class="linenos">3064</span>        ! allocate radiance structure for 1 profile
<span class="linenos">3065</span>        call rttov_alloc_rad (allocStatus(2),tvs_nchan(sensorId), radiancedata_d1,nlv_T,asw,init=.true.)
<span class="linenos">3066</span>        ! allocate chanprof for 1 profile
<span class="linenos">3067</span>        allocate(chanprof1(tvs_nchan(sensorId)))
<span class="linenos">3068</span>        do  channelIndex = 1,tvs_nchan(sensorId)
<span class="linenos">3069</span>          chanprof1(channelIndex)%prof = 1
<span class="linenos">3070</span>          chanprof1(channelIndex)%chan = channelIndex
<span class="linenos">3071</span>        end do
<span class="linenos">3072</span>
<span class="linenos">3073</span>        do profileIndex2 = 1, profileCount
<span class="linenos">3074</span>          tb1 = 1 + (profileIndex2-1) * tvs_nchan(sensorId) 
<span class="linenos">3075</span>          tb2 = profileIndex2 * tvs_nchan(sensorId)
<span class="linenos">3076</span>
<span class="linenos">3077</span>          call rttov_parallel_direct(                                                              &amp;
<span class="linenos">3078</span>               rttov_err_stat,                                                                     &amp; ! out
<span class="linenos">3079</span>               chanprof1,                                                                          &amp; ! in
<span class="linenos">3080</span>               tvs_opts(sensorId),                                                                 &amp; ! in
<span class="linenos">3081</span>               tvs_profiles_nl(sensorTovsIndexes(profileIndex2):sensorTovsIndexes(profileIndex2)), &amp; ! in
<span class="linenos">3082</span>               tvs_coefs(sensorId),                                                                &amp; ! in
<span class="linenos">3083</span>               transmission1,                                                                      &amp; ! inout
<span class="linenos">3084</span>               radiancedata_d1,                                                                    &amp; ! inout
<span class="linenos">3085</span>               calcemis=calcemis(tb1:tb2),                                                         &amp; ! in
<span class="linenos">3086</span>               emissivity=emissivity_local(tb1:tb2),                                               &amp; ! inout
<span class="linenos">3087</span>               nthreads=nthreads )   
<span class="linenos">3088</span>
<span class="linenos">3089</span>          ! copy contents of single profile structures into complete structures
<span class="linenos">3090</span>          transmission%tau_total(tb1:tb2)             = transmission1%tau_total(:)
<span class="linenos">3091</span>          transmission%tau_levels(:,tb1:tb2)          = transmission1%tau_levels(:,:)
<span class="linenos">3092</span>          transmission%tausun_levels_path1(:,tb1:tb2) = transmission1%tausun_levels_path1(:,:)
<span class="linenos">3093</span>          transmission%tausun_levels_path2(:,tb1:tb2) = transmission1%tausun_levels_path2(:,:)
<span class="linenos">3094</span>          transmission%tausun_total_path1(tb1:tb2)    = transmission1%tausun_total_path1(:)
<span class="linenos">3095</span>          transmission%tausun_total_path2(tb1:tb2)    = transmission1%tausun_total_path2(:)
<span class="linenos">3096</span>          radiancedata_d%clear(tb1:tb2)      = radiancedata_d1%clear(:)
<span class="linenos">3097</span>          radiancedata_d%total(tb1:tb2)      = radiancedata_d1%total(:)
<span class="linenos">3098</span>          radiancedata_d%bt_clear(tb1:tb2)   = radiancedata_d1%bt_clear(:)
<span class="linenos">3099</span>          radiancedata_d%bt(tb1:tb2)         = radiancedata_d1%bt(:)
<span class="linenos">3100</span>          radiancedata_d%refl_clear(tb1:tb2) = radiancedata_d1%refl_clear(:)
<span class="linenos">3101</span>          radiancedata_d%refl(tb1:tb2)       = radiancedata_d1%refl(:)
<span class="linenos">3102</span>          radiancedata_d%overcast(:,tb1:tb2) = radiancedata_d1%overcast(:,:)
<span class="linenos">3103</span>          radiancedata_d%cloudy(tb1:tb2)     = radiancedata_d1%cloudy(:)
<span class="linenos">3104</span>
<span class="linenos">3105</span>        end do
<span class="linenos">3106</span>
<span class="linenos">3107</span>        ! transmittance deallocation for 1 profile
<span class="linenos">3108</span>        deallocate(chanprof1)
<span class="linenos">3109</span>        asw = 0 ! 1 to allocate,0 to deallocate
<span class="linenos">3110</span>        ! transmittance deallocation for 1 profile
<span class="linenos">3111</span>        call rttov_alloc_transmission(allocStatus(1),transmission1,nlevels=nlv_T,  &amp;
<span class="linenos">3112</span>             nchanprof=tvs_nchan(sensorId), asw=asw )
<span class="linenos">3113</span>        ! radiance deallocation for 1 profile
<span class="linenos">3114</span>        call rttov_alloc_rad (allocStatus(2), tvs_nchan(sensorId), radiancedata_d1, nlv_T, asw)
<span class="linenos">3115</span>
<span class="linenos">3116</span>      else
<span class="linenos">3117</span>
<span class="linenos">3118</span>        ! run clear-sky RTTOV, save the radiances in OBS_BTCL of obsSpaceData 
<span class="linenos">3119</span>        if ((runObsOperatorWithClw .or. runObsOperatorWithHydrometeors) .and. &amp;
<span class="linenos">3120</span>            obs_columnActive_RB(obsSpaceData, OBS_BTCL)) then
<span class="linenos">3121</span>
<span class="linenos">3122</span>          ! run rttovScatt
<span class="linenos">3123</span>          if (runObsOperatorWithHydrometeors) then
<span class="linenos">3124</span>            ! set the cloud profile in tvs_cld_profiles_nl to zero
<span class="linenos">3125</span>            call updateCloudInTovsCloudProfile(sensorTovsIndexes(1:profileCount), &amp;
<span class="linenos">3126</span>                                          nlv_T,                      &amp;
<span class="linenos">3127</span>                                          mode=&#39;save&#39;,                &amp;
<span class="linenos">3128</span>                                          beSilent=.true.)
<span class="linenos">3129</span>            call rttov_scatt(                                         &amp;
<span class="linenos">3130</span>                 rttov_err_stat,                                      &amp;! out
<span class="linenos">3131</span>                 tvs_opts_scatt(sensorId),                            &amp;! in
<span class="linenos">3132</span>                 nlv_T,                                               &amp;! in
<span class="linenos">3133</span>                 chanprof,                                            &amp;! in
<span class="linenos">3134</span>                 frequencies,                                         &amp;! in
<span class="linenos">3135</span>                 tvs_profiles_nl(sensorTovsIndexes(1:profileCount)),  &amp;! in
<span class="linenos">3136</span>                 tvs_cld_profiles_nl(sensorTovsIndexes(1:profileCount)), &amp;! in
<span class="linenos">3137</span>                 tvs_coefs(sensorId),                                 &amp;! in
<span class="linenos">3138</span>                 tvs_coef_scatt(sensorId),                            &amp;! in
<span class="linenos">3139</span>                 calcemis,                                            &amp;! in
<span class="linenos">3140</span>                 emissivity_local,                                    &amp;! inout
<span class="linenos">3141</span>                 radiancedata_d) 
<span class="linenos">3142</span>          else
<span class="linenos">3143</span>            ! set the cloud profile in tvs_profiles_nl to zero
<span class="linenos">3144</span>            call updateCloudInTovsProfile(sensorTovsIndexes(1:profileCount), &amp;
<span class="linenos">3145</span>                                          nlv_T,                      &amp;
<span class="linenos">3146</span>                                          mode=&#39;save&#39;,                &amp;
<span class="linenos">3147</span>                                          beSilent=.true.)
<span class="linenos">3148</span>            call rttov_parallel_direct(                               &amp;
<span class="linenos">3149</span>                 rttov_err_stat,                                      &amp; ! out
<span class="linenos">3150</span>                 chanprof,                                            &amp; ! in
<span class="linenos">3151</span>                 tvs_opts(sensorId),                                  &amp; ! in
<span class="linenos">3152</span>                 tvs_profiles_nl(sensorTovsIndexes(1:profileCount)),  &amp; ! in
<span class="linenos">3153</span>                 tvs_coefs(sensorId),                                 &amp; ! in
<span class="linenos">3154</span>                 transmission,                                        &amp; ! inout
<span class="linenos">3155</span>                 radiancedata_d,                                      &amp; ! inout
<span class="linenos">3156</span>                 calcemis=calcemis,                                   &amp; ! in
<span class="linenos">3157</span>                 emissivity=emissivity_local,                         &amp; ! inout
<span class="linenos">3158</span>                 nthreads=nthreads      )   
<span class="linenos">3159</span>          end if ! run rttovScatt
<span class="linenos">3160</span>
<span class="linenos">3161</span>          ! save in obsSpaceData
<span class="linenos">3162</span>          loopClearSky1: do btIndex = 1, btCount
<span class="linenos">3163</span>            profileIndex = chanprof(btIndex)%prof
<span class="linenos">3164</span>            channelIndex = chanprof(btIndex)%chan
<span class="linenos">3165</span>            tovsIndex = sensorTovsIndexes(profileIndex)
<span class="linenos">3166</span>
<span class="linenos">3167</span>            clearMwRadiance = radiancedata_d % bt(btIndex)
<span class="linenos">3168</span>
<span class="linenos">3169</span>            headerIndex = tvs_headerIndex(tovsIndex)
<span class="linenos">3170</span>            if ( headerIndex &lt; 1 ) cycle loopClearSky1
<span class="linenos">3171</span>            istart = obs_headElem_i(obsSpaceData, OBS_RLN, headerIndex)
<span class="linenos">3172</span>            iend = obs_headElem_i(obsSpaceData, OBS_NLV, headerIndex) + istart - 1
<span class="linenos">3173</span>
<span class="linenos">3174</span>            ifBodyIndexFound = .false.
<span class="linenos">3175</span>            loopClearSky2: do bodyIndex = istart, iend
<span class="linenos">3176</span>              call tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos">3177</span>                                                  channelNumber, channelIndexFound )
<span class="linenos">3178</span>              if ( channelIndex == channelIndexFound ) then
<span class="linenos">3179</span>                ifBodyIndexFound = .true.
<span class="linenos">3180</span>                exit loopClearSky2
<span class="linenos">3181</span>              end if
<span class="linenos">3182</span>            end do loopClearSky2
<span class="linenos">3183</span>
<span class="linenos">3184</span>            if ( .not. ifBodyIndexFound ) call utl_abort(&#39;tvs_rttov: bodyIndex not found.&#39;)
<span class="linenos">3185</span>
<span class="linenos">3186</span>            if (obs_bodyElem_i(obsSpaceData, OBS_ASS, bodyIndex) == obs_assimilated) then
<span class="linenos">3187</span>              call obs_bodySet_r(obsSpaceData, OBS_BTCL, bodyIndex, clearMwRadiance)
<span class="linenos">3188</span>            end if
<span class="linenos">3189</span>          end do loopClearSky1
<span class="linenos">3190</span>
<span class="linenos">3191</span>          ! restore the cloud profiles in ...
<span class="linenos">3192</span>          if (runObsOperatorWithHydrometeors) then
<span class="linenos">3193</span>            ! tvs_cld_profiles_nl
<span class="linenos">3194</span>            call updateCloudInTovsCloudProfile(sensorTovsIndexes(1:profileCount), &amp;
<span class="linenos">3195</span>                                          nlv_T,                             &amp;
<span class="linenos">3196</span>                                          mode=&#39;restore&#39;,                    &amp;
<span class="linenos">3197</span>                                          beSilent=.true.)
<span class="linenos">3198</span>          else
<span class="linenos">3199</span>            ! tvs_profiles_nl
<span class="linenos">3200</span>            call updateCloudInTovsProfile(sensorTovsIndexes(1:profileCount), &amp;
<span class="linenos">3201</span>                                          nlv_T,                             &amp;
<span class="linenos">3202</span>                                          mode=&#39;restore&#39;,                    &amp;
<span class="linenos">3203</span>                                          beSilent=.true.)
<span class="linenos">3204</span>          end if
<span class="linenos">3205</span>        end if ! run clear-sky RTTOV
<span class="linenos">3206</span>
<span class="linenos">3207</span>        if (runObsOperatorWithHydrometeors) then
<span class="linenos">3208</span>          if (.not. beSilent) write(*,*) &#39;before rttov_scatt...&#39;, sensorID, profileCount
<span class="linenos">3209</span>          call rttov_scatt(                                         &amp;
<span class="linenos">3210</span>               rttov_err_stat,                                      &amp;! out
<span class="linenos">3211</span>               tvs_opts_scatt(sensorId),                            &amp;! in
<span class="linenos">3212</span>               nlv_T,                                               &amp;! in
<span class="linenos">3213</span>               chanprof,                                            &amp;! in
<span class="linenos">3214</span>               frequencies,                                         &amp;! in
<span class="linenos">3215</span>               tvs_profiles_nl(sensorTovsIndexes(1:profileCount)),  &amp;! in
<span class="linenos">3216</span>               tvs_cld_profiles_nl(sensorTovsIndexes(1:profileCount)), &amp;! in
<span class="linenos">3217</span>               tvs_coefs(sensorId),                                 &amp;! in
<span class="linenos">3218</span>               tvs_coef_scatt(sensorId),                            &amp;! in
<span class="linenos">3219</span>               calcemis,                                            &amp;! in
<span class="linenos">3220</span>               emissivity_local,                                    &amp;! inout
<span class="linenos">3221</span>               radiancedata_d) 
<span class="linenos">3222</span>          if ( .not. beSilent ) write(*,*) &#39;after rttov_scatt...&#39;
<span class="linenos">3223</span>        else
<span class="linenos">3224</span>          if (.not. beSilent) write(*,*) &#39;before rttov_parallel_direct...&#39;, sensorID, profileCount
<span class="linenos">3225</span>          
<span class="linenos">3226</span>          call rttov_parallel_direct(                               &amp;
<span class="linenos">3227</span>               rttov_err_stat,                                      &amp; ! out
<span class="linenos">3228</span>               chanprof,                                            &amp; ! in
<span class="linenos">3229</span>               tvs_opts(sensorId),                                  &amp; ! in
<span class="linenos">3230</span>               tvs_profiles_nl(sensorTovsIndexes(1:profileCount)),  &amp; ! in
<span class="linenos">3231</span>               tvs_coefs(sensorId),                                 &amp; ! in
<span class="linenos">3232</span>               transmission,                                        &amp; ! inout
<span class="linenos">3233</span>               radiancedata_d,                                      &amp; ! inout
<span class="linenos">3234</span>               calcemis=calcemis,                                   &amp; ! in
<span class="linenos">3235</span>               emissivity=emissivity_local,                         &amp; ! inout
<span class="linenos">3236</span>               nthreads=nthreads      )
<span class="linenos">3237</span>          if ( .not. beSilent ) write(*,*) &#39;after rttov_parallel_direct...&#39;
<span class="linenos">3238</span>          
<span class="linenos">3239</span>        end if
<span class="linenos">3240</span>
<span class="linenos">3241</span>      end if ! if (bgckMode .and. tvs_isInstrumHyperSpectral(instrum))
<span class="linenos">3242</span>
<span class="linenos">3243</span>      if ( .not. beSilent ) write(*,*) &#39;Memory Used: &#39;,get_max_rss()/1024,&#39;Mb&#39;     
<span class="linenos">3244</span>
<span class="linenos">3245</span>      if (rttov_err_stat /= 0) then
<span class="linenos">3246</span>        write(*,*) &#39;Error in rttov_parallel_direct&#39;,rttov_err_stat
<span class="linenos">3247</span>        call utl_abort(&#39;tvs_rttov&#39;)
<span class="linenos">3248</span>      end if
<span class="linenos">3249</span>                                        
<span class="linenos">3250</span>      !    2.4  Store hx in the structure tvs_radiance
<span class="linenos">3251</span>
<span class="linenos">3252</span>      do btIndex = 1, btCount
<span class="linenos">3253</span>        profileIndex = chanprof(btIndex)%prof
<span class="linenos">3254</span>        channelIndex = chanprof(btIndex)%chan
<span class="linenos">3255</span>        tovsIndex = sensorTovsIndexes(profileIndex)
<span class="linenos">3256</span>        tvs_radiance(tovsIndex) % bt(channelIndex) = radiancedata_d % bt(btIndex)
<span class="linenos">3257</span>
<span class="linenos">3258</span>        if ( bgckMode ) then
<span class="linenos">3259</span>          if ( .not. associated(tvs_radiance(tovsIndex)  % clear)) then 
<span class="linenos">3260</span>            allocStatus = 0
<span class="linenos">3261</span>            allocate( tvs_radiance(tovsIndex)  % clear  ( tvs_nchan(sensorId)  ), stat= allocStatus(1) )
<span class="linenos">3262</span>            !  allocate overcast black cloud sky radiance output
<span class="linenos">3263</span>            allocate( tvs_radiance(tovsIndex)  % overcast  (nlv_T - 1, tvs_nchan(sensorId) ), stat=allocStatus(2))
<span class="linenos">3264</span>            call utl_checkAllocationStatus(allocStatus(1:2), &#39; tvs_rttov&#39;)
<span class="linenos">3265</span>          end if
<span class="linenos">3266</span>          tvs_radiance(tovsIndex) % clear(channelIndex) =  &amp;
<span class="linenos">3267</span>               radiancedata_d %clear(btIndex)
<span class="linenos">3268</span>          do levelIndex = 1, nlv_T - 1
<span class="linenos">3269</span>            tvs_radiance(tovsIndex) % overcast(levelIndex,channelIndex) =   &amp;
<span class="linenos">3270</span>                 radiancedata_d % overcast(levelIndex,btIndex)
<span class="linenos">3271</span>          end do
<span class="linenos">3272</span>          if (.not. allocated(tvs_transmission)) call tvs_allocTransmission(nlv_T)
<span class="linenos">3273</span>        end if
<span class="linenos">3274</span>
<span class="linenos">3275</span>        if ( allocated( tvs_transmission) ) then
<span class="linenos">3276</span>          do levelIndex = 1, nlv_T
<span class="linenos">3277</span>            tvs_transmission(tovsIndex) % tau_levels(levelIndex,channelIndex) = &amp;
<span class="linenos">3278</span>                 transmission % tau_levels(levelIndex,btIndex)
<span class="linenos">3279</span>          end do
<span class="linenos">3280</span>          
<span class="linenos">3281</span>          tvs_transmission(tovsIndex) % tau_total(channelIndex) = &amp;
<span class="linenos">3282</span>               transmission % tau_total(btIndex)
<span class="linenos">3283</span>        end if
<span class="linenos">3284</span>
<span class="linenos">3285</span>        if ( allocated(tvs_emissivity) ) then
<span class="linenos">3286</span>          tvs_emissivity(channelIndex,tovsIndex) = emissivity_local(btIndex)%emis_out
<span class="linenos">3287</span>        end if
<span class="linenos">3288</span>          
<span class="linenos">3289</span>      end do
<span class="linenos">3290</span>
<span class="linenos">3291</span>      ! Append Surface Emissivity into ObsSpaceData
<span class="linenos">3292</span>      do btIndex = 1, btCount
<span class="linenos">3293</span>        bodyIndex = tvs_bodyIndexFromBtIndex(btIndex)
<span class="linenos">3294</span>        if (bodyIndex &gt; 0) call obs_bodySet_r(obsSpaceData, OBS_SEM, bodyIndex, emissivity_local(btIndex)%emis_out)
<span class="linenos">3295</span>      end do
<span class="linenos">3296</span>
<span class="linenos">3297</span>      !    Deallocate memory
<span class="linenos">3298</span>      asw = 0 ! 0 to deallocate
<span class="linenos">3299</span>      call rttov_alloc_direct(         &amp;
<span class="linenos">3300</span>           allocStatus(1),             &amp;
<span class="linenos">3301</span>           asw,                        &amp;
<span class="linenos">3302</span>           nprofiles=profileCount,     &amp; ! (not used)
<span class="linenos">3303</span>           nchanprof=btCount,          &amp;
<span class="linenos">3304</span>           nlevels=nlv_T,              &amp;
<span class="linenos">3305</span>           chanprof=chanprof,          &amp;
<span class="linenos">3306</span>           opts=tvs_opts(sensorId),    &amp;
<span class="linenos">3307</span>           coefs=tvs_coefs(sensorId),  &amp;
<span class="linenos">3308</span>           transmission=transmission,  &amp;
<span class="linenos">3309</span>           radiance=radiancedata_d,    &amp;
<span class="linenos">3310</span>           calcemis=calcemis,          &amp;
<span class="linenos">3311</span>           emissivity=emissivity_local,&amp;
<span class="linenos">3312</span>           init=.true.)
<span class="linenos">3313</span>
<span class="linenos">3314</span> 
<span class="linenos">3315</span>      if (useUofWIREmiss) then
<span class="linenos">3316</span>        deallocate ( uOfWLandWSurfaceEmissivity  ,stat=allocStatus(2) )
<span class="linenos">3317</span>      end if
<span class="linenos">3318</span>      deallocate ( surfem1    ,stat=allocStatus(3) )
<span class="linenos">3319</span>      if (allocated(frequencies)) deallocate (frequencies, stat=allocStatus(4))
<span class="linenos">3320</span>      call utl_checkAllocationStatus(allocStatus, &#39; tvs_rttov&#39;, .false.)
<span class="linenos">3321</span>      
<span class="linenos">3322</span>    end do sensor_loop
<span class="linenos">3323</span>    
<span class="linenos">3324</span>    deallocate(sensorTovsIndexes)
<span class="linenos">3325</span>
<span class="linenos">3326</span>  end subroutine tvs_rttov
<span class="linenos">3327</span>
<span class="linenos">3328</span>  !--------------------------------------------------------------------------
<span class="linenos">3329</span>  !  tvs_getMWemissivityFromAtlas
<span class="linenos">3330</span>  !--------------------------------------------------------------------------
<span class="linenos">3331</span>  subroutine tvs_getMWemissivityFromAtlas(originalEmissivity, updatedEmissivity, sensorId, chanprof, sensorTovsIndexes)
<span class="linenos">3332</span>    implicit none
<span class="linenos">3333</span>
<span class="linenos">3334</span>    real(8), intent(in)                  :: originalEmissivity(:)
<span class="linenos">3335</span>    type (rttov_emissivity), intent(out) :: updatedEmissivity(:)
<span class="linenos">3336</span>    integer, intent(in)                  :: sensorId
<span class="linenos">3337</span>    type (rttov_chanprof), intent(in)    :: chanprof(:)
<span class="linenos">3338</span>    integer, intent(in)                  :: sensorTovsIndexes(:)
<span class="linenos">3339</span>
<span class="linenos">3340</span>    integer :: returnCode
<span class="linenos">3341</span>    real(8) :: mWAtlasSurfaceEmissivity(size(originalEmissivity))
<span class="linenos">3342</span>    integer :: btCount, profileCount
<span class="linenos">3343</span>    integer :: profileIndex, btIndex, sensorIndex
<span class="linenos">3344</span>    
<span class="linenos">3345</span>    btCount = size( originalEmissivity )
<span class="linenos">3346</span>    if (useMWEmissivityAtlas) then
<span class="linenos">3347</span>
<span class="linenos">3348</span>      if (.not. allocated (tvs_atlas)) allocate(tvs_atlas(tvs_nsensors))
<span class="linenos">3349</span>      if ( .not. tvs_atlas(sensorId)%init) then
<span class="linenos">3350</span>        call rttov_setup_emis_atlas( returnCode, &amp;! out
<span class="linenos">3351</span>             tvs_opts(sensorId),                 &amp;! in
<span class="linenos">3352</span>             tvs_profiles_nl(1)%date(2),         &amp;! in
<span class="linenos">3353</span>             atlas_type_mw,                      &amp;! in
<span class="linenos">3354</span>             tvs_atlas(sensorId),                &amp;! inout
<span class="linenos">3355</span>             atlas_id = mWAtlasId,               &amp;! in ! 1 TELSEM2, 2 CNRM
<span class="linenos">3356</span>             coefs = tvs_coefs(sensorId)  )
<span class="linenos">3357</span>        if (returnCode /= 0) then
<span class="linenos">3358</span>          write(*,*) &#39;Error in rttov_atlas_setup MW&#39;,returnCode
<span class="linenos">3359</span>          call utl_abort(&#39;tvs_getMWemissivityFromAtlas&#39;)
<span class="linenos">3360</span>        end if
<span class="linenos">3361</span>      end if
<span class="linenos">3362</span>   
<span class="linenos">3363</span>      call rttov_get_emis( returnCode,            &amp; ! out
<span class="linenos">3364</span>           tvs_opts(sensorId),                    &amp; ! in
<span class="linenos">3365</span>           chanprof,                              &amp; ! in
<span class="linenos">3366</span>           tvs_profiles_nl(sensorTovsIndexes(:)), &amp; ! in
<span class="linenos">3367</span>           tvs_coefs(sensorId),                   &amp; ! in
<span class="linenos">3368</span>           tvs_atlas(sensorId),                   &amp; ! in
<span class="linenos">3369</span>           mWAtlasSurfaceEmissivity)                ! out
<span class="linenos">3370</span>    
<span class="linenos">3371</span>      if (returnCode /= 0) then
<span class="linenos">3372</span>        write(*,*) &#39;Error in rttov_get_emis MW&#39;, returnCode
<span class="linenos">3373</span>        call utl_abort(&#39;tvs_getMWemissivityFromAtlas&#39;)
<span class="linenos">3374</span>      end if
<span class="linenos">3375</span>
<span class="linenos">3376</span>      profileCount = size( sensorTovsIndexes )
<span class="linenos">3377</span>
<span class="linenos">3378</span>      do profileIndex=1, profileCount !loop on profiles
<span class="linenos">3379</span>        sensorIndex = sensorTovsIndexes(profileIndex)
<span class="linenos">3380</span>  
<span class="linenos">3381</span>        do btIndex=1, btCount !loop on channels
<span class="linenos">3382</span>          if (chanprof(btIndex)%prof==profileIndex) then
<span class="linenos">3383</span>            ! Now we have 0.75 in originalEmissivity(:) for land and sea ice
<span class="linenos">3384</span>            ! and the MW atlas emissivity in mWAtlasSurfaceEmissivity(:)
<span class="linenos">3385</span>
<span class="linenos">3386</span>            if ( tvs_profiles_nl(sensorIndex)% skin % surftype == surftype_land .and. &amp;
<span class="linenos">3387</span>                 mWAtlasSurfaceEmissivity(btIndex) &gt; 0.d0 .and. &amp;
<span class="linenos">3388</span>                 mWAtlasSurfaceEmissivity(btIndex) &lt;= 1.d0 ) then ! check for missing values
<span class="linenos">3389</span>              updatedEmissivity(btIndex)%emis_in = mWAtlasSurfaceEmissivity(btIndex)
<span class="linenos">3390</span>
<span class="linenos">3391</span>            else
<span class="linenos">3392</span>              updatedEmissivity(btIndex)%emis_in = originalEmissivity(btIndex)
<span class="linenos">3393</span>            end if
<span class="linenos">3394</span>            ! Note that emissivity above sea-ice is not modified
<span class="linenos">3395</span>          end if
<span class="linenos">3396</span>        end do
<span class="linenos">3397</span>      end do
<span class="linenos">3398</span>    else
<span class="linenos">3399</span>      updatedEmissivity(:)%emis_in = originalEmissivity(:)
<span class="linenos">3400</span>    end if
<span class="linenos">3401</span>  end subroutine tvs_getMWemissivityFromAtlas
<span class="linenos">3402</span>
<span class="linenos">3403</span>  !--------------------------------------------------------------------------
<span class="linenos">3404</span>  !  comp_ir_emiss
<span class="linenos">3405</span>  !--------------------------------------------------------------------------
<span class="linenos">3406</span>  subroutine comp_ir_emiss (emiss, wind, angle, nchn, np, mchannel)
<span class="linenos">3407</span>    !
<span class="linenos">3408</span>    !:Purpose: Computes water infrared emissivity for a specific set of
<span class="linenos">3409</span>    !           channel indices, wind speed and zenith angle.
<span class="linenos">3410</span>    !
<span class="linenos">3411</span>  
<span class="linenos">3412</span>    implicit none
<span class="linenos">3413</span>
<span class="linenos">3414</span>    !Arguments
<span class="linenos">3415</span>    real(8), intent(out) :: emiss(nchn,np) ! emissivities (0.-1.)
<span class="linenos">3416</span>    real(8), intent(in)  :: wind(np) ! wind: surface wind speed (m/s)
<span class="linenos">3417</span>    real(8), intent(in)  :: angle(np) ! angle: viewing angle (deg)
<span class="linenos">3418</span>    integer, intent(in)  :: nchn ! number of channels to process
<span class="linenos">3419</span>    integer, intent(in)  :: np     !number of locations
<span class="linenos">3420</span>    integer, intent(in)  :: mchannel(nchn) ! vector of channel indices to process
<span class="linenos">3421</span>
<span class="linenos">3422</span>    !Locals
<span class="linenos">3423</span>    integer, parameter :: MaxWn = 19
<span class="linenos">3424</span>    integer, parameter :: Nparm=3
<span class="linenos">3425</span>    integer, parameter :: MaxChan=19
<span class="linenos">3426</span>
<span class="linenos">3427</span>    real (8),parameter :: Theta(Nparm,MaxWn) = (/ &amp;
<span class="linenos">3428</span>         1700.381d0, 25.28534d0, 144.1023d0,      &amp;
<span class="linenos">3429</span>         1738.149d0, 25.67787d0, 146.6139d0,      &amp; 
<span class="linenos">3430</span>         1769.553d0, 26.05250d0, 148.6586d0,      &amp;
<span class="linenos">3431</span>         1778.610d0, 26.12333d0, 149.5127d0,      &amp;
<span class="linenos">3432</span>         1794.245d0, 26.18523d0, 150.5874d0,      &amp;
<span class="linenos">3433</span>         1791.904d0, 26.19991d0, 150.7076d0,      &amp;
<span class="linenos">3434</span>         1806.872d0, 26.37132d0, 151.7191d0,      &amp;
<span class="linenos">3435</span>         1926.078d0, 27.63825d0, 160.7103d0,      &amp;
<span class="linenos">3436</span>         1969.155d0, 28.02767d0, 163.6069d0,      &amp;
<span class="linenos">3437</span>         1975.549d0, 27.86465d0, 164.6228d0,      &amp;
<span class="linenos">3438</span>         1991.288d0, 27.94312d0, 166.2924d0,      &amp;
<span class="linenos">3439</span>         2082.691d0, 28.93558d0, 172.4025d0,      &amp;
<span class="linenos">3440</span>         2182.872d0, 29.89974d0, 179.5839d0,      &amp;
<span class="linenos">3441</span>         2338.510d0, 31.27507d0, 191.2063d0,      &amp;
<span class="linenos">3442</span>         2164.615d0, 28.97152d0, 182.6279d0,      &amp;
<span class="linenos">3443</span>         2099.714d0, 29.91868d0, 178.4015d0,      &amp;
<span class="linenos">3444</span>         1857.644d0, 29.13640d0, 160.9822d0,      &amp;
<span class="linenos">3445</span>         1610.696d0, 26.48602d0, 142.2768d0,      &amp;
<span class="linenos">3446</span>         1503.969d0, 24.97931d0, 133.4392d0 /)
<span class="linenos">3447</span>
<span class="linenos">3448</span>    real (8),parameter ::  C(Nparm,2,MaxWn) = (/                                 &amp;  
<span class="linenos">3449</span>         0.9715104043561414d0,-1.2034233230944147D-06, -5.8742655960993913D-07,  &amp;
<span class="linenos">3450</span>         0.9263932848727608d0,-9.4908630939690859D-04, 2.2831134823358876D-05,   &amp;
<span class="linenos">3451</span>         0.9732503924722753d0,-1.2007007329295099D-06, -5.8767355551283423D-07,  &amp;
<span class="linenos">3452</span>         0.9290947860585505d0,-9.5233413988900161D-04, 2.2640835623043761D-05,   &amp;
<span class="linenos">3453</span>         0.9745005204317289d0, 1.2857517639804244D-06, -7.1356127087301190D-07,  &amp;
<span class="linenos">3454</span>         0.9310852809117095d0,-9.5453509182819095D-04, 2.2562638663187251D-05,   &amp;
<span class="linenos">3455</span>         0.9756204829761132d0, 1.2979181109743976D-06, -7.1406809362820139D-07,  &amp;
<span class="linenos">3456</span>         0.9329073568177888d0,-9.5627536945214183D-04, 2.2442358508999558D-05,   &amp;
<span class="linenos">3457</span>         0.9764012672766408d0,-2.0826654381361387D-06, -4.9103920569405721D-07,  &amp;
<span class="linenos">3458</span>         0.9341937281933334d0,-9.5764423928102976D-04, 2.2326701573603621D-05,   &amp;
<span class="linenos">3459</span>         0.9770513558720460d0, 4.1867599593267133D-07, -6.1768073971231931D-07,  &amp;
<span class="linenos">3460</span>         0.9352981872014672d0,-9.5833614545300181D-04, 2.2261996883974513D-05,   &amp;
<span class="linenos">3461</span>         0.9775970810179080d0,-1.2289690625562906D-06, -5.2953762169985775D-07,  &amp;
<span class="linenos">3462</span>         0.9362188153954743d0,-9.5950872922696905D-04, 2.2251301675423482D-05,   &amp;
<span class="linenos">3463</span>         0.9830610391451819d0, 2.7693589475690676D-07, -5.1580217018207558D-07,  &amp;
<span class="linenos">3464</span>         0.9461121192685766d0,-9.5718115604053031D-04, 2.1087308573177295D-05,   &amp;
<span class="linenos">3465</span>         0.9840097930773377d0,-1.4987900189155091D-06, -3.8281408128977038D-07,  &amp;
<span class="linenos">3466</span>         0.9479758694804105d0,-9.5451252460440695D-04, 2.0800627740862229D-05,   &amp;
<span class="linenos">3467</span>         0.9851056150728580d0,-6.5768237152417477D-07, -4.2053769829400935D-07,  &amp;
<span class="linenos">3468</span>         0.9502084544618980d0,-9.4965534997704157D-04,  2.0326602209199427D-05,  &amp;
<span class="linenos">3469</span>         0.9862706396188835d0,-2.3713068057993353D-06, -2.8671134918457728D-07,  &amp;
<span class="linenos">3470</span>         0.9526580467595886d0,-9.4614505430749598D-04,  2.0001856872595840D-05,  &amp;
<span class="linenos">3471</span>         0.9875307221489201d0, 1.3003462826947714D-07, -4.1335288320283954D-07,  &amp;
<span class="linenos">3472</span>         0.9554195617948236d0,-9.3806678196435643D-04,  1.9407754748128057D-05,  &amp;
<span class="linenos">3473</span>         0.9891153260567763d0,-8.0730206675976713D-07, -3.1811320626834656D-07,  &amp;
<span class="linenos">3474</span>         0.9590558393678170d0,-9.2716287670223167D-04, 1.8690586764925213D-05,   &amp;
<span class="linenos">3475</span>         0.9913304557147524d0,-2.1153391229093421D-08, -3.1094269595901165D-07,  &amp;
<span class="linenos">3476</span>         0.9644162604969492d0,-9.0342753739935612D-04, 1.7274993357160937D-05,   &amp;
<span class="linenos">3477</span>         0.9925188366950193d0,-4.6365959315123653D-07, -2.7020120347068712D-07,  &amp;
<span class="linenos">3478</span>         0.9667877170960085d0,-9.0665804037922043D-04, 1.7083616616646458D-05,   &amp;
<span class="linenos">3479</span>         0.9919408379810360d0,-2.0563508815953840D-06, -1.8066722718403761D-07,  &amp;
<span class="linenos">3480</span>         0.9627535343397309d0,-9.7537134133678965D-04,  1.9698263973541952D-05,  &amp;
<span class="linenos">3481</span>         0.9889406296815972d0,-2.3713068057993353D-06, -2.8671134918457728D-07,  &amp;
<span class="linenos">3482</span>         0.9506051906192242d0,-1.0642902225813857D-03,  2.4235485973033298D-05,  &amp;
<span class="linenos">3483</span>         0.9828819693848310d0,-7.4086701870172759D-07, -6.2949258820534062D-07,  &amp;
<span class="linenos">3484</span>         0.9329616683158125d0,-1.0728027288012200D-03, 2.7209071863380586D-05,   &amp;
<span class="linenos">3485</span>         0.9767410313266288d0,-9.1750038410238915D-07, -7.9177921107781349D-07,  &amp;
<span class="linenos">3486</span>         0.9192775350344998d0,-1.0369254272157462D-03, 2.8000594542037504D-05 /)
<span class="linenos">3487</span>
<span class="linenos">3488</span>    real (8) a(MaxChan),b(MaxChan),cc(MaxChan)  ! local variable
<span class="linenos">3489</span>    real (8) ww
<span class="linenos">3490</span>    integer Index,Ichan,IP
<span class="linenos">3491</span>
<span class="linenos">3492</span>
<span class="linenos">3493</span>    do Ichan = 1 , Nchn
<span class="linenos">3494</span>
<span class="linenos">3495</span>      Index = Mchannel(Ichan)
<span class="linenos">3496</span>
<span class="linenos">3497</span>      do IP=1,NP
<span class="linenos">3498</span>
<span class="linenos">3499</span>        ww = wind(IP)
<span class="linenos">3500</span>        a(Ichan) = c(1,1,Index) + c(2,1,Index) * ww    &amp;  
<span class="linenos">3501</span>             + c(3,1,Index) * ww * ww
<span class="linenos">3502</span>        b(Ichan) = c(1,2,Index) + c(2,2,Index) * ww    &amp;
<span class="linenos">3503</span>             + c(3,2,Index)* ww * ww
<span class="linenos">3504</span>
<span class="linenos">3505</span>        cc(Ichan) = Theta(1,Index) + Theta(2,Index) * ww
<span class="linenos">3506</span>
<span class="linenos">3507</span>        emiss(Ichan,IP) = a(Ichan) + (b(Ichan) - a(Ichan)) *   &amp; 
<span class="linenos">3508</span>             exp(( (theta(3,Index) - 60.d0)**2.d0              &amp;
<span class="linenos">3509</span>             - (angle(IP) - theta(3,Index))**2.d0 ) / CC(Ichan))
<span class="linenos">3510</span>       
<span class="linenos">3511</span>      end do
<span class="linenos">3512</span>      
<span class="linenos">3513</span>    end do
<span class="linenos">3514</span>
<span class="linenos">3515</span>  end subroutine comp_ir_emiss
<span class="linenos">3516</span>
<span class="linenos">3517</span>  !--------------------------------------------------------------------------
<span class="linenos">3518</span>  !  pcnt_box
<span class="linenos">3519</span>  !--------------------------------------------------------------------------
<span class="linenos">3520</span>  subroutine pcnt_box(f_low, f_high, nprf, ilat, ilon, klat, klon, ireduc)
<span class="linenos">3521</span>    !
<span class="linenos">3522</span>    !:Purpose: Computes a low resolution feature form a high
<span class="linenos">3523</span>    !           resolution one by averaging.
<span class="linenos">3524</span>    !           example: use for percentage of water
<span class="linenos">3525</span>    implicit none
<span class="linenos">3526</span>
<span class="linenos">3527</span>    ! Arguments:
<span class="linenos">3528</span>    real(8), intent(out)  :: f_low(nprf)       ! Low resolution field
<span class="linenos">3529</span>    real(8), intent(in)   :: f_high(klon, klat)! High resolution field 
<span class="linenos">3530</span>    integer, intent(in)   :: nprf              ! Number of profiles
<span class="linenos">3531</span>    integer, intent(in)   :: ilat(nprf)        ! Y-coordinate of profile
<span class="linenos">3532</span>    integer, intent(in)   :: ilon(nprf)        ! X-coordinate of profile
<span class="linenos">3533</span>    integer, intent(in)   :: klon              ! Max value of latitude indices
<span class="linenos">3534</span>    integer, intent(in)   :: klat              ! Max value of longitude indices
<span class="linenos">3535</span>    integer, intent(in)   :: ireduc            ! Means a 2xireduc+1 by 2xireduc+1 averaging
<span class="linenos">3536</span>
<span class="linenos">3537</span>    ! Locals
<span class="linenos">3538</span>    integer :: nplon, jdlo1, jdlo2, jlon1, jlon2
<span class="linenos">3539</span>    integer :: nx, ilat1, ilat2, ilon1, ilon2, jn, ii, jj
<span class="linenos">3540</span>   
<span class="linenos">3541</span>    profiles : do jn = 1,nprf
<span class="linenos">3542</span>
<span class="linenos">3543</span>      nplon = 0
<span class="linenos">3544</span>
<span class="linenos">3545</span>      ! normal limits
<span class="linenos">3546</span>
<span class="linenos">3547</span>      ilat1=max(ilat(jn)-ireduc,1)
<span class="linenos">3548</span>      ilat2=min(ilat(jn)+ireduc,klat)
<span class="linenos">3549</span>      ilon1=max(ilon(jn)-ireduc,1)
<span class="linenos">3550</span>      ilon2=min(ilon(jn)+ireduc,klon)
<span class="linenos">3551</span>
<span class="linenos">3552</span>      if (ilon1 == 1 .or. ilon2 == klon) then
<span class="linenos">3553</span>        ! border cases for longitudes
<span class="linenos">3554</span>        jdlo1 = ilon(jn)-ireduc
<span class="linenos">3555</span>        jdlo2 = ilon(jn)+ireduc
<span class="linenos">3556</span>
<span class="linenos">3557</span>        if ( jdlo1 &lt;= 0 ) then
<span class="linenos">3558</span>          nplon = 1
<span class="linenos">3559</span>          jlon1 = klon + jdlo1
<span class="linenos">3560</span>          jlon2 = klon
<span class="linenos">3561</span>        else if ( jdlo2 &gt; klon ) then
<span class="linenos">3562</span>          nplon = 1
<span class="linenos">3563</span>          jlon1 = 1
<span class="linenos">3564</span>          jlon2 = jdlo2 - klon
<span class="linenos">3565</span>        end if
<span class="linenos">3566</span>      end if
<span class="linenos">3567</span>
<span class="linenos">3568</span>      nx = 0
<span class="linenos">3569</span>      f_low(jn) = 0.d0
<span class="linenos">3570</span>     
<span class="linenos">3571</span>      do jj = ilat1, ilat2
<span class="linenos">3572</span>
<span class="linenos">3573</span>        do ii = ilon1, ilon2
<span class="linenos">3574</span>          nx = nx + 1
<span class="linenos">3575</span>          f_low(jn) = f_low(jn) + f_high(ii,jj)         
<span class="linenos">3576</span>        end do
<span class="linenos">3577</span>        
<span class="linenos">3578</span>        if (nplon == 1) then
<span class="linenos">3579</span>          ! additional cases at border 1-klon
<span class="linenos">3580</span>          do ii = jlon1, jlon2
<span class="linenos">3581</span>            nx = nx + 1
<span class="linenos">3582</span>            f_low(jn) = f_low(jn) + f_high(ii,jj)         
<span class="linenos">3583</span>          end do
<span class="linenos">3584</span>        end if
<span class="linenos">3585</span>
<span class="linenos">3586</span>      end do
<span class="linenos">3587</span>      
<span class="linenos">3588</span>      f_low(jn) = f_low(jn) / dble(nx)
<span class="linenos">3589</span>
<span class="linenos">3590</span>    end do profiles
<span class="linenos">3591</span>
<span class="linenos">3592</span>  end subroutine pcnt_box
<span class="linenos">3593</span>
<span class="linenos">3594</span>  !--------------------------------------------------------------------------
<span class="linenos">3595</span>  !  emis_read_climatology
<span class="linenos">3596</span>  !--------------------------------------------------------------------------
<span class="linenos">3597</span>  subroutine emis_read_climatology
<span class="linenos">3598</span>    !
<span class="linenos">3599</span>    !:Purpose: Read information about ceres surface type and water fraction.
<span class="linenos">3600</span>    !
<span class="linenos">3601</span>    !:Arguments:
<span class="linenos">3602</span>    !        :none:
<span class="linenos">3603</span>    !
<span class="linenos">3604</span>    implicit none
<span class="linenos">3605</span>    
<span class="linenos">3606</span>    ! Locals:
<span class="linenos">3607</span>    integer            :: nisf,njsf,nksf
<span class="linenos">3608</span>    integer            :: niwa,njwa,nkwa
<span class="linenos">3609</span>    character(len=20)  :: ceresFile
<span class="linenos">3610</span>    integer, external  :: fnom,fstouv,fstfrm,fclos,fstlir
<span class="linenos">3611</span>    integer            :: isftest
<span class="linenos">3612</span>    integer            :: iv1,iv2,iv3,iv4,iv5,iv6
<span class="linenos">3613</span>
<span class="linenos">3614</span>    isftest = 0
<span class="linenos">3615</span>
<span class="linenos">3616</span>    !* get surface type and water fraction
<span class="linenos">3617</span>    ceresFile = &#39;ceres_global.std&#39;
<span class="linenos">3618</span>    iv1 = fnom(isftest,ceresFile,&#39;RND+R/O&#39;,0)
<span class="linenos">3619</span>    iv2 = fstouv(isftest,&#39;RND&#39;)
<span class="linenos">3620</span>    iv3 = fstlir(surfaceType,isftest,nisf,njsf,nksf,-1,&#39;SFC-TYPE&#39;,-1,-1,-1,&#39;&#39;,&#39;TY&#39;)
<span class="linenos">3621</span>    iv4 = utl_fstlir(waterFraction,isftest,niwa,njwa,nkwa,-1,&#39;WATER_FR&#39;,-1,-1,-1,&#39;&#39;,&#39;W%&#39;)
<span class="linenos">3622</span>    iv5 = fstfrm(isftest)
<span class="linenos">3623</span>    iv6 = fclos(isftest)
<span class="linenos">3624</span>
<span class="linenos">3625</span>    if (iv1 &lt; 0 .or. iv2 &lt; 0 .or. iv3 &lt; 0 .or. iv4 &lt; 0 .or. iv5 &lt; 0 .or. iv6 &lt; 0) then
<span class="linenos">3626</span>      write(*,*) &#39;LES iv DE CERES &#39;,iv1,iv2,iv3,iv4,iv5,iv6
<span class="linenos">3627</span>      write(*,*) &#39;THESE NUMBER SHOULD NOT BE NEGATIVE WHEN DOING AIRS BACKGROUND CHECK&#39;
<span class="linenos">3628</span>      call utl_abort(&#39;Problem with file ceres_global.std in emis_read_climatology &#39;)
<span class="linenos">3629</span>    end if
<span class="linenos">3630</span>   
<span class="linenos">3631</span>  end subroutine emis_read_climatology
<span class="linenos">3632</span>
<span class="linenos">3633</span>  !--------------------------------------------------------------------------
<span class="linenos">3634</span>  !  emis_getIrEmissivity
<span class="linenos">3635</span>  !--------------------------------------------------------------------------
<span class="linenos">3636</span>  subroutine emis_getIrEmissivity (surfem1, nchn, sensorIndex, nprf, nchannels_max, sensorTovsIndexes)
<span class="linenos">3637</span>    !
<span class="linenos">3638</span>    !:Purpose: Assign new ir surface emissivities based on
<span class="linenos">3639</span>    !           cmc analysis surface albedo, sea ice fraction and snow mask
<span class="linenos">3640</span>    !           in addition to ceres surface type and water fraction. 
<span class="linenos">3641</span>    !           This is a subroutine that can apply to any instrument.
<span class="linenos">3642</span>    !
<span class="linenos">3643</span>    implicit none
<span class="linenos">3644</span>   
<span class="linenos">3645</span>    ! Arguments:
<span class="linenos">3646</span>    real(8), intent(out) :: surfem1(nchannels_max) ! IR surface emissivity estimate (0-1)
<span class="linenos">3647</span>    integer, intent(in)  :: nchn                   ! Number of channels
<span class="linenos">3648</span>    integer, intent(in)  :: sensorindex            ! Sensor number
<span class="linenos">3649</span>    integer, intent(in)  :: nprf                   ! Number of profiles
<span class="linenos">3650</span>    integer, intent(in)  :: nchannels_max          ! Total number of observations treated
<span class="linenos">3651</span>    integer, intent(in)  :: sensorTovsIndexes( nprf )         ! Profile position number
<span class="linenos">3652</span>
<span class="linenos">3653</span>    !Locals:
<span class="linenos">3654</span>    integer :: jc,jn
<span class="linenos">3655</span>    integer :: ilat(nprf), ilon(nprf)
<span class="linenos">3656</span>    real(8) :: latitudes(nprf), longitudes(nprf), satzang(nprf)
<span class="linenos">3657</span>    real(8) :: wind_sfc(nprf), f_low(nprf), waven(nchn), em_oc(nchn,nprf), emi_mat(nchn,20)
<span class="linenos">3658</span>
<span class="linenos">3659</span>
<span class="linenos">3660</span>    ! Information to extract (transvidage)
<span class="linenos">3661</span>    ! latitudes(nprf) -- latitude (-90 to 90)
<span class="linenos">3662</span>    ! longitudes(nprf) -- longitude (0 to 360)
<span class="linenos">3663</span>    ! satzang(nprf) -- satellite zenith angle (deg)
<span class="linenos">3664</span>
<span class="linenos">3665</span>    do jn = 1, nprf
<span class="linenos">3666</span>      latitudes(jn)  = tvs_profiles_nl(sensorTovsIndexes(jn)) % latitude
<span class="linenos">3667</span>      longitudes(jn) = tvs_profiles_nl(sensorTovsIndexes(jn)) % longitude
<span class="linenos">3668</span>      satzang(jn)    = tvs_profiles_nl(sensorTovsIndexes(jn)) % zenangle
<span class="linenos">3669</span>    end do
<span class="linenos">3670</span>
<span class="linenos">3671</span>    !  Assign surface properties from grid to profiles
<span class="linenos">3672</span>    call interp_sfc(ilat,ilon, nprf,latitudes,longitudes,sensorTovsIndexes)
<span class="linenos">3673</span>
<span class="linenos">3674</span>
<span class="linenos">3675</span>    !  Find the sensor bands (central) wavenumbers
<span class="linenos">3676</span>    do jc = 1, nchn      
<span class="linenos">3677</span>      waven(jc) = tvs_coefs(sensorIndex) % coef % ff_cwn(jc)
<span class="linenos">3678</span>    end do
<span class="linenos">3679</span>
<span class="linenos">3680</span>
<span class="linenos">3681</span>    !  Get the CERES emissivity matrix for all sensor wavenumbers and surface types
<span class="linenos">3682</span>    call ceres_ematrix(emi_mat, waven,nchn)
<span class="linenos">3683</span>
<span class="linenos">3684</span>
<span class="linenos">3685</span>    ! Refine water emissivities
<span class="linenos">3686</span>
<span class="linenos">3687</span>    do jn = 1, nprf
<span class="linenos">3688</span>      !       find surface wind
<span class="linenos">3689</span>      wind_sfc(jn) = min(sqrt(tvs_profiles_nl(sensorTovsIndexes(jn)) % s2m %u**2 + tvs_profiles_nl(sensorTovsIndexes(jn)) % s2m % v**2 + 1.d-12),15.d0)
<span class="linenos">3690</span>    end do
<span class="linenos">3691</span>
<span class="linenos">3692</span>    !     find new ocean emissivities     
<span class="linenos">3693</span>
<span class="linenos">3694</span>    do jc = 1, nchn
<span class="linenos">3695</span>      em_oc(jc,:)= emi_mat(jc,17)
<span class="linenos">3696</span>    end do
<span class="linenos">3697</span>    
<span class="linenos">3698</span>    call emi_sea (em_oc, waven,satzang,wind_sfc,nprf,nchn)
<span class="linenos">3699</span>    
<span class="linenos">3700</span>
<span class="linenos">3701</span>    ! Get surface emissivities
<span class="linenos">3702</span>
<span class="linenos">3703</span>    do jn = 1, nprf
<span class="linenos">3704</span>      !       set albedo to 0.6 where snow is present
<span class="linenos">3705</span>      if ( tvs_profiles_nl(sensorTovsIndexes(jn)) % skin % surftype == surftype_land .and. tvs_surfaceParameters(sensorTovsIndexes(jn)) % snow &gt; 0.999 ) tvs_surfaceParameters(sensorTovsIndexes(jn)) % albedo = 0.6
<span class="linenos">3706</span>      !       if albedo too high no water
<span class="linenos">3707</span>      if ( tvs_surfaceParameters(sensorTovsIndexes(jn)) % albedo &gt;= 0.55 ) tvs_surfaceParameters(sensorTovsIndexes(jn)) % pcnt_wat = 0.
<span class="linenos">3708</span>      !       if water and CMC ice present then sea ice
<span class="linenos">3709</span>      if ( tvs_profiles_nl(sensorTovsIndexes(jn)) % skin % surftype == surftype_sea .and. tvs_surfaceParameters(sensorTovsIndexes(jn)) % ice &gt; 0.001 ) tvs_surfaceParameters(sensorTovsIndexes(jn)) % ltype = 20
<span class="linenos">3710</span>      !       if land and CMC snow present then snow
<span class="linenos">3711</span>      if ( tvs_profiles_nl(sensorTovsIndexes(jn)) % skin % surftype == surftype_land .and. tvs_surfaceParameters(sensorTovsIndexes(jn)) % snow &gt; 0.999 ) tvs_surfaceParameters(sensorTovsIndexes(jn)) % ltype = 15
<span class="linenos">3712</span>      do jc=1,nchn
<span class="linenos">3713</span>        surfem1((jn-1)*nchn+jc) =  tvs_surfaceParameters(sensorTovsIndexes(jn)) % pcnt_wat * em_oc(jc,jn)  +   &amp;
<span class="linenos">3714</span>             ( 1.d0 - tvs_surfaceParameters(sensorTovsIndexes(jn)) % pcnt_wat ) * emi_mat(jc,tvs_surfaceParameters(sensorTovsIndexes(jn)) % ltype)
<span class="linenos">3715</span>      end do
<span class="linenos">3716</span>    end do
<span class="linenos">3717</span>
<span class="linenos">3718</span>    ! Find the regional water fraction (here in a 15x15 pixel box centered on profile)
<span class="linenos">3719</span>    call pcnt_box (f_low, waterFraction,nprf,ilat,ilon,kslat,kslon,7)
<span class="linenos">3720</span>
<span class="linenos">3721</span>    do jn = 1, nprf
<span class="linenos">3722</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % pcnt_reg = f_low(jn)
<span class="linenos">3723</span>    end do
<span class="linenos">3724</span>
<span class="linenos">3725</span>  end subroutine emis_getIrEmissivity
<span class="linenos">3726</span>
<span class="linenos">3727</span>  !--------------------------------------------------------------------------
<span class="linenos">3728</span>  !  interp_sfc
<span class="linenos">3729</span>  !--------------------------------------------------------------------------
<span class="linenos">3730</span>  subroutine interp_sfc (ilat, ilon, nprf, latitudes, longitudes, sensorTovsIndexes)
<span class="linenos">3731</span>    !
<span class="linenos">3732</span>    !:Purpose: Associate surface albedo, ice fraction, snow depth 
<span class="linenos">3733</span>    !           and ceres surface type and water fraction to observations profiles.
<span class="linenos">3734</span>
<span class="linenos">3735</span>    implicit none
<span class="linenos">3736</span>
<span class="linenos">3737</span>    ! Arguments
<span class="linenos">3738</span>    integer, intent(out) :: ilat(nprf)   ! y-coordinate of profile
<span class="linenos">3739</span>    integer, intent(out) :: ilon(nprf)   ! x-coordinate of profile 
<span class="linenos">3740</span>    integer, intent(in)  :: nprf         ! number of profiles
<span class="linenos">3741</span>    real(8), intent(in)  :: latitudes(nprf)   ! latitude (-90s to 90n)
<span class="linenos">3742</span>    real(8), intent(in)  :: longitudes(nprf)   ! longitude (0 to 360)
<span class="linenos">3743</span>    integer, intent(in)  :: sensorTovsIndexes(nprf) ! observation index
<span class="linenos">3744</span>
<span class="linenos">3745</span>    ! Locals:
<span class="linenos">3746</span>    character(len=20)  :: cfile3,cfile5
<span class="linenos">3747</span>    integer            :: iun3,iun5
<span class="linenos">3748</span>    integer            ::                        iv7
<span class="linenos">3749</span>    integer            :: ix1,ix2,ix3,ix4,ix5,        ix8,ix9,ix10,ix11,ix12
<span class="linenos">3750</span>    integer            ::         iy3,iy4,iy5,        iy8,iy9,iy10
<span class="linenos">3751</span>    integer            :: iz1,iz2,iz3,iz4,iz5,        iz8,iz9,iz10,iz11,iz12
<span class="linenos">3752</span>    integer            :: ni3,nj3,nk3
<span class="linenos">3753</span>    integer            :: ni4,nj4,nk4
<span class="linenos">3754</span>    integer            :: ni5,nj5,nk5
<span class="linenos">3755</span>    integer            :: dateo,deet,npas,nbits,datyp
<span class="linenos">3756</span>    integer            :: ip1,ip2,ip3
<span class="linenos">3757</span>    integer            :: ig13,ig23,ig33,ig43
<span class="linenos">3758</span>    integer            :: ig14,ig24,ig34,ig44
<span class="linenos">3759</span>    integer            :: ig15,ig25,ig35,ig45
<span class="linenos">3760</span>    integer            :: swa,lng,dltf,ubc,ex1,ex2,ex3
<span class="linenos">3761</span>    integer            :: jn
<span class="linenos">3762</span>    character(len=1)   :: typvar
<span class="linenos">3763</span>    character(len=1)   :: grtyp3,grtyp4,grtyp5
<span class="linenos">3764</span>    character(len=2)   :: nomvar, snowvar
<span class="linenos">3765</span>    character(len=8)   :: etiket
<span class="linenos">3766</span>    integer, external  :: fnom,fstouv,fstinf,fstprm,fstfrm,fclos
<span class="linenos">3767</span>    integer, external  :: ezqkdef,ezdefset
<span class="linenos">3768</span>    real(8)            :: zig1,zig2,zig3,zig4
<span class="linenos">3769</span>    integer            :: ig1obs,ig2obs,ig3obs,ig4obs
<span class="linenos">3770</span>    real (8)           :: alat, alon, zzlat, zzlon
<span class="linenos">3771</span>    ! fields on input grid
<span class="linenos">3772</span>    real(8), allocatable :: glace(:,:), neige(:,:), alb(:,:)
<span class="linenos">3773</span>    ! fields on output grid
<span class="linenos">3774</span>    real(8)              :: glace_intrpl(nprf,1), neige_intrpl(nprf,1), alb_intrpl(nprf,1)
<span class="linenos">3775</span>
<span class="linenos">3776</span>
<span class="linenos">3777</span>    ! printout header
<span class="linenos">3778</span>    write(*,*) 
<span class="linenos">3779</span>    write(*,*) &#39;SUBROUTINE interp_sfc&#39;
<span class="linenos">3780</span>    write(*,*) &#39;---------------------&#39;
<span class="linenos">3781</span>    write(*,*) &#39; called multiple time by bunch of &#39;,nprf,&#39; profiles&#39;
<span class="linenos">3782</span>    write(*,*) &#39; &lt;RETURN CODES&gt; SHOULD NOT BE NEGATIVE&#39;
<span class="linenos">3783</span>    write(*,*) &#39;---------------------------------------------------&#39;
<span class="linenos">3784</span>
<span class="linenos">3785</span>
<span class="linenos">3786</span>    ! --- FOR CERES VARIABLES -------------
<span class="linenos">3787</span>    !  Get number of pixels per degree of lat or lon
<span class="linenos">3788</span>
<span class="linenos">3789</span>    alat = dble(kslat)/180.d0
<span class="linenos">3790</span>    alon = dble(kslon)/360.d0
<span class="linenos">3791</span>
<span class="linenos">3792</span>    do jn=1, nprf
<span class="linenos">3793</span>
<span class="linenos">3794</span>      ! get lat and lon within limits if necessary
<span class="linenos">3795</span>      zzlat = min(latitudes(jn),89.999d0)
<span class="linenos">3796</span>      zzlat = max(Zzlat,-89.999d0)
<span class="linenos">3797</span>      
<span class="linenos">3798</span>      zzlon = min(longitudes(jn),359.999d0)
<span class="linenos">3799</span>      zzlon = max(zzlon,0.d0)
<span class="linenos">3800</span>
<span class="linenos">3801</span>      !  Find in which surface field pixel is located the observation profile
<span class="linenos">3802</span>
<span class="linenos">3803</span>      ! Note : CERES grid at 1/6 resolution 
<span class="linenos">3804</span>      !         N-S : starts at N pole and excludes S pole
<span class="linenos">3805</span>      !         W-E : starts at longitude 0 and excludes longitude 360
<span class="linenos">3806</span>
<span class="linenos">3807</span>      ilat(jn) = max( nint((zzlat + 90.d0) * alat),1) 
<span class="linenos">3808</span>      ilon(jn) = nint(zzlon * alon) + 1
<span class="linenos">3809</span>      if (ilon(jn) &gt; kslon) ilon(jn) = 1
<span class="linenos">3810</span>
<span class="linenos">3811</span>      !  Assign surface caracteristics to observation profiles
<span class="linenos">3812</span>
<span class="linenos">3813</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % ltype    = surfaceType(ilon(jn),ilat(jn))
<span class="linenos">3814</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % pcnt_wat = waterFraction(ilon(jn),ilat(jn))
<span class="linenos">3815</span>
<span class="linenos">3816</span>    end do
<span class="linenos">3817</span>
<span class="linenos">3818</span>    !  For ice, snow and albedo variables -------------
<span class="linenos">3819</span>
<span class="linenos">3820</span>    iun3 = 0
<span class="linenos">3821</span>    iun5 = 0
<span class="linenos">3822</span>
<span class="linenos">3823</span>    ! File names
<span class="linenos">3824</span>    cfile3 = &#39;sfc4airs&#39;          ! for ice fraction and snow cover
<span class="linenos">3825</span>    cfile5 = &#39;sfc4airs_newalb&#39;   ! for albedo
<span class="linenos">3826</span>
<span class="linenos">3827</span>
<span class="linenos">3828</span>    ! fnom: make the connections with the external files name
<span class="linenos">3829</span>    ! success = 0
<span class="linenos">3830</span>    write(*,*) 
<span class="linenos">3831</span>    ix1 = fnom(iun3,cfile3,&#39;RND+R/O&#39;,0)
<span class="linenos">3832</span>    write(*,*) &#39;file = sfc4airs         : fnom   : return = &#39;, ix1
<span class="linenos">3833</span>
<span class="linenos">3834</span>    iz1 = fnom(iun5,cfile5,&#39;RND+R/O&#39;,0)
<span class="linenos">3835</span>    write(*,*) &#39;file = sfc4airs_newalb  : fnom   : return = &#39;, iz1
<span class="linenos">3836</span>
<span class="linenos">3837</span>
<span class="linenos">3838</span>    ! fstouv: open the standard files
<span class="linenos">3839</span>    ! success = number of records found in the file
<span class="linenos">3840</span>    write(*,*) 
<span class="linenos">3841</span>    ix2 = fstouv(iun3,&#39;RND&#39;)
<span class="linenos">3842</span>    write(*,*) &#39;file = sfc4airs         : fstouv : return = &#39;, ix2
<span class="linenos">3843</span>    iz2 = fstouv(iun5,&#39;RND&#39;)
<span class="linenos">3844</span>    write(*,*) &#39;file = sfc4airs_newalb  : fstouv : return = &#39;, iz2
<span class="linenos">3845</span>
<span class="linenos">3846</span>
<span class="linenos">3847</span>    ! fstinf: locate the records that matches the search keys
<span class="linenos">3848</span>    ! success = handle of the record found after the search
<span class="linenos">3849</span>    ! desired output = handle
<span class="linenos">3850</span>    write(*,*) 
<span class="linenos">3851</span>    ix3 = fstinf(iun3,ni3,nj3,nk3,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,&#39;LG&#39;)
<span class="linenos">3852</span>    write(*,*) &#39;variable = LG           : fstinf : return = &#39;, ix3
<span class="linenos">3853</span>
<span class="linenos">3854</span>    snowvar=&#39;SD&#39;
<span class="linenos">3855</span>    iy3 = fstinf(iun3,ni4,nj4,nk4,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,snowvar)
<span class="linenos">3856</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : fstinf : return = &#39;, iy3
<span class="linenos">3857</span>    if ( iy3  &lt;  0 ) then
<span class="linenos">3858</span>      write(*,*) &#39;did not find &#39;&#39;SD&#39;&#39; so look for &#39;&#39;NE&#39;&#39;&#39;
<span class="linenos">3859</span>      snowvar=&#39;NE&#39;
<span class="linenos">3860</span>      iy3 = fstinf(iun3,ni4,nj4,nk4,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,snowvar)
<span class="linenos">3861</span>      write(*,*) &#39;variable = &#39;, snowvar, &#39;           : fstinf : return = &#39;, iy3
<span class="linenos">3862</span>    end if
<span class="linenos">3863</span>
<span class="linenos">3864</span>    iz3 = fstinf(iun5,ni5,nj5,nk5,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,&#39;AL&#39;)
<span class="linenos">3865</span>    write(*,*) &#39;variable = AL           : fstinf : return = &#39;, iz3
<span class="linenos">3866</span>
<span class="linenos">3867</span>
<span class="linenos">3868</span>    ! fstprm: get the description informations of the record given the key
<span class="linenos">3869</span>    ! success = 0
<span class="linenos">3870</span>    ! desired output = nix,njx,grtypx,igxx,ig1x,ig2x,ig3x,ig4x
<span class="linenos">3871</span>
<span class="linenos">3872</span>    write(*,*) 
<span class="linenos">3873</span>    ix4 = fstprm(ix3, dateo,deet,npas,ni3,nj3,nk3,nbits,datyp, &amp;
<span class="linenos">3874</span>         ip1,ip2,ip3,typvar,nomvar,etiket,grtyp3,  &amp;
<span class="linenos">3875</span>         ig13,ig23,ig33,ig43,swa,lng,dltf,ubc,ex1,ex2,ex3)
<span class="linenos">3876</span>    write(*,*) &#39;variable = LG           : fstprm : return = &#39;, ix4
<span class="linenos">3877</span>
<span class="linenos">3878</span>    iy4 = fstprm(iy3, dateo,deet,npas,ni4,nj4,nk4,nbits,datyp, &amp;
<span class="linenos">3879</span>         ip1,ip2,ip3,typvar,nomvar,etiket,grtyp4,  &amp;
<span class="linenos">3880</span>         ig14,ig24,ig34,ig44,swa,lng,dltf,ubc,ex1,ex2,ex3)
<span class="linenos">3881</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : fstprm : return = &#39;, iy4
<span class="linenos">3882</span>
<span class="linenos">3883</span>    iz4 = fstprm(iz3, dateo,deet,npas,ni5,nj5,nk5,nbits,datyp, &amp;
<span class="linenos">3884</span>         ip1,ip2,ip3,typvar,nomvar,etiket,grtyp5,  &amp;
<span class="linenos">3885</span>         ig15,ig25,ig35,ig45,swa,lng,dltf,ubc,ex1,ex2,ex3)
<span class="linenos">3886</span>    write(*,*) &#39;variable = AL           : fstprm : return = &#39;, iz4
<span class="linenos">3887</span>
<span class="linenos">3888</span>
<span class="linenos">3889</span>    ! allocation of the field on the grid
<span class="linenos">3890</span>    allocate ( glace  (ni3,nj3) )
<span class="linenos">3891</span>    allocate ( neige  (ni4,nj4) )
<span class="linenos">3892</span>    allocate ( alb    (ni5,nj5) )
<span class="linenos">3893</span>
<span class="linenos">3894</span>
<span class="linenos">3895</span>    ! utl_fstlir: read records data (field on the grid) given the key
<span class="linenos">3896</span>    ! success = handle of the record
<span class="linenos">3897</span>    ! desired output = FIELD
<span class="linenos">3898</span>    write(*,*) 
<span class="linenos">3899</span>
<span class="linenos">3900</span>    ix5 = utl_fstlir(glace, iun3,ni3,nj3,nk3,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,&#39;LG&#39;)
<span class="linenos">3901</span>    write(*,*) &#39;variable = LG           : utl_fstlir : return = &#39;, ix5
<span class="linenos">3902</span>    iy5 = utl_fstlir(neige, iun3,ni4,nj4,nk4,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,snowvar)
<span class="linenos">3903</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : utl_fstlir : return = &#39;, iy5
<span class="linenos">3904</span>    iz5 = utl_fstlir(alb,   iun5,ni5,nj5,nk5,-1,&#39;&#39;,-1,-1,-1,&#39;&#39;,&#39;AL&#39;)
<span class="linenos">3905</span>    write(*,*) &#39;variable = AL           : utl_fstlir : return = &#39;, iz5
<span class="linenos">3906</span>
<span class="linenos">3907</span>    ! int_CXGAIG: define the grid descriptors (integer form) of the
<span class="linenos">3908</span>    !          observation profile output grid
<span class="linenos">3909</span>    ! desired output = ig1OBS, ig2OBS, ig3OBS, ig4OBS
<span class="linenos">3910</span>    zig1 = 0.0d0
<span class="linenos">3911</span>    zig2 = 0.0d0
<span class="linenos">3912</span>    zig3 = 1.0d0
<span class="linenos">3913</span>    zig4 = 1.0d0
<span class="linenos">3914</span>
<span class="linenos">3915</span>    call int_cxgaig(&#39;L&#39;,ig1OBS,ig2OBS,ig3OBS,ig4OBS,zig1,zig2,zig3,zig4)
<span class="linenos">3916</span>
<span class="linenos">3917</span>
<span class="linenos">3918</span>    ! int_EZGDEF: define the grid of the observations profiles (output grid)
<span class="linenos">3919</span>    ! of type Y containing the lat-lon of profiles
<span class="linenos">3920</span>    ! success = token to identify the grid
<span class="linenos">3921</span>    ! desired output = token
<span class="linenos">3922</span>    write(*,*) 
<span class="linenos">3923</span>    iv7 = int_ezgdef(nprf,1,&#39;Y&#39;,&#39;L&#39;,ig1obs,ig2obs,ig3obs,ig4obs,longitudes,latitudes)
<span class="linenos">3924</span>    write(*,*) &#39;apply to all variables  : int_EZGDEF : return = &#39;, iv7
<span class="linenos">3925</span>    
<span class="linenos">3926</span>
<span class="linenos">3927</span>    ! EZQKDEF: define the grid of the records data (input grid)
<span class="linenos">3928</span>    ! success = token to identify the grid
<span class="linenos">3929</span>    ! desired output = token
<span class="linenos">3930</span>    ! EZDEFSET: interpolate from input grids to output grid
<span class="linenos">3931</span>    ! success = key
<span class="linenos">3932</span>    ! int_hInterpScalar: interpolation of the field on the input grid to observation profiles
<span class="linenos">3933</span>    ! success = 0
<span class="linenos">3934</span>    ! desired output = FIELD_intrpl
<span class="linenos">3935</span>    write(*,*) 
<span class="linenos">3936</span>    ix8 = ezqkdef(ni3,nj3,grtyp3,ig13,ig23,ig33,ig43,iun3)
<span class="linenos">3937</span>    write(*,*) &#39;variable = LG           : ezqkdef  : return = &#39;, ix8
<span class="linenos">3938</span>    
<span class="linenos">3939</span>    ix9 = ezdefset(iv7,ix8)
<span class="linenos">3940</span>    write(*,*) &#39;variable = LG           : ezdefset : return = &#39;, ix9
<span class="linenos">3941</span>
<span class="linenos">3942</span>    ix10 = int_hInterpScalar(glace_intrpl,glace,interpDegree=&#39;NEAREST&#39;)
<span class="linenos">3943</span>    write(*,*) &#39;variable = LG           : int_hInterpScalar  : return = &#39;, ix10
<span class="linenos">3944</span>
<span class="linenos">3945</span>    write(*,*) 
<span class="linenos">3946</span>
<span class="linenos">3947</span>    iy8 = ezqkdef(ni4,nj4,grtyp4,ig14,ig24,ig34,ig44,iun3)
<span class="linenos">3948</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : ezqkdef  : return = &#39;, iy8
<span class="linenos">3949</span>
<span class="linenos">3950</span>    iy9 = ezdefset(iv7,iy8)
<span class="linenos">3951</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : ezdefset : return = &#39;, iy9
<span class="linenos">3952</span>
<span class="linenos">3953</span>    iy10 = int_hInterpScalar(neige_intrpl,neige,interpDegree=&#39;NEAREST&#39;)
<span class="linenos">3954</span>    write(*,*) &#39;variable = &#39;, snowvar, &#39;           : int_hInterpScalar  : return = &#39;, iy10
<span class="linenos">3955</span>
<span class="linenos">3956</span>    write(*,*) 
<span class="linenos">3957</span>
<span class="linenos">3958</span>    iz8 = ezqkdef(ni5,nj5,grtyp5,ig15,ig25,ig35,ig45,iun5)
<span class="linenos">3959</span>    write(*,*) &#39;variable = AL           : ezqkdef  : return = &#39;, iz8
<span class="linenos">3960</span>
<span class="linenos">3961</span>    iz9 = ezdefset(iv7,iz8)
<span class="linenos">3962</span>    write(*,*) &#39;variable = AL           : ezdefset : return = &#39;, iz9
<span class="linenos">3963</span>
<span class="linenos">3964</span>    iz10 = int_hInterpScalar(alb_intrpl,alb,interpDegree=&#39;NEAREST&#39;)
<span class="linenos">3965</span>    write(*,*) &#39;variable = AL           : int_hInterpScalar  : return = &#39;, iz10
<span class="linenos">3966</span>
<span class="linenos">3967</span>
<span class="linenos">3968</span>    ! fstfrm: close the standard files
<span class="linenos">3969</span>    ! success = 0
<span class="linenos">3970</span>    write(*,*) 
<span class="linenos">3971</span>    ix11 = fstfrm(iun3)
<span class="linenos">3972</span>    write(*,*) &#39;file = sfc4airs         : fstfrm : return = &#39;, ix11
<span class="linenos">3973</span>    
<span class="linenos">3974</span>    iz11 = fstfrm(iun5)
<span class="linenos">3975</span>    write(*,*) &#39;file = sfc4airs_newalb  : fstfrm : return = &#39;, iz11
<span class="linenos">3976</span> 
<span class="linenos">3977</span>
<span class="linenos">3978</span>    ! fclos: release the connections with the external files name
<span class="linenos">3979</span>    ! success = 0
<span class="linenos">3980</span>
<span class="linenos">3981</span>    write(*,*) 
<span class="linenos">3982</span>
<span class="linenos">3983</span>    ix12 = fclos(iun3)
<span class="linenos">3984</span>    write(*,*) &#39;file = sfc4airs         : fclos  : return = &#39;, ix12
<span class="linenos">3985</span>
<span class="linenos">3986</span>    iz12 = fclos(iun5)
<span class="linenos">3987</span>    write(*,*) &#39;file = sfc4airs_newalb  : fclos  : return = &#39;, iz12
<span class="linenos">3988</span>
<span class="linenos">3989</span>    ! assign surface caracteristics to observation profiles
<span class="linenos">3990</span>
<span class="linenos">3991</span>    do jn=1, nprf
<span class="linenos">3992</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % ice    = glace_intrpl(jn,1)
<span class="linenos">3993</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % snow   = neige_intrpl(jn,1)
<span class="linenos">3994</span>      tvs_surfaceParameters(sensorTovsIndexes(jn)) % albedo = alb_intrpl(jn,1)
<span class="linenos">3995</span>    end do
<span class="linenos">3996</span>
<span class="linenos">3997</span>    deallocate(glace,neige,alb)
<span class="linenos">3998</span>
<span class="linenos">3999</span>  end subroutine interp_sfc
<span class="linenos">4000</span>
<span class="linenos">4001</span>  !--------------------------------------------------------------------------
<span class="linenos">4002</span>  !  ceres_ematrix
<span class="linenos">4003</span>  !--------------------------------------------------------------------------
<span class="linenos">4004</span>  subroutine ceres_ematrix(emi_mat, waven, nchn)
<span class="linenos">4005</span>    !
<span class="linenos">4006</span>    !:Purpose: Set up emissivity versus fixed wavenumbers and surface types.
<span class="linenos">4007</span>    !
<span class="linenos">4008</span>    !:CERES:
<span class="linenos">4009</span>    ! Emissivity data available at low spectral resolution: only 14 values 
<span class="linenos">4010</span>    ! to cover the entire spectrum. Thus, this can be used as a nominal value.
<span class="linenos">4011</span>    ! The error associated with this emissivity can roughly be estimated to
<span class="linenos">4012</span>    ! increase with lower emissivity as : (1-EMI)*0.5 
<span class="linenos">4013</span>    ! (i.e. as large as 0.10 for EMI=0.80 but better than 0.01 for EMI &gt; 0.98)
<span class="linenos">4014</span>    ! -No dependence on viewing angle is assumed.
<span class="linenos">4015</span>    ! -Not to be used for oceans uncovered by ice.
<span class="linenos">4016</span>    !
<span class="linenos">4017</span>    !:Longwave Emmissivities in 12 original Fu bands + 2 extra to cover the range:
<span class="linenos">4018</span>    !
<span class="linenos">4019</span>    ! Longwave spectral intervals [cm-1] for the Fu &amp; Liou code.
<span class="linenos">4020</span>    !
<span class="linenos">4021</span>    ! ====  ==========  ==========  ==========  ===========  ==========  ==========  =========  =========  =========  =========  =========  =============
<span class="linenos">4022</span>    ! Band       1          2           3           4           5            6           7          8          9          10         11          12
<span class="linenos">4023</span>    !       2200-1900   1900-1700   1700-1400   1400-1250    1250-1100   1100-980     980-800    800-670    670-540    540-400    400-280    280-0 
<span class="linenos">4024</span>    ! ====  ==========  ==========  ==========  ===========  ==========  ==========  =========  =========  =========  =========  =========  =============
<span class="linenos">4025</span>    !
<span class="linenos">4026</span>    ! Two additional LW spectral intervals have been added in beyond 2200cm-1.
<span class="linenos">4027</span>    !
<span class="linenos">4028</span>    ! =====   ===========   ===========
<span class="linenos">4029</span>    ! Band        13            14
<span class="linenos">4030</span>    !          2500-2200     2850-2500
<span class="linenos">4031</span>    ! =====   ===========   ===========
<span class="linenos">4032</span>    !
<span class="linenos">4033</span>    ! Emissivity ems(band(1))   from April data, Table2 of Chen et al
<span class="linenos">4034</span>    ! 11th Conf Sat Met, Madison, WI, p 514
<span class="linenos">4035</span>    ! here regoganized as 14 13 1 2 ... 12 above
<span class="linenos">4036</span>    !
<span class="linenos">4037</span>    !:20 surface types:
<span class="linenos">4038</span>    !
<span class="linenos">4039</span>    ! ===================  ===================  ===================  =====================
<span class="linenos">4040</span>    !  1= evergreen nleaf   2= evergreen bleaf   3= deciduous nleaf   4= deciduous bleaf
<span class="linenos">4041</span>    !  5= mixed forests     6= closed shrubs     7= open shrubs       8= woody savanna
<span class="linenos">4042</span>    !  9= savanna          10= grasslands       11= perma wet        12= croplands
<span class="linenos">4043</span>    ! 13= urban            14= mosaic           15= snow             16= barren (deserts)
<span class="linenos">4044</span>    ! 17= water            18= toundra          19= fresh snow       20= sea ice
<span class="linenos">4045</span>    ! ===================  ===================  ===================  =====================
<span class="linenos">4046</span>    implicit none
<span class="linenos">4047</span>
<span class="linenos">4048</span>    ! Arguments
<span class="linenos">4049</span>    integer, intent(in) :: nchn              ! number of bands for which emissivity is needed
<span class="linenos">4050</span>    real(8), intent(in) :: waven(nchn)       ! wavenumbers (cm-1)
<span class="linenos">4051</span>    real(8), intent(out):: emi_mat(nchn, 20) ! emissivity (0.0-1.0)
<span class="linenos">4052</span>
<span class="linenos">4053</span>    ! locals
<span class="linenos">4054</span>    integer          :: i, nc, nt
<span class="linenos">4055</span>    real(8)          :: dum
<span class="linenos">4056</span>
<span class="linenos">4057</span>    ! CERES bands central wavenumber (covers 3.7 micron to 71.4 mic)
<span class="linenos">4058</span>    integer, parameter :: nb=14
<span class="linenos">4059</span>    real(8), parameter :: mid(nb) =(/                                             &amp;
<span class="linenos">4060</span>         2675.d0, 2350.d0, 2050.d0, 1800.d0, 1550.d0, 1325.d0, 1175.d0, 1040.d0,  &amp;
<span class="linenos">4061</span>         890.d0,  735.d0,  605.d0,  470.d0,  340.d0,  140.d0 /)
<span class="linenos">4062</span>
<span class="linenos">4063</span>    ! CERES emissivity per wavenumber and surface types
<span class="linenos">4064</span>    real(8), parameter ::  emi_tab(nb,20)=(/                                      &amp;
<span class="linenos">4065</span>         0.951d0, 0.989d0, 0.989d0, 0.989d0, 0.990d0, 0.991d0, 0.991d0, 0.990d0,  &amp;
<span class="linenos">4066</span>         0.990d0, 0.995d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4067</span>         0.956d0, 0.989d0, 0.989d0, 0.989d0, 0.990d0, 0.991d0, 0.991d0, 0.990d0,  &amp;
<span class="linenos">4068</span>         0.990d0, 0.995d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4069</span>         0.929d0, 0.985d0, 0.985d0, 0.986d0, 0.984d0, 0.983d0, 0.979d0, 0.980d0,  &amp;
<span class="linenos">4070</span>         0.973d0, 0.987d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4071</span>         0.943d0, 0.985d0, 0.985d0, 0.986d0, 0.984d0, 0.983d0, 0.979d0, 0.980d0,  &amp;
<span class="linenos">4072</span>         0.973d0, 0.987d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4073</span>         0.945d0, 0.987d0, 0.987d0, 0.987d0, 0.987d0, 0.987d0, 0.985d0, 0.985d0,  &amp;
<span class="linenos">4074</span>         0.982d0, 0.991d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4075</span>         0.933d0, 0.949d0, 0.949d0, 0.970d0, 0.974d0, 0.971d0, 0.947d0, 0.958d0,  &amp;
<span class="linenos">4076</span>         0.966d0, 0.975d0, 0.984d0, 0.984d0, 0.984d0, 0.984d0,                    &amp;
<span class="linenos">4077</span>         0.873d0, 0.873d0, 0.873d0, 0.934d0, 0.944d0, 0.939d0, 0.873d0, 0.904d0,  &amp;
<span class="linenos">4078</span>         0.936d0, 0.942d0, 0.951d0, 0.951d0, 0.951d0, 0.951d0,                    &amp;
<span class="linenos">4079</span>         0.930d0, 0.987d0, 0.987d0, 0.990d0, 0.992d0, 0.993d0, 0.983d0, 0.975d0,  &amp;
<span class="linenos">4080</span>         0.985d0, 0.993d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4081</span>         0.926d0, 0.987d0, 0.987d0, 0.990d0, 0.992d0, 0.993d0, 0.983d0, 0.975d0,  &amp;
<span class="linenos">4082</span>         0.985d0, 0.993d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4083</span>         0.899d0, 0.987d0, 0.987d0, 0.990d0, 0.992d0, 0.993d0, 0.983d0, 0.975d0,  &amp;
<span class="linenos">4084</span>         0.985d0, 0.993d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4085</span>         0.951d0, 0.983d0, 0.983d0, 0.987d0, 0.987d0, 0.988d0, 0.983d0, 0.981d0,  &amp;
<span class="linenos">4086</span>         0.987d0, 0.982d0, 0.986d0, 0.986d0, 0.986d0, 0.986d0,                    &amp;
<span class="linenos">4087</span>         0.924d0, 0.987d0, 0.987d0, 0.990d0, 0.992d0, 0.993d0, 0.983d0, 0.975d0,  &amp;
<span class="linenos">4088</span>         0.985d0, 0.993d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4089</span>         0.929d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,  &amp;
<span class="linenos">4090</span>         1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4091</span>         0.926d0, 0.987d0, 0.987d0, 0.989d0, 0.989d0, 0.990d0, 0.984d0, 0.980d0,  &amp;
<span class="linenos">4092</span>         0.983d0, 0.992d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,                    &amp;
<span class="linenos">4093</span>         0.972d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0, 1.000d0,  &amp;
<span class="linenos">4094</span>         1.000d0, 0.999d0, 0.999d0, 0.999d0, 0.999d0, 0.999d0,                    &amp;
<span class="linenos">4095</span>         0.866d0, 0.835d0, 0.835d0, 0.916d0, 0.934d0, 0.923d0, 0.835d0, 0.877d0,  &amp;
<span class="linenos">4096</span>         0.921d0, 0.926d0, 0.934d0, 0.934d0, 0.934d0, 0.934d0,                    &amp;
<span class="linenos">4097</span>         0.973d0, 0.979d0, 0.979d0, 0.983d0, 0.982d0, 0.982d0, 0.984d0, 0.987d0,  &amp;
<span class="linenos">4098</span>         0.989d0, 0.972d0, 0.972d0, 0.972d0, 0.972d0, 0.972d0,                    &amp;
<span class="linenos">4099</span>         0.968d0, 0.947d0, 0.947d0, 0.967d0, 0.988d0, 0.979d0, 0.975d0, 0.977d0,  &amp;
<span class="linenos">4100</span>         0.992d0, 0.989d0, 0.989d0, 0.989d0, 0.989d0, 0.989d0,                    &amp;
<span class="linenos">4101</span>         0.984d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0,  &amp;
<span class="linenos">4102</span>         0.988d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0, 0.988d0,                    &amp;
<span class="linenos">4103</span>         0.964d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0,  &amp;
<span class="linenos">4104</span>         0.979d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0, 0.979d0  /)
<span class="linenos">4105</span>
<span class="linenos">4106</span>
<span class="linenos">4107</span>
<span class="linenos">4108</span>    do nt = 1, 20
<span class="linenos">4109</span>      do nc = 1, nchn
<span class="linenos">4110</span>        if ( waven(nc) &gt; mid(1) ) then
<span class="linenos">4111</span>          emi_mat(nc,nt) = emi_tab(1,nt)
<span class="linenos">4112</span>        else if ( waven(nc) &lt; mid(nb) ) then
<span class="linenos">4113</span>          emi_mat(nc,nt) = emi_tab(nb,nt)
<span class="linenos">4114</span>        else
<span class="linenos">4115</span>          do i = 1, nb - 1
<span class="linenos">4116</span>            if ( waven(nc) &lt;= mid(i) .and. waven(nc) &gt;= mid(i + 1) ) then
<span class="linenos">4117</span>              dum = ( waven(nc) - mid(i) ) / ( mid(i + 1) - mid(i) )
<span class="linenos">4118</span>              emi_mat(nc,nt) = emi_tab(i,nt) + ( emi_tab(i + 1,nt) - emi_tab(i,nt) ) * dum
<span class="linenos">4119</span>              exit
<span class="linenos">4120</span>            end if
<span class="linenos">4121</span>          end do
<span class="linenos">4122</span>        end if
<span class="linenos">4123</span>      end do
<span class="linenos">4124</span>    end do
<span class="linenos">4125</span>
<span class="linenos">4126</span>
<span class="linenos">4127</span>  end subroutine ceres_ematrix
<span class="linenos">4128</span>
<span class="linenos">4129</span>  !--------------------------------------------------------------------------
<span class="linenos">4130</span>  !  emi_sea
<span class="linenos">4131</span>  !--------------------------------------------------------------------------
<span class="linenos">4132</span>  subroutine emi_sea(em_oc, wnum, angle, wind, np, nc)
<span class="linenos">4133</span>    !
<span class="linenos">4134</span>    !:Purpose: GET OCEAN SURFACE EMISSIVITY
<span class="linenos">4135</span>    !:Note:    IMEM(NC), set to zero initially, on next call IMEM will have the
<span class="linenos">4136</span>    !           right boundary channel to save search time in interpolation.
<span class="linenos">4137</span>    !           IOPT=1 means activate IMEM option (all calls ask for same channels)
<span class="linenos">4138</span>    !
<span class="linenos">4139</span>    !           To get surface ocean emissivity for a group of channels with
<span class="linenos">4140</span>    !           wavenumbers WNUM (cm-1) looking at one point with surface
<span class="linenos">4141</span>    !           wind speed wind from angle angle.
<span class="linenos">4142</span>    !           Based on Masuda,1988, Remote Sens. of Envir, 313-329.
<span class="linenos">4143</span>    !           Coded emissivity routine based on Masuda&#39;s data by Tom Kleespies
<span class="linenos">4144</span>    !           Covers 650-2857 cm-1 or 3.1-15.4 microns
<span class="linenos">4145</span>    !
<span class="linenos">4146</span>    !:CAUTION: extrapolated values from 769-650 cm-1
<span class="linenos">4147</span>    !           and interpolated values between 2439-1250 cm-1
<span class="linenos">4148</span>    !
<span class="linenos">4149</span>    implicit none
<span class="linenos">4150</span>
<span class="linenos">4151</span>    ! Arguments:
<span class="linenos">4152</span>    real(8), intent(out)   :: em_oc(nc,np) ! Ocean emissivities (0.-1.)
<span class="linenos">4153</span>    real(8), intent(in)    :: wnum(nc)     ! Channel wavenumbers (cm-1)
<span class="linenos">4154</span>    real(8), intent(in)    :: angle(np)    ! Viewing angle (deg)
<span class="linenos">4155</span>    real(8), intent(in)    :: wind(np)     ! Surface wind speed (m/s)
<span class="linenos">4156</span>    integer, intent(in)    :: np           ! Number of profiles
<span class="linenos">4157</span>    integer, intent(in)    :: nc           ! Number of channels
<span class="linenos">4158</span>
<span class="linenos">4159</span>    ! Locals
<span class="linenos">4160</span>    integer     :: i, k, l
<span class="linenos">4161</span>    integer     :: imem(nc) 
<span class="linenos">4162</span>    integer     :: mchan(2)
<span class="linenos">4163</span>    real(8)     :: dum
<span class="linenos">4164</span>    real(8)     :: emi2(2,np)
<span class="linenos">4165</span>
<span class="linenos">4166</span>    ! Masuda&#39;s 19 wavelengths converted to wavenumber
<span class="linenos">4167</span>    real(8), parameter :: refw(19)=(/ 2857.1d0, 2777.7d0, 2702.7d0, 2631.6d0, 2564.1d0, &amp;
<span class="linenos">4168</span>         2500.0d0, 2439.0d0, 1250.0d0, 1190.5d0, 1136.3d0,                           &amp;
<span class="linenos">4169</span>         1087.0d0, 1041.7d0, 1000.0d0, 952.38d0, 909.09d0,                           &amp;
<span class="linenos">4170</span>         869.57d0, 833.33d0, 800.00d0, 769.23d0/)
<span class="linenos">4171</span>
<span class="linenos">4172</span>
<span class="linenos">4173</span>    ! imem options
<span class="linenos">4174</span>
<span class="linenos">4175</span>    imem(:) = 0
<span class="linenos">4176</span>
<span class="linenos">4177</span>    do I = 1, nc
<span class="linenos">4178</span>
<span class="linenos">4179</span>      !  out of range
<span class="linenos">4180</span>      if ( wnum(I) &lt; 645.d0 .or. wnum(I) &gt; refw(1) ) then
<span class="linenos">4181</span>        write(*,&#39;(A,1x,e12.4)&#39;) &#39; fatal: wavenumber out of range in emi_sea&#39;, wnum(I)
<span class="linenos">4182</span>        stop
<span class="linenos">4183</span>      else if ( wnum(I) &lt;= refw(19) .and. wnum(I) &gt; 645.d0 ) then
<span class="linenos">4184</span>        !  extrapolated from 769 cm-1 to 645 cm-1: NOT FROM REAL DATA
<span class="linenos">4185</span>        !  nevertheless thought to be much better than unity
<span class="linenos">4186</span>        !  this is a region of relatively rapid emissivity change
<span class="linenos">4187</span>        !  worst estimates for 700-645 cm-1, but these channels do not
<span class="linenos">4188</span>        !  see the surface (strong co2 absorption).
<span class="linenos">4189</span>        imem(I) = 18
<span class="linenos">4190</span>      else
<span class="linenos">4191</span>        !  CAUTION interpolation on large interval 1250-2439 cm-1
<span class="linenos">4192</span>        !  where no data is available except that of ASTER. ASTER
<span class="linenos">4193</span>        !  shows a relatively smooth variation with wavelength except
<span class="linenos">4194</span>        !  for a sharp drop at 1600 cm-1 with highs at 1550 and 1650 cm-1
<span class="linenos">4195</span>        !  with peak-to-peak variation of 1.5% in that narrow range.
<span class="linenos">4196</span>        !  Worst estimates would be between 1400-1800 cm-1 in HIRS ch 12
<span class="linenos">4197</span>        !  which only in very cold atmospheres sees the surface.
<span class="linenos">4198</span>        do k = 1, 18
<span class="linenos">4199</span>          if ( wnum(I) &gt; refw(k + 1) .and. wnum(I) &lt;= refw(k) ) then
<span class="linenos">4200</span>            imem(I) = k
<span class="linenos">4201</span>          end if
<span class="linenos">4202</span>        end do
<span class="linenos">4203</span>
<span class="linenos">4204</span>      end if
<span class="linenos">4205</span>   
<span class="linenos">4206</span>      mchan(1)= imem(I)
<span class="linenos">4207</span>      mchan(2)= imem(I) + 1
<span class="linenos">4208</span>
<span class="linenos">4209</span>      dum = ( wnum(I) - refw(mchan(1)) ) / ( refw(mchan(2)) - refw(mchan(1)) )
<span class="linenos">4210</span>
<span class="linenos">4211</span>      call COMP_IR_EMISS(emi2, wind,angle,2,np,mchan)
<span class="linenos">4212</span>
<span class="linenos">4213</span>      ! interpolation/extrapolation in wavenumber 
<span class="linenos">4214</span>
<span class="linenos">4215</span>      do L = 1, np
<span class="linenos">4216</span>  
<span class="linenos">4217</span>        em_oc(I,L) = emi2(1,L) + ( emi2(2,L) - emi2(1,L) ) * dum
<span class="linenos">4218</span>          
<span class="linenos">4219</span>      end do
<span class="linenos">4220</span>
<span class="linenos">4221</span>    end do
<span class="linenos">4222</span>
<span class="linenos">4223</span>
<span class="linenos">4224</span>  end subroutine emi_sea
<span class="linenos">4225</span>
<span class="linenos">4226</span>
<span class="linenos">4227</span>  !--------------------------------------------------------------------------
<span class="linenos">4228</span>  !  tvs_getCommonChannelSet
<span class="linenos">4229</span>  !--------------------------------------------------------------------------
<span class="linenos">4230</span>  subroutine tvs_getCommonChannelSet(channels,countUniqueChannel, listAll)
<span class="linenos">4231</span>    !
<span class="linenos">4232</span>    !:Purpose: get common channels among all MPI tasks
<span class="linenos">4233</span>    !
<span class="linenos">4234</span>    implicit none
<span class="linenos">4235</span>    !Arguments:
<span class="linenos">4236</span>    integer, intent(in) :: channels(:)
<span class="linenos">4237</span>    integer, intent(out):: countUniqueChannel, listAll(:)
<span class="linenos">4238</span>    !Locals:
<span class="linenos">4239</span>    integer :: channelsb(tvs_maxChannelNumber)
<span class="linenos">4240</span>    integer :: ierr, i, j
<span class="linenos">4241</span>    integer, allocatable :: listGlobal(:)
<span class="linenos">4242</span>    logical :: found
<span class="linenos">4243</span>     
<span class="linenos">4244</span>    if (size(channels) &gt; tvs_maxChannelNumber) then
<span class="linenos">4245</span>      write(*,*) &#39;You need to increase tvs_maxChannelNumber in tovs_nl_mod !&#39;,size(channels), tvs_maxChannelNumber
<span class="linenos">4246</span>      call utl_abort(&#39;tvs_getCommonChannelSet&#39;)
<span class="linenos">4247</span>    end if
<span class="linenos">4248</span>
<span class="linenos">4249</span>    if (mmpi_myid ==0) then
<span class="linenos">4250</span>      allocate(listGlobal(mmpi_nprocs*tvs_maxChannelNumber))
<span class="linenos">4251</span>    else
<span class="linenos">4252</span>      allocate(listGlobal(1))
<span class="linenos">4253</span>    end if
<span class="linenos">4254</span>
<span class="linenos">4255</span>    listAll(:) = 0
<span class="linenos">4256</span>    listGlobal(:) = 0
<span class="linenos">4257</span>    channelsb(:) = 0
<span class="linenos">4258</span>    channelsb(1:size(channels)) = channels(:)
<span class="linenos">4259</span>
<span class="linenos">4260</span>    call rpn_comm_barrier(&#39;GRID&#39;,ierr)
<span class="linenos">4261</span>
<span class="linenos">4262</span>    call rpn_comm_gather(channelsb, tvs_maxChannelNumber, &#39;MPI_INTEGER&#39;, listGlobal, &amp;
<span class="linenos">4263</span>         tvs_maxChannelNumber, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4264</span>    countUniqueChannel = 0
<span class="linenos">4265</span>    if ( mmpi_myid == 0 ) then
<span class="linenos">4266</span>      call isort(listGlobal, mmpi_nprocs*tvs_maxChannelNumber)
<span class="linenos">4267</span>      do i=1, mmpi_nprocs * tvs_maxChannelNumber
<span class="linenos">4268</span>        if (listGlobal(i) &gt; 0) then
<span class="linenos">4269</span>          found = .false.
<span class="linenos">4270</span>          LOOPJ: do j=countUniqueChannel,1,-1
<span class="linenos">4271</span>            if (listGlobal(i) == listAll(j) ) then
<span class="linenos">4272</span>              found =.true.
<span class="linenos">4273</span>              exit LOOPJ
<span class="linenos">4274</span>            end if
<span class="linenos">4275</span>          end do LOOPJ
<span class="linenos">4276</span>          if (.not.found) then
<span class="linenos">4277</span>            countUniqueChannel = countUniqueChannel + 1
<span class="linenos">4278</span>            listAll(countUniqueChannel) = listGlobal(i)
<span class="linenos">4279</span>          end if
<span class="linenos">4280</span>        end if
<span class="linenos">4281</span>      end do
<span class="linenos">4282</span>    end if
<span class="linenos">4283</span>    
<span class="linenos">4284</span>    call rpn_comm_bcast(countUniqueChannel, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4285</span>    call rpn_comm_bcast(listAll(1:countUniqueChannel), countUniqueChannel, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4286</span>
<span class="linenos">4287</span>    deallocate(listGlobal)
<span class="linenos">4288</span>
<span class="linenos">4289</span>  end subroutine tvs_getCommonChannelSet
<span class="linenos">4290</span>
<span class="linenos">4291</span>
<span class="linenos">4292</span>  !--------------------------------------------------------------------------
<span class="linenos">4293</span>  !  tvs_rttov_read_coefs
<span class="linenos">4294</span>  !--------------------------------------------------------------------------
<span class="linenos">4295</span>  subroutine tvs_rttov_read_coefs(errorStatus, coefs, opts, channels, instrument)
<span class="linenos">4296</span>    !
<span class="linenos">4297</span>    !:Purpose: MPI wrapper for rttov_read_coefs
<span class="linenos">4298</span>    !           the coefficient files are read by MPI task 0
<span class="linenos">4299</span>    !           and then broadcasted to the other tasks according to the selected
<span class="linenos">4300</span>    !           channels. Argument channels is mandatory (it is optional in rttov_setup)
<span class="linenos">4301</span>    !           optional argument channels_rec was removed (it is useful only in principal component mode)
<span class="linenos">4302</span>    !           other optionnal arguments were removed :
<span class="linenos">4303</span>    !                          *  form_coef, to specify format
<span class="linenos">4304</span>    !                          *  form_scaer,        
<span class="linenos">4305</span>    !                          *  form_sccld,        
<span class="linenos">4306</span>    !                          *  form_pccoef,       
<span class="linenos">4307</span>    !                          *  file_coef, to specify filename
<span class="linenos">4308</span>    !                          *  file_scaer,        
<span class="linenos">4309</span>    !                          *  file_sccld,        
<span class="linenos">4310</span>    !                          *  file_pccoef,       
<span class="linenos">4311</span>    !                          *  file_id_coef, to specify fortran unit number
<span class="linenos">4312</span>    !                          *  file_id_scaer,     
<span class="linenos">4313</span>    !                          *  file_id_sccld,     
<span class="linenos">4314</span>    !                          *  file_id_pccoef,
<span class="linenos">4315</span>    !                          *  path,  to specify the path to look for coefficient files
<span class="linenos">4316</span>    !
<span class="linenos">4317</span>    !           if necessary these arguments could be  added (ask S. Heilliette)
<span class="linenos">4318</span>    !           also this subroutine will work only for clear sky radiance computations
<span class="linenos">4319</span>    !           if somebody wants to do realistic cloud or aerosol affected radiance simulations
<span class="linenos">4320</span>    !           some changes are needed. Ask me in that case. (S. Heilliette) 
<span class="linenos">4321</span>    !           It is implicitely assumed that the options are the same for all MPI tasks for a given instrument
<span class="linenos">4322</span>    !           No check will be done (options for task 0 will be used for all tasks). 
<span class="linenos">4323</span>    !           Only differences in channel lists are accounted for.
<span class="linenos">4324</span>    !
<span class="linenos">4325</span>
<span class="linenos">4326</span>    implicit none
<span class="linenos">4327</span>
<span class="linenos">4328</span>    ! Arguments:
<span class="linenos">4329</span>    integer(kind=jpim), intent(out) :: errorStatus  ! Error status
<span class="linenos">4330</span>    type(rttov_coefs),  intent(out) :: coefs        ! Rttov coefficient structure
<span class="linenos">4331</span>    type(rttov_options), intent(in) :: opts         ! Rttov option structure
<span class="linenos">4332</span>    integer(kind=jpim), intent(in)  :: channels(:)  ! Channel list
<span class="linenos">4333</span>    integer(kind=jpim), intent(in)  :: instrument(3)! Instrument vector
<span class="linenos">4334</span>
<span class="linenos">4335</span>    ! Locals:
<span class="linenos">4336</span>    real(8), allocatable :: bigArray(:,:,:,:)
<span class="linenos">4337</span>    integer :: i, j, ichan, ierr, countUniqueChannel, indexchan(size(channels)), listAll(tvs_maxChannelNumber)
<span class="linenos">4338</span>    logical :: associated0
<span class="linenos">4339</span>    integer :: nlte_count, nlte_start,isol,isat,nlte_file_nchan
<span class="linenos">4340</span>    integer, allocatable :: nlte_chans(:) 
<span class="linenos">4341</span>
<span class="linenos">4342</span>    write(*,*) &#39;tvs_rttov_read_coefs: Starting&#39;
<span class="linenos">4343</span>
<span class="linenos">4344</span>    ! First step: we should determine a common set of channels among MPI tasks
<span class="linenos">4345</span>    call tvs_getCommonChannelSet(channels,countUniqueChannel, listAll)
<span class="linenos">4346</span>
<span class="linenos">4347</span>    ! Second step: mpi task 0 will do the job
<span class="linenos">4348</span>    if ( mmpi_myid == 0 ) then
<span class="linenos">4349</span>      call rttov_read_coefs (         &amp;
<span class="linenos">4350</span>          errorStatus,                &amp;! out
<span class="linenos">4351</span>          coefs,                      &amp;
<span class="linenos">4352</span>          opts,                       &amp;
<span class="linenos">4353</span>          instrument=instrument,      &amp;! in
<span class="linenos">4354</span>          channels=listAll(1:countUniqueChannel)  )     ! in option
<span class="linenos">4355</span>      if (errorStatus /= errorStatus_success) then
<span class="linenos">4356</span>        write(*,*) &#39;tvs_rttov_read_coefs: failure in rttov_read_coefs while reading RTTOV coefficient file&#39;, instrument, errorStatus
<span class="linenos">4357</span>        call utl_abort(&#39;tvs_rttov_read_coefs&#39;)
<span class="linenos">4358</span>      end if
<span class="linenos">4359</span>    else
<span class="linenos">4360</span>      call rttov_nullify_coef(coefs%coef)
<span class="linenos">4361</span>    end if
<span class="linenos">4362</span>
<span class="linenos">4363</span>    ! Third step: common (i.e. independent from the channel list) parameters are simply broadcasted to other processors
<span class="linenos">4364</span>    ! Scalar and fixed size arrays and  strings first
<span class="linenos">4365</span>    coefs%initialised = .true.                                                    ! Logical flag for initialization
<span class="linenos">4366</span>    call rpn_comm_bcast(coefs%coef%id_platform, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)! OK
<span class="linenos">4367</span>    call rpn_comm_bcast(coefs%coef%id_sat, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)     ! OK
<span class="linenos">4368</span>    call rpn_comm_bcast(coefs%coef%id_inst, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)    ! OK
<span class="linenos">4369</span>    call rpn_comm_bcast(coefs%coef%id_sensor, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)  ! OK 
<span class="linenos">4370</span>    call rpn_comm_bcast(coefs%coef%id_comp_lvl, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)! OK
<span class="linenos">4371</span>    call rpn_comm_bcast(coefs%coef%id_comp_pc, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) ! OK
<span class="linenos">4372</span>
<span class="linenos">4373</span>    call rpn_comm_bcast(coefs%coef%fmv_model_ver, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4374</span>    call rpn_comm_bcast(coefs%coef%fmv_chn, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4375</span>    call rpn_comm_bcast(coefs%coef%fmv_gas, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4376</span>    call rpn_comm_bcast(coefs%coef%fmv_ori_nchn, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4377</span>
<span class="linenos">4378</span>    call rpn_comm_bcast(coefs%coef%nmixed, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)          ! number of variables/predictors for Mixed Gases
<span class="linenos">4379</span>    call rpn_comm_bcast(coefs%coef%nwater, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)          ! number of variables/predictors for Water Vapour
<span class="linenos">4380</span>    call rpn_comm_bcast(coefs%coef%nozone, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)          ! number of variables/predictors for Ozone
<span class="linenos">4381</span>    call rpn_comm_bcast(coefs%coef%nwvcont, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of variables/predictors for WV continuum
<span class="linenos">4382</span>    call rpn_comm_bcast(coefs%coef%nco2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)            ! number of variables/predictors for CO2
<span class="linenos">4383</span>    call rpn_comm_bcast(coefs%coef%nn2o , 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of variables/predictors for N2O
<span class="linenos">4384</span>    call rpn_comm_bcast(coefs%coef%nco, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)             ! number of variables/predictors for CO
<span class="linenos">4385</span>    call rpn_comm_bcast(coefs%coef%nch4, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)            ! number of variables/predictors for CH4
<span class="linenos">4386</span>    call rpn_comm_bcast(coefs%coef%nso2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)            ! number of variables/predictors for SO2
<span class="linenos">4387</span>
<span class="linenos">4388</span>    call rpn_comm_bcast(coefs%coef%nlevels, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of levels(pres/absorber) same for all gases
<span class="linenos">4389</span>    call rpn_comm_bcast(coefs%coef%nlayers, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of layers(pres/absorber) nlevels-1
<span class="linenos">4390</span>    call rpn_comm_bcast(coefs%coef%pmc_nlay, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4391</span>    call rpn_comm_bcast(coefs%coef%pmc_nvar, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4392</span>    call rpn_comm_bcast(coefs%coef%IncZeeman, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)       ! Flag to include Zeeman effect for this sensor
<span class="linenos">4393</span>    call rpn_comm_bcast(coefs%coef%solarcoef, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)       ! Flag to include solar reflection
<span class="linenos">4394</span>    call rpn_comm_bcast(coefs%coef%nltecoef, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)        ! Flag to include nlte corrections
<span class="linenos">4395</span>    call rpn_comm_bcast(coefs%coef%pmc_shift, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4396</span>
<span class="linenos">4397</span>    call rpn_comm_bcast(coefs%coef%ncmixed, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Mixed Gases
<span class="linenos">4398</span>    call rpn_comm_bcast(coefs%coef%ncwater, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Water Vapour
<span class="linenos">4399</span>    call rpn_comm_bcast(coefs%coef%ncozone, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Ozone
<span class="linenos">4400</span>    call rpn_comm_bcast(coefs%coef%ncwvcont, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)        ! number of coefficients for WV continuum
<span class="linenos">4401</span>    call rpn_comm_bcast(coefs%coef%ncco2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CO2
<span class="linenos">4402</span>    call rpn_comm_bcast(coefs%coef%ncn2o, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for N2O
<span class="linenos">4403</span>    call rpn_comm_bcast(coefs%coef%ncco , 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CO
<span class="linenos">4404</span>    call rpn_comm_bcast(coefs%coef%ncch4, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CH4
<span class="linenos">4405</span>    call rpn_comm_bcast(coefs%coef%ncso2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for SO2
<span class="linenos">4406</span>
<span class="linenos">4407</span>    call rpn_comm_bcast(coefs%coef%nccmixed, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Mixed Gases
<span class="linenos">4408</span>    call rpn_comm_bcast(coefs%coef%nccwater, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Water Vapour
<span class="linenos">4409</span>    call rpn_comm_bcast(coefs%coef%nccozone, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)         ! number of coefficients for Ozone
<span class="linenos">4410</span>    call rpn_comm_bcast(coefs%coef%nccwvcont, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)        ! number of coefficients for WV continuum
<span class="linenos">4411</span>    call rpn_comm_bcast(coefs%coef%nccco2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CO2
<span class="linenos">4412</span>    call rpn_comm_bcast(coefs%coef%nccn2o, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for N2O
<span class="linenos">4413</span>    call rpn_comm_bcast(coefs%coef%nccco , 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CO
<span class="linenos">4414</span>    call rpn_comm_bcast(coefs%coef%nccch4, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for CH4
<span class="linenos">4415</span>    call rpn_comm_bcast(coefs%coef%nccso2, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)           ! number of coefficients for SO2
<span class="linenos">4416</span>
<span class="linenos">4417</span>    call rpn_comm_bcast(coefs%coef%ws_nomega, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4418</span>
<span class="linenos">4419</span>    call rpn_comm_bcast(coefs%coef%id_creation_date, 3, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr) ! OK 
<span class="linenos">4420</span>    call rpn_comm_bcastc(coefs%coef%id_creation, 80, &#39;MPI_CHARACTER&#39;, 0, &#39;GRID&#39;, ierr)  ! OK 
<span class="linenos">4421</span>    call rpn_comm_bcastc(coefs%coef%id_Common_name, 32, &#39;MPI_CHARACTER&#39;, 0, &#39;GRID&#39;, ierr) !OK
<span class="linenos">4422</span>    do i=1, 100
<span class="linenos">4423</span>      call rpn_comm_bcastc(coefs%coef%line_by_line(i), 132, &#39;MPI_CHARACTER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4424</span>      call rpn_comm_bcastc(coefs%coef%readme_srf(i), 132, &#39;MPI_CHARACTER&#39;, 0, &#39;GRID&#39;, ierr) !ok
<span class="linenos">4425</span>    end do
<span class="linenos">4426</span>    call rpn_comm_bcastc(coefs%coef%fmv_model_def, 32, &#39;MPI_CHARACTER&#39;, 0, &#39;GRID&#39;, ierr)  !OK
<span class="linenos">4427</span>    call rpn_comm_bcast(coefs%coef%fc_planck_c1, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) ! first radiation constant (mW/(m2*sr*cm-4)) !ok
<span class="linenos">4428</span>    call rpn_comm_bcast(coefs%coef%fc_planck_c2, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) !second radiation constant (mW/(m2*sr*cm-4)) !ok
<span class="linenos">4429</span>    call rpn_comm_bcast(coefs%coef%fc_sat_height, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)! satellite nominal altitude (km) !ok
<span class="linenos">4430</span>
<span class="linenos">4431</span>    call rpn_comm_bcast(coefs%coef%pmc_lengthcell, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4432</span>    call rpn_comm_bcast(coefs%coef%pmc_tempcell, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4433</span>    call rpn_comm_bcast(coefs%coef%pmc_betaplus1, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4434</span>    ! FASTEM section
<span class="linenos">4435</span>    call rpn_comm_bcast(coefs%coef%ssirem_ver, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4436</span>    call rpn_comm_bcast(coefs%coef%iremis_version, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4437</span>    call rpn_comm_bcast(coefs%coef%iremis_ncoef, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4438</span>    call rpn_comm_bcast(coefs%coef%iremis_angle0, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4439</span>    call rpn_comm_bcast(coefs%coef%iremis_tskin0, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4440</span>    call rpn_comm_bcast(coefs%coef%ratoe, 1, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4441</span>    ! then variable size vectors
<span class="linenos">4442</span>    ! this one must be done first because it is used to dimension other ones ....
<span class="linenos">4443</span>    if (mmpi_myid &gt; 0) allocate( coefs%coef%fmv_lvl(coefs%coef%fmv_gas))
<span class="linenos">4444</span>    call rpn_comm_bcast(coefs%coef%fmv_lvl, coefs%coef%fmv_gas, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4445</span>    if (mmpi_myid &gt; 0) then
<span class="linenos">4446</span>      if (coefs%coef%nltecoef) allocate( coefs%coef%nlte_coef)
<span class="linenos">4447</span>      allocate( coefs%coef%fmv_gas_id(coefs%coef%fmv_gas))
<span class="linenos">4448</span>      allocate( coefs%coef%fmv_gas_pos(ngases_max)) !size is from rttov consts
<span class="linenos">4449</span>      allocate( coefs%coef%fmv_var(coefs%coef%fmv_gas))
<span class="linenos">4450</span>      allocate( coefs%coef%fmv_coe(coefs%coef%fmv_gas)) ! number of coefficients by gas (fmv_gas)
<span class="linenos">4451</span>      allocate( coefs%coef%fmv_ncorr(coefs%coef%fmv_gas)) ! number of coefs by gas for correction term (fmv_gas) (v13 only)
<span class="linenos">4452</span>      allocate( coefs%coef%ws_npoint(coefs%coef%ws_nomega) )
<span class="linenos">4453</span>      allocate( coefs%coef%ws_k_omega(coefs%coef%ws_nomega) )
<span class="linenos">4454</span>      allocate( coefs%coef%ref_prfl_p(coefs%coef%nlevels ) )
<span class="linenos">4455</span>      allocate( coefs%coef%ref_prfl_t(coefs%coef%nlevels, coefs%coef%fmv_gas ) )
<span class="linenos">4456</span>      allocate( coefs%coef%ref_prfl_mr(coefs%coef%nlevels, coefs%coef%fmv_gas ) )
<span class="linenos">4457</span>      allocate( coefs%coef%bkg_prfl_mr(coefs%coef%nlevels, coefs%coef%fmv_gas ) )
<span class="linenos">4458</span>      allocate( coefs%coef%lim_prfl_p(coefs%coef%nlevels ) )
<span class="linenos">4459</span>      allocate( coefs%coef%lim_prfl_tmax(coefs%coef%fmv_lvl(gas_id_mixed) ) )
<span class="linenos">4460</span>      allocate( coefs%coef%lim_prfl_tmin(coefs%coef%fmv_lvl(gas_id_mixed) ) )
<span class="linenos">4461</span>      allocate( coefs%coef%lim_prfl_gmax(coefs%coef%fmv_lvl(gas_id_mixed), coefs%coef%fmv_gas ) )
<span class="linenos">4462</span>      allocate( coefs%coef%lim_prfl_gmin(coefs%coef%fmv_lvl(gas_id_mixed), coefs%coef%fmv_gas ) )
<span class="linenos">4463</span>      allocate( coefs%coef%env_prfl_tmax(coefs%coef%nlevels ) )
<span class="linenos">4464</span>      allocate( coefs%coef%env_prfl_tmin(coefs%coef%nlevels ) )
<span class="linenos">4465</span>      allocate( coefs%coef%env_prfl_gmax(coefs%coef%nlevels, coefs%coef%fmv_gas ) )
<span class="linenos">4466</span>      allocate( coefs%coef%env_prfl_gmin(coefs%coef%nlevels, coefs%coef%fmv_gas ) )
<span class="linenos">4467</span>      allocate( coefs%coef%dpp(0:coefs%coef%nlayers) )
<span class="linenos">4468</span>      allocate( coefs%coef%dp(coefs%coef%nlayers) )
<span class="linenos">4469</span>      allocate( coefs%coef%tstar(coefs%coef%nlayers) )
<span class="linenos">4470</span>      allocate( coefs%coef%tstar_r(coefs%coef%nlayers) )
<span class="linenos">4471</span>      allocate( coefs%coef%tstar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4472</span>      if (coefs%coef%fmv_model_ver == 8) &amp;
<span class="linenos">4473</span>           allocate( coefs%coef%tstarmod_wsum_r(coefs%coef%nlayers) )
<span class="linenos">4474</span>      if (coefs%coef%fmv_model_ver &lt;= 9) &amp;
<span class="linenos">4475</span>           allocate( coefs%coef%tstar_uwsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4476</span>      allocate( coefs%coef%wstar(coefs%coef%nlayers) )
<span class="linenos">4477</span>      allocate( coefs%coef%wstar_r(coefs%coef%nlayers) )
<span class="linenos">4478</span>      allocate( coefs%coef%wstar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4479</span>      allocate( coefs%coef%wtstar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4480</span>    end if
<span class="linenos">4481</span>
<span class="linenos">4482</span>    call broadcastI41dArray( coefs%coef%fmv_gas_id )
<span class="linenos">4483</span>    call broadcastI41dArray( coefs%coef%fmv_gas_pos )
<span class="linenos">4484</span>    call broadcastI41dArray( coefs%coef%fmv_var )
<span class="linenos">4485</span>    call broadcastI41dArray( coefs%coef%fmv_coe )
<span class="linenos">4486</span>    call broadcastI41dArray( coefs%coef%fmv_ncorr )
<span class="linenos">4487</span>    call broadcastR81dArray( coefs%coef%ws_npoint )
<span class="linenos">4488</span>    call broadcastR81dArray( coefs%coef%ws_k_omega )
<span class="linenos">4489</span>    call broadcastR81dArray( coefs%coef%ref_prfl_p )
<span class="linenos">4490</span>    call broadcastR82dArray( coefs%coef%ref_prfl_t )
<span class="linenos">4491</span>    call broadcastR82dArray( coefs%coef%ref_prfl_mr )
<span class="linenos">4492</span>    call broadcastR82dArray( coefs%coef%bkg_prfl_mr )
<span class="linenos">4493</span>    call broadcastR81dArray( coefs%coef%lim_prfl_p )
<span class="linenos">4494</span>    call broadcastR81dArray( coefs%coef%lim_prfl_tmax )
<span class="linenos">4495</span>    call broadcastR81dArray( coefs%coef%lim_prfl_tmin )
<span class="linenos">4496</span>    call broadcastR82dArray( coefs%coef%lim_prfl_gmax )
<span class="linenos">4497</span>    call broadcastR82dArray( coefs%coef%lim_prfl_gmin )
<span class="linenos">4498</span>    call broadcastR81dArray( coefs%coef%env_prfl_tmax )
<span class="linenos">4499</span>    call broadcastR81dArray( coefs%coef%env_prfl_tmin )
<span class="linenos">4500</span>    call broadcastR82dArray( coefs%coef%env_prfl_gmax )
<span class="linenos">4501</span>    call broadcastR82dArray( coefs%coef%env_prfl_gmin )
<span class="linenos">4502</span>    call broadcastR81dArray( coefs%coef%dp )
<span class="linenos">4503</span>    call broadcastR81dArray( coefs%coef%dpp )
<span class="linenos">4504</span>    call broadcastR81dArray( coefs%coef%tstar ) 
<span class="linenos">4505</span>    call broadcastR81dArray( coefs%coef%tstar_r )
<span class="linenos">4506</span>    call broadcastR81dArray( coefs%coef%tstar_wsum_r )
<span class="linenos">4507</span>    if (coefs%coef%fmv_model_ver == 8) &amp;
<span class="linenos">4508</span>         call broadcastR81dArray( coefs%coef%tstarmod_wsum_r )
<span class="linenos">4509</span>    if (coefs%coef%fmv_model_ver &lt;= 9) &amp;
<span class="linenos">4510</span>         call broadcastR81dArray( coefs%coef%tstar_uwsum_r )
<span class="linenos">4511</span>    call broadcastR81dArray( coefs%coef%wstar )
<span class="linenos">4512</span>    call broadcastR81dArray( coefs%coef%wstar_r )
<span class="linenos">4513</span>    call broadcastR81dArray( coefs%coef%wstar_wsum_r )
<span class="linenos">4514</span>    call broadcastR81dArray( coefs%coef%wtstar_wsum_r )
<span class="linenos">4515</span>    if (coefs%coef%nozone &gt; 0) then
<span class="linenos">4516</span>      if (mmpi_myid &gt; 0) then
<span class="linenos">4517</span>        allocate( coefs%coef%to3star(coefs%coef%nlayers) )
<span class="linenos">4518</span>        allocate( coefs%coef%ostar(coefs%coef%nlayers) )
<span class="linenos">4519</span>        allocate( coefs%coef%to3star_r(coefs%coef%nlayers) )
<span class="linenos">4520</span>        allocate( coefs%coef%ostar_r(coefs%coef%nlayers) )
<span class="linenos">4521</span>        allocate( coefs%coef%ostar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4522</span>      end if
<span class="linenos">4523</span>      call rpn_comm_bcast(coefs%coef%to3star, size(coefs%coef%to3star) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4524</span>      call rpn_comm_bcast(coefs%coef%ostar, size(coefs%coef%ostar) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4525</span>      call rpn_comm_bcast(coefs%coef%to3star_r, size(coefs%coef%to3star_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4526</span>      call rpn_comm_bcast(coefs%coef%ostar_r, size(coefs%coef%ostar_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4527</span>      call rpn_comm_bcast(coefs%coef%ostar_wsum_r, size(coefs%coef%ostar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4528</span>    end if
<span class="linenos">4529</span>    if ( coefs%coef%nco2 &gt; 0) then
<span class="linenos">4530</span>      if (mmpi_myid&gt;0) then
<span class="linenos">4531</span>        allocate( coefs%coef%co2star(coefs%coef%nlayers) )
<span class="linenos">4532</span>        allocate( coefs%coef%co2star_r(coefs%coef%nlayers) )
<span class="linenos">4533</span>        allocate( coefs%coef%co2star_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4534</span>      end if
<span class="linenos">4535</span>      call rpn_comm_bcast(coefs%coef%co2star, size(coefs%coef%co2star) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4536</span>      call rpn_comm_bcast(coefs%coef%co2star_r, size(coefs%coef%co2star_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4537</span>      call rpn_comm_bcast(coefs%coef%co2star_wsum_r, size(coefs%coef%co2star_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4538</span>    end if
<span class="linenos">4539</span>    if ( coefs%coef%nn2o &gt; 0) then
<span class="linenos">4540</span>      if (mmpi_myid&gt;0) then
<span class="linenos">4541</span>        allocate( coefs%coef%n2ostar(coefs%coef%nlayers) )
<span class="linenos">4542</span>        allocate( coefs%coef%n2ostar_r(coefs%coef%nlayers) )
<span class="linenos">4543</span>        allocate( coefs%coef%n2ostar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4544</span>        allocate( coefs%coef%n2otstar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4545</span>      end if
<span class="linenos">4546</span>      call rpn_comm_bcast(coefs%coef%n2ostar, size(coefs%coef%n2ostar) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4547</span>      call rpn_comm_bcast(coefs%coef%n2ostar_r, size(coefs%coef%n2ostar_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4548</span>      call rpn_comm_bcast(coefs%coef%n2ostar_wsum_r, size(coefs%coef%n2ostar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4549</span>      call rpn_comm_bcast(coefs%coef%n2otstar_wsum_r, size(coefs%coef%n2otstar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4550</span>    end if
<span class="linenos">4551</span>    if ( coefs%coef%nco &gt; 0) then
<span class="linenos">4552</span>      if (mmpi_myid&gt;0) then
<span class="linenos">4553</span>        allocate( coefs%coef%costar(coefs%coef%nlayers) )
<span class="linenos">4554</span>        allocate( coefs%coef%costar_r(coefs%coef%nlayers) )
<span class="linenos">4555</span>        allocate( coefs%coef%costar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4556</span>        allocate( coefs%coef%cotstar_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4557</span>      end if
<span class="linenos">4558</span>      call rpn_comm_bcast(coefs%coef%costar, size(coefs%coef%costar) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4559</span>      call rpn_comm_bcast(coefs%coef%costar_r, size(coefs%coef%costar_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4560</span>      call rpn_comm_bcast(coefs%coef%costar_wsum_r, size(coefs%coef%costar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4561</span>      call rpn_comm_bcast(coefs%coef%cotstar_wsum_r, size(coefs%coef%cotstar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4562</span>    end if
<span class="linenos">4563</span>    if ( coefs%coef%nch4 &gt; 0) then
<span class="linenos">4564</span>      if (mmpi_myid&gt;0) then
<span class="linenos">4565</span>        allocate( coefs%coef%ch4star(coefs%coef%nlayers) )
<span class="linenos">4566</span>        allocate( coefs%coef%ch4star_r(coefs%coef%nlayers) )
<span class="linenos">4567</span>        allocate( coefs%coef%ch4star_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4568</span>        allocate( coefs%coef%ch4tstar_wsum_r(coefs%coef%nlayers) )
<span class="linenos">4569</span>      end if
<span class="linenos">4570</span>      call rpn_comm_bcast(coefs%coef%ch4star, size(coefs%coef%ch4star) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4571</span>      call rpn_comm_bcast(coefs%coef%ch4star_r, size(coefs%coef%ch4star_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4572</span>      call rpn_comm_bcast(coefs%coef%ch4star_wsum_r, size(coefs%coef%ch4star_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4573</span>      call rpn_comm_bcast(coefs%coef%ch4tstar_wsum_r, size(coefs%coef%ch4tstar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr) 
<span class="linenos">4574</span>    end if
<span class="linenos">4575</span>    if (coefs%coef%nso2 &gt; 0) then
<span class="linenos">4576</span>      if (mmpi_myid&gt;0) then
<span class="linenos">4577</span>        allocate( coefs%coef%so2star(coefs%coef%nlayers) )
<span class="linenos">4578</span>        allocate( coefs%coef%so2star_r(coefs%coef%nlayers) )
<span class="linenos">4579</span>        allocate( coefs%coef%so2star_wsum_r(0:coefs%coef%nlayers) )
<span class="linenos">4580</span>        allocate( coefs%coef%so2tstar_wsum_r(coefs%coef%nlayers) )
<span class="linenos">4581</span>      end if
<span class="linenos">4582</span>      call rpn_comm_bcast(coefs%coef%so2star, size(coefs%coef%so2star) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4583</span>      call rpn_comm_bcast(coefs%coef%so2star_r, size(coefs%coef%so2star_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4584</span>      call rpn_comm_bcast(coefs%coef%so2star_wsum_r, size(coefs%coef%so2star_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4585</span>      call rpn_comm_bcast(coefs%coef%so2tstar_wsum_r, size(coefs%coef%so2tstar_wsum_r) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4586</span>    end if
<span class="linenos">4587</span>    ! Fourth step: channel dependent parameters are extracted according to the channel list and sent to each MPI task
<span class="linenos">4588</span>    coefs%coef%fmv_chn = size( channels )
<span class="linenos">4589</span>
<span class="linenos">4590</span>    if (mmpi_myid == 0) deallocate ( coefs%coef%ff_ori_chn)
<span class="linenos">4591</span>    allocate ( coefs%coef%ff_ori_chn(coefs%coef%fmv_chn) )
<span class="linenos">4592</span>    coefs%coef%ff_ori_chn =  channels
<span class="linenos">4593</span>
<span class="linenos">4594</span>    do i=1,  coefs%coef%fmv_chn
<span class="linenos">4595</span>      loopj2:do j=1, countUniqueChannel
<span class="linenos">4596</span>        if (listAll(j) == channels(i)) then
<span class="linenos">4597</span>          indexchan(i) = j
<span class="linenos">4598</span>          exit loopj2
<span class="linenos">4599</span>        end if
<span class="linenos">4600</span>      end do loopj2
<span class="linenos">4601</span>    end do
<span class="linenos">4602</span>    
<span class="linenos">4603</span>    ! 1D arrays first
<span class="linenos">4604</span>    call extractI41dArray(coefs%coef%pw_val_chn, countUniqueChannel,indexchan)
<span class="linenos">4605</span>    call extractI41dArray(coefs%coef%ff_val_chn, countUniqueChannel,indexchan)
<span class="linenos">4606</span>    call extractR81dArray(coefs%coef%ff_cwn, countUniqueChannel,indexchan)
<span class="linenos">4607</span>    call extractR81dArray(coefs%coef%ff_bco, countUniqueChannel,indexchan)
<span class="linenos">4608</span>    call extractR81dArray(coefs%coef%ff_bcs, countUniqueChannel,indexchan) 
<span class="linenos">4609</span>    call extractR81dArray(coefs%coef%ff_gam, countUniqueChannel,indexchan)
<span class="linenos">4610</span>    call extractI41dArray(coefs%coef%tt_val_chn, countUniqueChannel,indexchan) 
<span class="linenos">4611</span>    call extractR81dArray(coefs%coef%tt_a0, countUniqueChannel,indexchan) 
<span class="linenos">4612</span>    call extractR81dArray(coefs%coef%tt_a1, countUniqueChannel,indexchan) 
<span class="linenos">4613</span>    call extractI41dArray(coefs%coef%ss_val_chn, countUniqueChannel,indexchan) 
<span class="linenos">4614</span>    call extractR81dArray(coefs%coef%ss_solar_spectrum, countUniqueChannel,indexchan)
<span class="linenos">4615</span>    if ( coefs%coef%fmv_model_ver &gt; 9) then
<span class="linenos">4616</span>      call extractR81dArray(coefs%coef%ss_rayleigh_ext, countUniqueChannel,indexchan)
<span class="linenos">4617</span>    end if
<span class="linenos">4618</span>    call extractCmplx81dArray(coefs%coef%woc_waopc_ow, countUniqueChannel, indexchan) 
<span class="linenos">4619</span>    call extractCmplx81dArray(coefs%coef%woc_waopc_fw, countUniqueChannel, indexchan)
<span class="linenos">4620</span>  
<span class="linenos">4621</span>    call extractI41dArray(coefs%coef%fastem_polar, countUniqueChannel,indexchan)
<span class="linenos">4622</span>    call extractR81dArray(coefs%coef%pol_phi, countUniqueChannel,indexchan)
<span class="linenos">4623</span>    call extractR81dArray(coefs%coef%ssirem_a0, countUniqueChannel,indexchan)
<span class="linenos">4624</span>    call extractR81dArray(coefs%coef%ssirem_a1, countUniqueChannel,indexchan)
<span class="linenos">4625</span>    call extractR81dArray(coefs%coef%ssirem_a2, countUniqueChannel,indexchan)
<span class="linenos">4626</span>    call extractR81dArray(coefs%coef%ssirem_xzn1, countUniqueChannel,indexchan)
<span class="linenos">4627</span>    call extractR81dArray(coefs%coef%ssirem_xzn2, countUniqueChannel,indexchan)
<span class="linenos">4628</span>
<span class="linenos">4629</span>    call extractR81dArray(coefs%coef%planck1, countUniqueChannel,indexchan)
<span class="linenos">4630</span>    call extractR81dArray(coefs%coef%planck2, countUniqueChannel,indexchan)
<span class="linenos">4631</span>    if (coefs%coef%id_sensor == sensor_id_mw .or. coefs%coef%id_sensor == sensor_id_po) &amp;
<span class="linenos">4632</span>         call extractR81dArray(coefs%coef%frequency_ghz, countUniqueChannel,indexchan)
<span class="linenos">4633</span>
<span class="linenos">4634</span>    call extractR81dArray(coefs%coef%pmc_pnominal, countUniqueChannel,indexchan)
<span class="linenos">4635</span>    call extractR81dArray(coefs%coef%pmc_ppmc, countUniqueChannel,indexchan)
<span class="linenos">4636</span>    call extractR81dArray(coefs%coef%pol_fac_v, countUniqueChannel,indexchan)
<span class="linenos">4637</span>    call extractR81dArray(coefs%coef%pol_fac_h, countUniqueChannel,indexchan)
<span class="linenos">4638</span>
<span class="linenos">4639</span>    ! 2D arrays
<span class="linenos">4640</span>    call extractR82dArray(coefs%coef%iremis_coef,coefs%coef%iremis_ncoef,countUniqueChannel,indexchan)
<span class="linenos">4641</span>    ! 3D arrays
<span class="linenos">4642</span>    call extractR83dArray(coefs%coef%pmc_coef,coefs%coef%pmc_nlay,countUniqueChannel,coefs%coef%pmc_nvar,indexchan)
<span class="linenos">4643</span>
<span class="linenos">4644</span>    ! then coefficients. It is more complicated with RTTOV12
<span class="linenos">4645</span>    call dispatch_fast_coef(errorStatus, coefs%coef%thermal, coefs%coef%fmv_gas_id, coefs%coef%fmv_coe, coefs%coef%fmv_model_ver, &amp;
<span class="linenos">4646</span>         coefs%coef%nlayers, coefs%coef%fmv_gas)
<span class="linenos">4647</span>    if (coefs%coef%fmv_model_ver &gt; 9) THEN
<span class="linenos">4648</span>      call dispatch_fast_coef(errorStatus, coefs%coef%thermal_corr, coefs%coef%fmv_gas_id, coefs%coef%fmv_ncorr, coefs%coef%fmv_model_ver, &amp;
<span class="linenos">4649</span>           coefs%coef%nlayers, coefs%coef%fmv_gas)
<span class="linenos">4650</span>    end if
<span class="linenos">4651</span>    if (coefs%coef%solarcoef) then
<span class="linenos">4652</span>      call dispatch_fast_coef(errorStatus, coefs%coef%solar, coefs%coef%fmv_gas_id, coefs%coef%fmv_coe, coefs%coef%fmv_model_ver, &amp;
<span class="linenos">4653</span>           coefs%coef%nlayers, coefs%coef%fmv_gas)
<span class="linenos">4654</span>      if (coefs%coef%fmv_model_ver &gt; 9) THEN
<span class="linenos">4655</span>        call dispatch_fast_coef(errorStatus, coefs%coef%solar_corr, coefs%coef%fmv_gas_id, coefs%coef%fmv_ncorr, coefs%coef%fmv_model_ver, &amp;
<span class="linenos">4656</span>             coefs%coef%nlayers, coefs%coef%fmv_gas)
<span class="linenos">4657</span>      end if
<span class="linenos">4658</span>    end if
<span class="linenos">4659</span>
<span class="linenos">4660</span>    if (coefs%coef%nltecoef) then
<span class="linenos">4661</span>
<span class="linenos">4662</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%ncoef, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4663</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%nsol, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4664</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%nsat, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4665</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%nchan, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4666</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%start_chan, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4667</span>
<span class="linenos">4668</span>      allocate(nlte_chans(coefs%coef%fmv_chn)) ! Index of selected channels in nlte_coefs array in the file
<span class="linenos">4669</span>
<span class="linenos">4670</span>      nlte_count = 0  ! Number of NLTE channels being read in
<span class="linenos">4671</span>      nlte_start = 0  ! Index (in input channel list) of first NLTE channel being read in
<span class="linenos">4672</span>      do i = 1, coefs%coef%fmv_chn
<span class="linenos">4673</span>        if (channels(i) &gt;= coefs%coef%nlte_coef%start_chan .and. &amp;
<span class="linenos">4674</span>             channels(i) &lt; coefs%coef%nlte_coef%start_chan + coefs%coef%nlte_coef%nchan) then
<span class="linenos">4675</span>          nlte_count = nlte_count + 1
<span class="linenos">4676</span>          nlte_chans(nlte_count) = channels(i) - coefs%coef%nlte_coef%start_chan + 1
<span class="linenos">4677</span>          if (nlte_count == 1) nlte_start = i
<span class="linenos">4678</span>        end if
<span class="linenos">4679</span>      end do
<span class="linenos">4680</span>
<span class="linenos">4681</span>      coefs%coef%nltecoef = ( nlte_count &gt; 0)
<span class="linenos">4682</span>
<span class="linenos">4683</span>      nlte_file_nchan  = coefs%coef%nlte_coef%nchan
<span class="linenos">4684</span>
<span class="linenos">4685</span>      ! Reset NLTE channel variables according to input channel limit
<span class="linenos">4686</span>      coefs%coef%nlte_coef%start_chan  = nlte_start
<span class="linenos">4687</span>      coefs%coef%nlte_coef%nchan      = nlte_count
<span class="linenos">4688</span>
<span class="linenos">4689</span>      if (mmpi_myid &gt; 0) then
<span class="linenos">4690</span>         allocate (coefs%coef%nlte_coef%sec_sat(coefs%coef%nlte_coef%nsat) )
<span class="linenos">4691</span>         allocate (coefs%coef%nlte_coef%sol_zen_angle(coefs%coef%nlte_coef%nsol) )
<span class="linenos">4692</span>         allocate (coefs%coef%nlte_coef%sat_zen_angle(coefs%coef%nlte_coef%nsat) )
<span class="linenos">4693</span>         allocate (coefs%coef%nlte_coef%cos_sol(coefs%coef%nlte_coef%nsol) )
<span class="linenos">4694</span>      end if
<span class="linenos">4695</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%sec_sat, coefs%coef%nlte_coef%nsat, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4696</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%sol_zen_angle, coefs%coef%nlte_coef%nsol, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4697</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%sat_zen_angle, coefs%coef%nlte_coef%nsat, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4698</span>      call rpn_comm_bcast(coefs%coef%nlte_coef%cos_sol, coefs%coef%nlte_coef%nsol, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4699</span>
<span class="linenos">4700</span>      allocate(bigArray(coefs%coef%nlte_coef%ncoef, coefs%coef%nlte_coef%nsat, &amp;
<span class="linenos">4701</span>           coefs%coef%nlte_coef%nsol, nlte_file_nchan) )
<span class="linenos">4702</span>
<span class="linenos">4703</span>      if (mmpi_myid == 0) then
<span class="linenos">4704</span>         do ichan = 1, nlte_file_nchan
<span class="linenos">4705</span>            do isol = 1, coefs%coef%nlte_coef%nsol
<span class="linenos">4706</span>               do isat = 1, coefs%coef%nlte_coef%nsat
<span class="linenos">4707</span>                  do I=1, coefs%coef%nlte_coef%ncoef
<span class="linenos">4708</span>                     bigArray(i, isat, isol, ichan) = coefs%coef%nlte_coef%coef(i,isat,isol,ichan)
<span class="linenos">4709</span>                  end do
<span class="linenos">4710</span>               end do
<span class="linenos">4711</span>            end do
<span class="linenos">4712</span>         end do
<span class="linenos">4713</span>         deallocate(  coefs%coef%nlte_coef%coef )
<span class="linenos">4714</span>      end if
<span class="linenos">4715</span>
<span class="linenos">4716</span>      call rpn_comm_bcast(bigArray, size(bigArray), &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4717</span>      allocate(coefs%coef%nlte_coef%coef(coefs%coef%nlte_coef%ncoef, coefs%coef%nlte_coef%nsat, &amp;
<span class="linenos">4718</span>           coefs%coef%nlte_coef%nsol, nlte_count))
<span class="linenos">4719</span>      coefs%coef%nlte_coef%coef(:,:,:,:) = bigArray(:,:,:,nlte_chans(1:nlte_count))
<span class="linenos">4720</span>      deallocate(nlte_chans, bigArray)
<span class="linenos">4721</span>       
<span class="linenos">4722</span>    end if
<span class="linenos">4723</span>
<span class="linenos">4724</span>    if (mmpi_myid==0 .and. associated(coefs%coef%bounds) )  deallocate(coefs%coef%bounds)
<span class="linenos">4725</span>  
<span class="linenos">4726</span>    !allocate bounds array to store opdep calculation layer limits
<span class="linenos">4727</span>    !1st dim: upper boundary layer [ub](above which coefs all zeros), lower boundary layer [lb]
<span class="linenos">4728</span>    !4th dim: thermal layer limits, solar layer limits
<span class="linenos">4729</span>    allocate(coefs%coef%bounds(2, coefs%coef%fmv_gas, coefs%coef%fmv_chn, 2))
<span class="linenos">4730</span>    call set_fastcoef_level_bounds(coefs%coef, coefs%coef%thermal, thermal = .true._jplm)
<span class="linenos">4731</span>    ! if the solar_fast_coefficients section is not present then point the solar coefs to the thermal coefs
<span class="linenos">4732</span>    if (coefs%coef%solarcoef) then
<span class="linenos">4733</span>      call set_fastcoef_level_bounds(coefs%coef, coefs%coef%solar, thermal = .false._jplm)
<span class="linenos">4734</span>    else
<span class="linenos">4735</span>      coefs%coef%solar =&gt; coefs%coef%thermal
<span class="linenos">4736</span>      coefs%coef%solar_corr =&gt; coefs%coef%thermal_corr
<span class="linenos">4737</span>      coefs%coef%bounds(:,:,:,2) = coefs%coef%bounds(:,:,:,1)
<span class="linenos">4738</span>    end if
<span class="linenos">4739</span>
<span class="linenos">4740</span>    coefs%coef%ff_val_bc = any(coefs%coef%ff_bco(:) /= 0.0d0) .or. any(coefs%coef%ff_bcs(:) /= 1.d0)
<span class="linenos">4741</span>    coefs%coef%ff_val_gam = any(coefs%coef%ff_gam(:) /= 1.d0)
<span class="linenos">4742</span>
<span class="linenos">4743</span>    ! surface water reflectance for visible/near-ir channels
<span class="linenos">4744</span>    if (any(coefs%coef%ss_val_chn == 2)) then
<span class="linenos">4745</span>      if ( mmpi_myid==0) deallocate(coefs%coef%refl_visnir_ow, &amp;
<span class="linenos">4746</span>           coefs%coef%refl_visnir_fw, stat = errorStatus)
<span class="linenos">4747</span>      allocate(coefs%coef%refl_visnir_ow(coefs%coef%fmv_chn), &amp;
<span class="linenos">4748</span>           coefs%coef%refl_visnir_fw(coefs%coef%fmv_chn), stat = errorStatus)
<span class="linenos">4749</span>      call rttov_refl_water_interp(coefs%coef%ff_cwn, coefs%coef%refl_visnir_ow, coefs%coef%refl_visnir_fw)
<span class="linenos">4750</span>    end if
<span class="linenos">4751</span>
<span class="linenos">4752</span>    if (coefs%coef%pmc_shift .and. mmpi_myid &gt; 0) then
<span class="linenos">4753</span>      allocate(coefs%coef%pmc_ppmc(coefs%coef%fmv_chn), stat = errorStatus)
<span class="linenos">4754</span>    else
<span class="linenos">4755</span>      nullify(coefs%coef%pmc_pnominal, coefs%coef%pmc_coef, coefs%coef%pmc_ppmc)
<span class="linenos">4756</span>    end if
<span class="linenos">4757</span>
<span class="linenos">4758</span>    contains
<span class="linenos">4759</span>
<span class="linenos">4760</span>    subroutine nullify_gas_coef_pointers(fast_coef)
<span class="linenos">4761</span>      type(rttov_fast_coef), intent(inout) :: fast_coef
<span class="linenos">4762</span>      nullify (fast_coef%mixedgas,&amp;
<span class="linenos">4763</span>           fast_coef%watervapour, &amp;
<span class="linenos">4764</span>           fast_coef%ozone,       &amp;
<span class="linenos">4765</span>           fast_coef%wvcont,      &amp;
<span class="linenos">4766</span>           fast_coef%co2,         &amp;
<span class="linenos">4767</span>           fast_coef%n2o,         &amp;
<span class="linenos">4768</span>           fast_coef%co,          &amp;
<span class="linenos">4769</span>           fast_coef%ch4,         &amp;
<span class="linenos">4770</span>           fast_coef%so2)
<span class="linenos">4771</span>    end subroutine nullify_gas_coef_pointers
<span class="linenos">4772</span>
<span class="linenos">4773</span>    subroutine dispatch_fast_coef(err, fast_coef, gas_ids, ncoefs, version, nlayers, ngas)
<span class="linenos">4774</span>      integer,                        intent(out)   :: err
<span class="linenos">4775</span>      type(rttov_fast_coef), pointer, intent(inout) :: fast_coef(:)
<span class="linenos">4776</span>      integer(jpim),         intent(in)             :: gas_ids(:)
<span class="linenos">4777</span>      integer(jpim),         intent(in)             :: ncoefs(:)
<span class="linenos">4778</span>      integer(jpim),         intent(in)             :: version
<span class="linenos">4779</span>      integer(jpim),         intent(in)             :: nlayers
<span class="linenos">4780</span>      integer(jpim),         intent(in)             :: ngas
<span class="linenos">4781</span>
<span class="linenos">4782</span>      integer(jpim) :: channelIndex, gasIndex, layerIndex, coefIndex
<span class="linenos">4783</span>      real(8), allocatable :: bigArray(:,:,:,:)
<span class="linenos">4784</span>      logical :: allocated0
<span class="linenos">4785</span>
<span class="linenos">4786</span>      allocate(bigArray(countUniqueChannel,maxval(ncoefs),ngas,nlayers), stat=err )
<span class="linenos">4787</span>      bigArray(:,:,:,:) = 0.0d0
<span class="linenos">4788</span>
<span class="linenos">4789</span>      if (mmpi_myid &gt; 0) then
<span class="linenos">4790</span>        allocate (fast_coef(countUniqueChannel) )
<span class="linenos">4791</span>        do channelIndex = 1, countUniqueChannel
<span class="linenos">4792</span>          allocate(fast_coef(channelIndex)%gasarray(ngas) )
<span class="linenos">4793</span>          do gasIndex = 1, ngas
<span class="linenos">4794</span>            allocate (fast_coef(channelIndex)%gasarray(gasIndex)%coef( ncoefs(gasIndex), nlayers) )
<span class="linenos">4795</span>          end do
<span class="linenos">4796</span>        end do
<span class="linenos">4797</span>      end if
<span class="linenos">4798</span>
<span class="linenos">4799</span>      do channelIndex = 1, countUniqueChannel
<span class="linenos">4800</span>        do gasIndex = 1, ngas
<span class="linenos">4801</span>          call broadcastR82dArray( fast_coef(channelIndex)%gasarray(gasIndex)%coef )
<span class="linenos">4802</span>        end do
<span class="linenos">4803</span>      end do
<span class="linenos">4804</span>
<span class="linenos">4805</span>      do channelIndex = 1, countUniqueChannel  
<span class="linenos">4806</span>        do gasIndex = 1, ngas
<span class="linenos">4807</span>          associated0 = associated( fast_coef(channelIndex)%gasarray(gasIndex)%coef )
<span class="linenos">4808</span>          call rpn_comm_bcast(associated0, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4809</span>          if (associated0) then
<span class="linenos">4810</span>            do layerIndex=1, nlayers
<span class="linenos">4811</span>              do coefIndex=1, ncoefs(gasIndex)
<span class="linenos">4812</span>                bigArray(channelIndex,coefIndex,gasIndex,layerIndex) = fast_coef(channelIndex)%gasarray(gasIndex)%coef(coefIndex,layerIndex)
<span class="linenos">4813</span>              end do
<span class="linenos">4814</span>            end do
<span class="linenos">4815</span>          end if
<span class="linenos">4816</span>        end do
<span class="linenos">4817</span>      end do
<span class="linenos">4818</span>
<span class="linenos">4819</span>      do channelIndex = 1, countUniqueChannel
<span class="linenos">4820</span>        do gasIndex = 1, ngas
<span class="linenos">4821</span>          associated0 = associated(fast_coef(channelIndex)%gasarray(gasIndex)%coef)
<span class="linenos">4822</span>          if (associated0) deallocate(fast_coef(channelIndex)%gasarray(gasIndex)%coef)
<span class="linenos">4823</span>        end do
<span class="linenos">4824</span>        deallocate(fast_coef(channelIndex)%gasarray)
<span class="linenos">4825</span>      end do
<span class="linenos">4826</span>      deallocate(fast_coef)
<span class="linenos">4827</span>      allocate (fast_coef(coefs%coef%fmv_chn) )
<span class="linenos">4828</span>      do channelIndex = 1, coefs%coef%fmv_chn
<span class="linenos">4829</span>        allocate (fast_coef(channelIndex)%gasarray(ngas) )
<span class="linenos">4830</span>        call nullify_gas_coef_pointers( fast_coef(channelIndex) )
<span class="linenos">4831</span>        do gasIndex = 1, ngas
<span class="linenos">4832</span>          if (any( bigArray(indexchan(channelIndex),:,gasIndex,:) /= 0.) ) then
<span class="linenos">4833</span>            allocate (fast_coef(channelIndex)%gasarray(gasIndex)%coef( ncoefs(gasIndex), nlayers) )
<span class="linenos">4834</span>            do layerIndex=1, nlayers
<span class="linenos">4835</span>              do coefIndex=1, ncoefs(gasIndex)
<span class="linenos">4836</span>                fast_coef(channelIndex)%gasarray(gasIndex)%coef(coefIndex,layerIndex)  = bigArray(indexchan(channelIndex),coefIndex,gasIndex,layerIndex)
<span class="linenos">4837</span>              end do
<span class="linenos">4838</span>            end do
<span class="linenos">4839</span>          end if
<span class="linenos">4840</span>          call set_pointers(fast_coef(channelIndex), gasIndex, gas_ids(gasIndex))
<span class="linenos">4841</span>        end do
<span class="linenos">4842</span>      end do
<span class="linenos">4843</span>
<span class="linenos">4844</span>      deallocate(bigArray, stat=err )
<span class="linenos">4845</span>
<span class="linenos">4846</span>    end subroutine dispatch_fast_coef
<span class="linenos">4847</span>
<span class="linenos">4848</span>  end subroutine tvs_rttov_read_coefs
<span class="linenos">4849</span>
<span class="linenos">4850</span>  subroutine extractI41dArray(array,oldSize,index)
<span class="linenos">4851</span>    implicit none
<span class="linenos">4852</span>    integer, pointer :: array(:)
<span class="linenos">4853</span>    integer, intent(in) :: oldSize
<span class="linenos">4854</span>    integer, intent(in) :: index(:)
<span class="linenos">4855</span>    ! Locals
<span class="linenos">4856</span>    integer :: newSize, tmpI41d(oldSize), ierr, trueSize
<span class="linenos">4857</span>
<span class="linenos">4858</span>    if (mmpi_myid == 0) then
<span class="linenos">4859</span>      if (associated(array)) then
<span class="linenos">4860</span>        trueSize = size(array)
<span class="linenos">4861</span>      else
<span class="linenos">4862</span>        trueSize = 0
<span class="linenos">4863</span>      end if
<span class="linenos">4864</span>    end if
<span class="linenos">4865</span>    ierr = 0
<span class="linenos">4866</span>    call rpn_comm_bcast(trueSize, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4867</span>    if (ierr /= 0) then
<span class="linenos">4868</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, trueSize
<span class="linenos">4869</span>      call utl_abort(&#39;extractI41dArray&#39;)
<span class="linenos">4870</span>    end if
<span class="linenos">4871</span>    if (trueSize &lt; 1) return
<span class="linenos">4872</span>    
<span class="linenos">4873</span>    if (trueSize /= oldSize) then
<span class="linenos">4874</span>      write(*,*) &#39;extractI41dArray: should not happen &#39;, trueSize, oldSize
<span class="linenos">4875</span>    end if
<span class="linenos">4876</span>    
<span class="linenos">4877</span>    newSize = size( index )
<span class="linenos">4878</span>
<span class="linenos">4879</span>    if (mmpi_myid &gt; 0) allocate( array(oldSize))
<span class="linenos">4880</span>    ierr = 0
<span class="linenos">4881</span>    call rpn_comm_bcast(array, oldSize, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4882</span>    if (ierr /= 0) then
<span class="linenos">4883</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, array(:)
<span class="linenos">4884</span>      call utl_abort(&#39;extractI41dArray&#39;)
<span class="linenos">4885</span>    end if
<span class="linenos">4886</span>    tmpI41d = array
<span class="linenos">4887</span>    deallocate( array )
<span class="linenos">4888</span>    allocate( array(newSize))
<span class="linenos">4889</span>    array( : ) =  tmpI41d( index(:) )
<span class="linenos">4890</span>  end subroutine extractI41dArray
<span class="linenos">4891</span>  
<span class="linenos">4892</span>  subroutine extractR81dArray(array,oldSize,index)
<span class="linenos">4893</span>    implicit none
<span class="linenos">4894</span>    real(8), pointer :: array(:)
<span class="linenos">4895</span>    integer, intent(in) :: oldSize, index(:)
<span class="linenos">4896</span>    !Locals
<span class="linenos">4897</span>    integer :: newSize, ierr, trueSize
<span class="linenos">4898</span>    real(8) :: tmpR81d(oldSize)
<span class="linenos">4899</span>    
<span class="linenos">4900</span>    if (mmpi_myid == 0) then
<span class="linenos">4901</span>      if (associated(array)) then
<span class="linenos">4902</span>        trueSize = size(array)
<span class="linenos">4903</span>      else
<span class="linenos">4904</span>        trueSize = 0
<span class="linenos">4905</span>      end if
<span class="linenos">4906</span>    end if
<span class="linenos">4907</span>    ierr = 0
<span class="linenos">4908</span>    call rpn_comm_bcast(trueSize, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4909</span>    if (ierr /= 0) then
<span class="linenos">4910</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, trueSize
<span class="linenos">4911</span>      call utl_abort(&#39;extractR81dArray&#39;)
<span class="linenos">4912</span>    end if
<span class="linenos">4913</span>    if (trueSize &lt; 1) return
<span class="linenos">4914</span>    
<span class="linenos">4915</span>    if (trueSize /= oldSize) then
<span class="linenos">4916</span>      write(*,*) &#39;extractR81dArray: should not happen &#39;, trueSize, oldSize
<span class="linenos">4917</span>    end if
<span class="linenos">4918</span>    
<span class="linenos">4919</span>    newSize = size( index )
<span class="linenos">4920</span>
<span class="linenos">4921</span>    if (mmpi_myid &gt; 0) allocate( array(oldSize))
<span class="linenos">4922</span>    ierr = 0
<span class="linenos">4923</span>    call rpn_comm_bcast(array, oldSize, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4924</span>    if (ierr /= 0) then
<span class="linenos">4925</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, array(:)
<span class="linenos">4926</span>      call utl_abort(&#39;extractR81dArray&#39;)
<span class="linenos">4927</span>    end if
<span class="linenos">4928</span>    tmpR81d = array
<span class="linenos">4929</span>    deallocate( array )
<span class="linenos">4930</span>    allocate( array(newSize))
<span class="linenos">4931</span>    array( : ) =  tmpR81d( index(:) )
<span class="linenos">4932</span>  end subroutine extractR81dArray
<span class="linenos">4933</span>
<span class="linenos">4934</span>  subroutine extractR82dArray(array,oldSize1,oldSize2,index)
<span class="linenos">4935</span>    !second dimension is for channels
<span class="linenos">4936</span>    implicit none
<span class="linenos">4937</span>    real(8), pointer :: array(:,:)
<span class="linenos">4938</span>    integer, intent(in) :: oldSize1, oldSize2,index(:)
<span class="linenos">4939</span>    !Locals
<span class="linenos">4940</span>    integer :: newSize, ierr, trueSize,i
<span class="linenos">4941</span>    real(8) :: tmpR82d(oldSize1,oldsize2)
<span class="linenos">4942</span>    
<span class="linenos">4943</span>    if (mmpi_myid == 0) then
<span class="linenos">4944</span>      if (associated(array)) then
<span class="linenos">4945</span>        trueSize = size(array)
<span class="linenos">4946</span>      else
<span class="linenos">4947</span>        trueSize = 0
<span class="linenos">4948</span>      end if
<span class="linenos">4949</span>    end if
<span class="linenos">4950</span>    ierr = 0
<span class="linenos">4951</span>    call rpn_comm_bcast(trueSize, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4952</span>    if (ierr /= 0) then
<span class="linenos">4953</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, trueSize
<span class="linenos">4954</span>      call utl_abort(&#39;extractR82dArray&#39;)
<span class="linenos">4955</span>    end if
<span class="linenos">4956</span>    if (trueSize &lt; 1) return
<span class="linenos">4957</span>    
<span class="linenos">4958</span>    if (trueSize /= oldSize1 * oldSize2) then
<span class="linenos">4959</span>      write(*,*) &#39;extractR82dArray: should not happen &#39;, trueSize, oldSize1, oldSize2
<span class="linenos">4960</span>    end if
<span class="linenos">4961</span>
<span class="linenos">4962</span>    newSize = size( index )
<span class="linenos">4963</span>
<span class="linenos">4964</span>    if (mmpi_myid &gt; 0) allocate( array(oldSize1,oldSize2) )
<span class="linenos">4965</span>    ierr = 0
<span class="linenos">4966</span>    call rpn_comm_bcast(array, oldSize1*oldSize2, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4967</span>    if (ierr /= 0) then
<span class="linenos">4968</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, array(:,:)
<span class="linenos">4969</span>      call utl_abort(&#39;extractR82dArray&#39;)
<span class="linenos">4970</span>    end if
<span class="linenos">4971</span>    tmpR82d = array
<span class="linenos">4972</span>    deallocate( array )
<span class="linenos">4973</span>    allocate( array(oldSize1,newSize))
<span class="linenos">4974</span>    do i=1, newSize
<span class="linenos">4975</span>      array( :,i) =  tmpR82d(:, index(i) )
<span class="linenos">4976</span>    end do
<span class="linenos">4977</span>  end subroutine extractR82dArray
<span class="linenos">4978</span>
<span class="linenos">4979</span>  subroutine extractR83dArray(array,oldSize1,oldSize2,oldSize3,index)
<span class="linenos">4980</span>    !second dimension is for channels
<span class="linenos">4981</span>    implicit none
<span class="linenos">4982</span>    real(8), pointer :: array(:,:,:)
<span class="linenos">4983</span>    integer, intent(in) :: oldSize1, oldSize2,oldSize3,index(:)
<span class="linenos">4984</span>    !Locals
<span class="linenos">4985</span>    integer :: newSize, ierr, trueSize,i
<span class="linenos">4986</span>    real(8) :: tmpR83d(oldSize1,oldSize2,oldSize3)
<span class="linenos">4987</span>    
<span class="linenos">4988</span>    if (mmpi_myid == 0) then
<span class="linenos">4989</span>      if (associated(array)) then
<span class="linenos">4990</span>        trueSize = size(array)
<span class="linenos">4991</span>      else
<span class="linenos">4992</span>        trueSize = 0
<span class="linenos">4993</span>      end if
<span class="linenos">4994</span>    end if
<span class="linenos">4995</span>    ierr = 0
<span class="linenos">4996</span>    call rpn_comm_bcast(trueSize, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">4997</span>    if (ierr /= 0) then
<span class="linenos">4998</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, trueSize
<span class="linenos">4999</span>      call utl_abort(&#39;extractR83dArray&#39;)
<span class="linenos">5000</span>    end if
<span class="linenos">5001</span>    if (trueSize &lt; 1) return
<span class="linenos">5002</span>
<span class="linenos">5003</span>    if (trueSize /= oldSize1 * oldSize2 * oldSize3) then
<span class="linenos">5004</span>      write(*,*) &#39;extractR83dArray: should not happen &#39;, trueSize, oldSize1, oldSize2, oldSize3
<span class="linenos">5005</span>    end if
<span class="linenos">5006</span>  
<span class="linenos">5007</span>    newSize = size( index )
<span class="linenos">5008</span>  
<span class="linenos">5009</span>    if (mmpi_myid &gt; 0) allocate( array(oldSize1,oldSize2, oldSIze3) )
<span class="linenos">5010</span>    ierr = 0
<span class="linenos">5011</span>    call rpn_comm_bcast(array, oldSize1*oldSize2*oldSize3, &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5012</span>    if (ierr /= 0) then
<span class="linenos">5013</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, array(:,:,:)
<span class="linenos">5014</span>      call utl_abort(&#39;extractR83dArray&#39;)
<span class="linenos">5015</span>    end if
<span class="linenos">5016</span>    tmpR83d = array
<span class="linenos">5017</span>    deallocate( array )
<span class="linenos">5018</span>    allocate( array(oldSize1,newSize,oldSize3))
<span class="linenos">5019</span>    do i=1, newSize
<span class="linenos">5020</span>      array( :,i,:) =  tmpR83d(:, index(i),: )
<span class="linenos">5021</span>    end do
<span class="linenos">5022</span>  end subroutine extractR83dArray
<span class="linenos">5023</span>
<span class="linenos">5024</span>  subroutine extractCmplx81dArray(array,oldSize,index)
<span class="linenos">5025</span>    implicit none
<span class="linenos">5026</span>    complex(kind=8), pointer :: array(:)
<span class="linenos">5027</span>    integer, intent(in) :: oldSize, index(:)
<span class="linenos">5028</span>    !Locals
<span class="linenos">5029</span>    integer :: newSize, ierr, trueSize
<span class="linenos">5030</span>    complex(kind=8) :: tmpCx81d(oldSize)
<span class="linenos">5031</span>
<span class="linenos">5032</span>    if (mmpi_myid == 0) then
<span class="linenos">5033</span>      if (associated(array)) then
<span class="linenos">5034</span>        trueSize = size(array)
<span class="linenos">5035</span>      else
<span class="linenos">5036</span>        trueSize = 0
<span class="linenos">5037</span>      end if
<span class="linenos">5038</span>    end if
<span class="linenos">5039</span>    ierr = 0
<span class="linenos">5040</span>    call rpn_comm_bcast(trueSize, 1, &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5041</span>    if (ierr /= 0) then
<span class="linenos">5042</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, trueSize
<span class="linenos">5043</span>      call utl_abort(&#39;extractCmplx81dArray&#39;)
<span class="linenos">5044</span>    end if
<span class="linenos">5045</span>    if (trueSize &lt; 1) return
<span class="linenos">5046</span>  
<span class="linenos">5047</span>    if (trueSize /= oldSize) then
<span class="linenos">5048</span>      write(*,*) &#39;extractCmplx81dArray: should not happen &#39;, trueSize, oldSize
<span class="linenos">5049</span>    end if
<span class="linenos">5050</span>
<span class="linenos">5051</span>    newSize = size( index )
<span class="linenos">5052</span>    
<span class="linenos">5053</span>    if (mmpi_myid &gt; 0) allocate( array(oldSize))
<span class="linenos">5054</span>    ierr = 0
<span class="linenos">5055</span>    call rpn_comm_bcast(array, oldSize, &#39;MPI_COMPLEX8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5056</span>    if (ierr /= 0) then
<span class="linenos">5057</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, array(:)
<span class="linenos">5058</span>      call utl_abort(&#39;extractCmplx81dArray&#39;)
<span class="linenos">5059</span>    end if
<span class="linenos">5060</span>    tmpCx81d = array
<span class="linenos">5061</span>    deallocate( array )
<span class="linenos">5062</span>    allocate( array(newSize))
<span class="linenos">5063</span>    array( : ) =  tmpCx81d( index(:) )
<span class="linenos">5064</span>  end subroutine extractCmplx81dArray
<span class="linenos">5065</span>  
<span class="linenos">5066</span>
<span class="linenos">5067</span>  subroutine broadcastR82dArray(array)
<span class="linenos">5068</span>    implicit none
<span class="linenos">5069</span>    real(kind=8), pointer :: array(:,:)
<span class="linenos">5070</span>    !Locals
<span class="linenos">5071</span>    logical :: associated0
<span class="linenos">5072</span>    integer :: ierr
<span class="linenos">5073</span>
<span class="linenos">5074</span>    associated0 = associated(array)
<span class="linenos">5075</span>    call rpn_comm_bcast(associated0, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5076</span>    if (ierr /= 0) then
<span class="linenos">5077</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, associated0
<span class="linenos">5078</span>      call utl_abort(&#39;broadcastR82dArray&#39;)
<span class="linenos">5079</span>    end if
<span class="linenos">5080</span>    ierr = 0
<span class="linenos">5081</span>    if (associated0) call rpn_comm_bcast(array, size(array) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5082</span>    if (ierr /= 0) then
<span class="linenos">5083</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, size(array,dim=1), size(array,dim=2)
<span class="linenos">5084</span>      call utl_abort(&#39;broadcastR82dArray&#39;)
<span class="linenos">5085</span>    end if
<span class="linenos">5086</span>   
<span class="linenos">5087</span>  end subroutine broadcastR82dArray
<span class="linenos">5088</span>
<span class="linenos">5089</span>  subroutine broadcastR81dArray(array)
<span class="linenos">5090</span>    implicit none
<span class="linenos">5091</span>    real(kind=8), pointer :: array(:)
<span class="linenos">5092</span>    !Locals
<span class="linenos">5093</span>    logical :: associated0
<span class="linenos">5094</span>    integer :: ierr
<span class="linenos">5095</span>    
<span class="linenos">5096</span>    associated0 = associated(array)
<span class="linenos">5097</span>    call rpn_comm_bcast(associated0, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5098</span>    if (ierr/=0) then
<span class="linenos">5099</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, associated0
<span class="linenos">5100</span>      call utl_abort(&#39;broadcastR81dArray&#39;)
<span class="linenos">5101</span>    end if
<span class="linenos">5102</span>    ierr = 0
<span class="linenos">5103</span>    if (associated0) call rpn_comm_bcast(array, size(array) , &#39;MPI_REAL8&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5104</span>    if (ierr/=0) then
<span class="linenos">5105</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, size(array)
<span class="linenos">5106</span>      call utl_abort(&#39;broadcastR81dArray&#39;)
<span class="linenos">5107</span>    end if
<span class="linenos">5108</span>    
<span class="linenos">5109</span>  end subroutine broadcastR81dArray
<span class="linenos">5110</span>
<span class="linenos">5111</span>
<span class="linenos">5112</span>  subroutine broadcastI41dArray(array)
<span class="linenos">5113</span>    implicit none
<span class="linenos">5114</span>    integer(kind=4), pointer :: array(:)
<span class="linenos">5115</span>    !Locals
<span class="linenos">5116</span>    logical :: associated0
<span class="linenos">5117</span>    integer :: ierr
<span class="linenos">5118</span>
<span class="linenos">5119</span>    associated0 = associated(array)
<span class="linenos">5120</span>    call rpn_comm_bcast(associated0, 1, &#39;MPI_LOGICAL&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5121</span>    if (ierr/=0) then
<span class="linenos">5122</span>      write(*,*) &#39;error 1 in rpn_comm_bcast&#39;, ierr, associated0
<span class="linenos">5123</span>      call utl_abort(&#39;broadcastI41dArray&#39;)
<span class="linenos">5124</span>    end if
<span class="linenos">5125</span>    ierr = 0
<span class="linenos">5126</span>    if (associated0) call rpn_comm_bcast(array, size(array) , &#39;MPI_INTEGER&#39;, 0, &#39;GRID&#39;, ierr)
<span class="linenos">5127</span>    if (ierr/=0) then
<span class="linenos">5128</span>      write(*,*) &#39;error 2 in rpn_comm_bcast&#39;, ierr, size(array)
<span class="linenos">5129</span>      call utl_abort(&#39;broadcastI41dArray&#39;)
<span class="linenos">5130</span>    end if
<span class="linenos">5131</span>
<span class="linenos">5132</span>  end subroutine broadcastI41dArray
<span class="linenos">5133</span>
<span class="linenos">5134</span>  !--------------------------------------------------------------------------
<span class="linenos">5135</span>  !   tvs_printDetailledOmfStatistics
<span class="linenos">5136</span>  !--------------------------------------------------------------------------
<span class="linenos">5137</span>  subroutine tvs_printDetailledOmfStatistics(obsSpaceData)
<span class="linenos">5138</span>    !
<span class="linenos">5139</span>    !:Purpose: Print channel by channnel O-F statistics fro radiances
<span class="linenos">5140</span>    !
<span class="linenos">5141</span>    implicit none
<span class="linenos">5142</span>
<span class="linenos">5143</span>    !Arguments:
<span class="linenos">5144</span>    type(struct_obs), intent(inout) :: obsSpaceData! obsSpacaData structure
<span class="linenos">5145</span>
<span class="linenos">5146</span>    ! Locals:
<span class="linenos">5147</span>    integer :: sensorIndex, channelIndex, tovsIndex
<span class="linenos">5148</span>    real(8) zjoch  (0:tvs_maxChannelNumber,tvs_maxNumberOfSensors)
<span class="linenos">5149</span>    real(8) zavgnrm(0:tvs_maxChannelNumber,tvs_maxNumberOfSensors)
<span class="linenos">5150</span>    real(pre_obsReal) :: zdtb, obsPRM
<span class="linenos">5151</span>    integer nchanperline, startChannel, endChannel
<span class="linenos">5152</span>    integer count, incanjo
<span class="linenos">5153</span>    integer idatyp
<span class="linenos">5154</span>    integer rttovChannelNumber, bufrChannelNumber
<span class="linenos">5155</span>    integer inobsch(0:tvs_maxChannelNumber,tvs_maxNumberOfSensors)
<span class="linenos">5156</span>    integer lcanjo(tvs_maxChannelNumber)
<span class="linenos">5157</span>    integer :: headerIndex, bodyIndex
<span class="linenos">5158</span>    real(8) :: sigmaObs
<span class="linenos">5159</span>
<span class="linenos">5160</span>    write(*,*) &#39;tvs_printDetailledOmfStatistics: Starting&#39;
<span class="linenos">5161</span>
<span class="linenos">5162</span>    if ( tvs_nobtov == 0) return    ! exit if there are not tovs data
<span class="linenos">5163</span>
<span class="linenos">5164</span>    ! 1.  Computation of (hx - z)/sigma for tovs data only
<span class="linenos">5165</span>
<span class="linenos">5166</span>    count  = 0
<span class="linenos">5167</span>    inobsch(:,:) = 0
<span class="linenos">5168</span>    zjoch  (:,:) = 0.0d0
<span class="linenos">5169</span>    zavgnrm(:,:) = 0.0d0
<span class="linenos">5170</span>
<span class="linenos">5171</span>    ! loop over all header indices of the &#39;TO&#39; family
<span class="linenos">5172</span>    call obs_set_current_header_list(obsSpaceData,&#39;TO&#39;)
<span class="linenos">5173</span>    HEADER: do
<span class="linenos">5174</span>      headerIndex = obs_getHeaderIndex(obsSpaceData)
<span class="linenos">5175</span>      if (headerIndex &lt; 0) exit HEADER
<span class="linenos">5176</span>
<span class="linenos">5177</span>      ! 1.1  Extract general information for this observation point
<span class="linenos">5178</span>      !      ------------------------------------------------------
<span class="linenos">5179</span>
<span class="linenos">5180</span>      ! process only radiance data to be assimilated?
<span class="linenos">5181</span>      idatyp = obs_headElem_i(obsSpaceData,OBS_ITY,headerIndex)
<span class="linenos">5182</span>      if ( .not. tvs_isIdBurpTovs(idatyp) ) then
<span class="linenos">5183</span>        write(*,*) &#39;tvs_printDetailledOmfStatistics: warning unknown radiance codtyp present check NAMTOVSINST&#39;, idatyp
<span class="linenos">5184</span>        cycle HEADER
<span class="linenos">5185</span>      end if
<span class="linenos">5186</span>      tovsIndex = tvs_tovsIndex(headerIndex)
<span class="linenos">5187</span>      if ( tovsIndex == -1 ) cycle HEADER
<span class="linenos">5188</span>       
<span class="linenos">5189</span>      sensorIndex = tvs_lsensor(tovsIndex)
<span class="linenos">5190</span>
<span class="linenos">5191</span>      ! Set the body list
<span class="linenos">5192</span>      ! (&amp; start at the beginning of the list)
<span class="linenos">5193</span>      call obs_set_current_body_list(obsSpaceData, headerIndex)
<span class="linenos">5194</span>      count = 0
<span class="linenos">5195</span>      BODY: do 
<span class="linenos">5196</span>        bodyIndex = obs_getBodyIndex(obsSpaceData)
<span class="linenos">5197</span>        if (bodyIndex &lt; 0) exit BODY
<span class="linenos">5198</span>        
<span class="linenos">5199</span>        ! Only consider if flagged for assimilation
<span class="linenos">5200</span>        if ( obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex) /= obs_assimilated ) cycle BODY                
<span class="linenos">5201</span>
<span class="linenos">5202</span>        call tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos">5203</span>                                            rttovChannelNumber, channelIndex )
<span class="linenos">5204</span>        bufrChannelNumber = rttovChannelNumber + tvs_channelOffset(sensorIndex)
<span class="linenos">5205</span>        if ( channelIndex == 0 ) then
<span class="linenos">5206</span>          write(*,&#39;(A)&#39;) &#39;  tvs_printDetailledOmfStatistics: error with channel number&#39;
<span class="linenos">5207</span>          call utl_abort(&#39; tvs_printDetailledOmfStatistics&#39;)
<span class="linenos">5208</span>        end if
<span class="linenos">5209</span>
<span class="linenos">5210</span>        zdtb = obs_bodyElem_r(obsSpaceData,OBS_PRM,bodyIndex) - &amp;
<span class="linenos">5211</span>             tvs_radiance (tovsIndex) % bt(channelIndex)
<span class="linenos">5212</span>        if ( tvs_debug ) then
<span class="linenos">5213</span>          obsPRM = obs_bodyElem_r(obsSpaceData,OBS_PRM,bodyIndex)
<span class="linenos">5214</span>          write(*,&#39;(a,i4,2f8.2,f6.2)&#39;) &#39; rttovChannelNumber,sim,obs,diff= &#39;, &amp;
<span class="linenos">5215</span>               rttovChannelNumber,  tvs_radiance (tovsIndex) % bt(channelIndex), &amp;
<span class="linenos">5216</span>               obsPRM, -zdtb
<span class="linenos">5217</span>        end if
<span class="linenos">5218</span>
<span class="linenos">5219</span>        sigmaObs = obs_bodyElem_r(obsSpaceData,OBS_OER,bodyIndex)
<span class="linenos">5220</span>
<span class="linenos">5221</span>        if ( sigmaObs == MPC_missingValue_R8) cycle body
<span class="linenos">5222</span>
<span class="linenos">5223</span>        count = count + 1
<span class="linenos">5224</span>        inobsch(bufrChannelNumber,sensorIndex) = inobsch(bufrChannelNumber,sensorIndex) + 1
<span class="linenos">5225</span>        zjoch(bufrChannelNumber,sensorIndex)   = &amp;
<span class="linenos">5226</span>             zjoch(bufrChannelNumber,sensorIndex) &amp;
<span class="linenos">5227</span>             + zdtb * zdtb / (sigmaObs * sigmaObs)
<span class="linenos">5228</span>        zavgnrm(bufrChannelNumber,sensorIndex)   = &amp;
<span class="linenos">5229</span>             zavgnrm(bufrChannelNumber,sensorIndex) - &amp;
<span class="linenos">5230</span>             zdtb / sigmaObs
<span class="linenos">5231</span>      end do BODY
<span class="linenos">5232</span>
<span class="linenos">5233</span>    end do HEADER
<span class="linenos">5234</span>
<span class="linenos">5235</span>    !   2.  Close up, print summary
<span class="linenos">5236</span>    !   .   -----------------------
<span class="linenos">5237</span>
<span class="linenos">5238</span>
<span class="linenos">5239</span>    ! printout of mean jo and normalized average for each sensor.
<span class="linenos">5240</span>
<span class="linenos">5241</span>    nchanperline = 18
<span class="linenos">5242</span>    if ( count &gt; 0 ) then
<span class="linenos">5243</span>      write(*,*)
<span class="linenos">5244</span>      write(*,*)
<span class="linenos">5245</span>      write(*,&#39;(10x,A)&#39;) &#39;- tvs_printDetailledOmfStatistics: computing jo and residuals to tovs  observations&#39;
<span class="linenos">5246</span>
<span class="linenos">5247</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos">5248</span>        inobsch(0,sensorIndex) = sum ( inobsch(1:,sensorIndex) )
<span class="linenos">5249</span>        zjoch(0,sensorIndex) = sum( zjoch(1:,sensorIndex) )
<span class="linenos">5250</span>        zavgnrm(0,sensorIndex) = sum( zavgnrm(1:,sensorIndex) )
<span class="linenos">5251</span>      end do
<span class="linenos">5252</span>
<span class="linenos">5253</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos">5254</span>        incanjo = 0
<span class="linenos">5255</span>        do channelIndex = 0, tvs_maxChannelNumber
<span class="linenos">5256</span>          if ( inobsch(channelIndex, sensorIndex) /= 0 ) then
<span class="linenos">5257</span>            incanjo = incanjo + 1
<span class="linenos">5258</span>            lcanjo(incanjo) = channelIndex
<span class="linenos">5259</span>          end if
<span class="linenos">5260</span>        end do
<span class="linenos">5261</span>        if ( incanjo /= 0 ) then
<span class="linenos">5262</span>          write(*,&quot;(/1x,&#39;sensor #&#39;,i2,&#39;. platform: &#39;,a, &#39;instrument: &#39;,a)&quot;) &amp;
<span class="linenos">5263</span>               sensorIndex, tvs_satelliteName(sensorIndex), tvs_instrumentName(sensorIndex)
<span class="linenos">5264</span>          do startChannel = 1, incanjo, nchanperline
<span class="linenos">5265</span>            endChannel = min(startChannel + nchanperline - 1 , incanjo)
<span class="linenos">5266</span>            if ( startChannel == 1 ) then
<span class="linenos">5267</span>              write(*,&quot;(1x,&#39;channel&#39;,t13,&#39;   all&#39;,17i6)&quot;) (lcanjo(channelIndex), channelIndex=startChannel+1, endChannel)
<span class="linenos">5268</span>            else
<span class="linenos">5269</span>              write(*,&quot;(1x,&#39;channel&#39;,t13,18i6)&quot;) (lcanjo(channelIndex), channelIndex=startChannel, endChannel)
<span class="linenos">5270</span>            end if
<span class="linenos">5271</span>            write(*,&quot;(1x,&#39;no. obs.&#39;,t13,18i6)&quot;) (inobsch(lcanjo(channelIndex),sensorIndex), channelIndex=startChannel, endChannel)
<span class="linenos">5272</span>            write(*,&quot;(1x,&#39;mean jo&#39;,t13,18f6.2)&quot;) &amp;
<span class="linenos">5273</span>                 (zjoch(lcanjo(channelIndex),sensorIndex)/max(1,inobsch(lcanjo(channelIndex),sensorIndex)), channelIndex=startChannel,endChannel)
<span class="linenos">5274</span>            write(*,&quot;(1x,&#39;norm. bias&#39;,t13,18f6.2,/)&quot;) &amp;
<span class="linenos">5275</span>                 (zavgnrm(lcanjo(channelIndex),sensorIndex)/max(1,inobsch(lcanjo(channelIndex), sensorIndex)) , channelIndex=startChannel, endChannel)
<span class="linenos">5276</span>          end do
<span class="linenos">5277</span>        end if
<span class="linenos">5278</span>      end do
<span class="linenos">5279</span>    end if
<span class="linenos">5280</span>
<span class="linenos">5281</span>  end subroutine  tvs_printDetailledOmfStatistics
<span class="linenos">5282</span>
<span class="linenos">5283</span>
<span class="linenos">5284</span>  !--------------------------------------------------------------------------
<span class="linenos">5285</span>  !  tvs_getLocalChannelIndexFromChannelNumber
<span class="linenos">5286</span>  !--------------------------------------------------------------------------
<span class="linenos">5287</span>  subroutine tvs_getLocalChannelIndexFromChannelNumber(idsat,channelIndex_out,channelNumber_in)
<span class="linenos">5288</span>    !
<span class="linenos">5289</span>    !:Purpose: to get local channel index from channel number
<span class="linenos">5290</span>    !
<span class="linenos">5291</span>    implicit none
<span class="linenos">5292</span>
<span class="linenos">5293</span>    !Arguments:
<span class="linenos">5294</span>    integer, intent(in)  :: idsat            ! Satellite index
<span class="linenos">5295</span>    integer, intent(out) :: channelIndex_out ! Channel index
<span class="linenos">5296</span>    integer, intent(in)  :: channelNumber_in ! Channel number
<span class="linenos">5297</span>
<span class="linenos">5298</span>    ! Locals:
<span class="linenos">5299</span>    logical, save              :: first =.true.
<span class="linenos">5300</span>    integer                    :: channelNumber, sensorIndex, channelIndex 
<span class="linenos">5301</span>    integer, allocatable, save :: savedChannelIndexes(:,:)
<span class="linenos">5302</span>
<span class="linenos">5303</span>    if (first) then
<span class="linenos">5304</span>      allocate( savedChannelIndexes(tvs_nsensors, tvs_maxChannelNumber ) )
<span class="linenos">5305</span>      savedChannelIndexes(:,:) = -1
<span class="linenos">5306</span>      do sensorIndex = 1, tvs_nsensors
<span class="linenos">5307</span>        channels:do channelNumber = 1,  tvs_maxChannelNumber
<span class="linenos">5308</span>          indexes: do channelIndex =1, tvs_nchan(sensorIndex)
<span class="linenos">5309</span>            if ( channelNumber == tvs_ichan(channelIndex,sensorIndex) ) then
<span class="linenos">5310</span>              savedChannelIndexes(sensorIndex,channelNumber) = channelIndex
<span class="linenos">5311</span>              exit indexes
<span class="linenos">5312</span>            end if
<span class="linenos">5313</span>          end do indexes
<span class="linenos">5314</span>        end do channels
<span class="linenos">5315</span>      end do
<span class="linenos">5316</span>      first = .false.
<span class="linenos">5317</span>    end if
<span class="linenos">5318</span>
<span class="linenos">5319</span>    channelIndex_out = savedChannelIndexes(idsat,channelNumber_in)
<span class="linenos">5320</span>
<span class="linenos">5321</span>    if (channelIndex_out == -1) then
<span class="linenos">5322</span>      write(*,*) &#39;channel number requested = &#39;, channelNumber_in
<span class="linenos">5323</span>      write(*,*) &#39;idsat = &#39;, idsat
<span class="linenos">5324</span>      write(*,*) &#39;tvs_getLocalChannelIndexFromChannelNumber: warning channel not found&#39;  
<span class="linenos">5325</span>    end if
<span class="linenos">5326</span>
<span class="linenos">5327</span>  end subroutine tvs_getLocalChannelIndexFromChannelNumber
<span class="linenos">5328</span>
<span class="linenos">5329</span>
<span class="linenos">5330</span>  subroutine updateCloudInTovsProfile(sensorTovsIndexes, nlv_T, mode, beSilent)
<span class="linenos">5331</span>    !
<span class="linenos">5332</span>    !:Purpose: Modify the cloud in tvs_profiles_nl structure of rttov.
<span class="linenos">5333</span>    !
<span class="linenos">5334</span>    implicit none
<span class="linenos">5335</span>    
<span class="linenos">5336</span>    ! Arguments:
<span class="linenos">5337</span>    integer,      intent(in) :: sensorTovsIndexes(:)
<span class="linenos">5338</span>    integer,      intent(in) :: nlv_T
<span class="linenos">5339</span>    character(*), intent(in) :: mode         ! save or restore
<span class="linenos">5340</span>    logical,      intent(in) :: beSilent     ! flag to control verbosity
<span class="linenos">5341</span>
<span class="linenos">5342</span>    ! Locals:
<span class="linenos">5343</span>    integer :: profileIndex, profileCount
<span class="linenos">5344</span>    real(8), allocatable, save :: cloudProfileToStore(:,:)
<span class="linenos">5345</span>
<span class="linenos">5346</span>    if ( .not. beSilent ) write(*,*) &#39;updateCloudInTovsProfile: Starting&#39;
<span class="linenos">5347</span>    if ( .not. beSilent ) write(*,*) &#39;Memory Used: &#39;,get_max_rss()/1024,&#39;Mb&#39;
<span class="linenos">5348</span>
<span class="linenos">5349</span>    profileCount = size(sensorTovsIndexes)
<span class="linenos">5350</span>
<span class="linenos">5351</span>    if ( trim(mode) == &#39;save&#39; ) then 
<span class="linenos">5352</span>      if (allocated(cloudProfileToStore)) deallocate(cloudProfileToStore)
<span class="linenos">5353</span>      allocate(cloudProfileToStore(nlv_T,profileCount))
<span class="linenos">5354</span>
<span class="linenos">5355</span>      do profileIndex = 1, profileCount
<span class="linenos">5356</span>        cloudProfileToStore(:,profileIndex) = tvs_profiles_nl(sensorTovsIndexes(profileIndex)) % clw(:)
<span class="linenos">5357</span>        tvs_profiles_nl(sensorTovsIndexes(profileIndex)) % clw(:) = qlim_getMinValueCloud(&#39;LWCR&#39;) 
<span class="linenos">5358</span>      end do
<span class="linenos">5359</span>
<span class="linenos">5360</span>    else if ( trim(mode) == &#39;restore&#39; ) then 
<span class="linenos">5361</span>      do profileIndex = 1, profileCount
<span class="linenos">5362</span>        tvs_profiles_nl(sensorTovsIndexes(profileIndex)) % clw(:) = cloudProfileToStore(:,profileIndex)
<span class="linenos">5363</span>      end do
<span class="linenos">5364</span>
<span class="linenos">5365</span>      deallocate(cloudProfileToStore)
<span class="linenos">5366</span>
<span class="linenos">5367</span>    else
<span class="linenos">5368</span>      call utl_abort(&#39;updateCloudInTovsProfile: mode should be either &quot;save&quot; or &quot;restore&quot;&#39;)
<span class="linenos">5369</span>
<span class="linenos">5370</span>    end if
<span class="linenos">5371</span>
<span class="linenos">5372</span>  end subroutine updateCloudInTovsProfile
<span class="linenos">5373</span>
<span class="linenos">5374</span>
<span class="linenos">5375</span>  subroutine updateCloudInTovsCloudProfile(sensorTovsIndexes, nlv_T, mode, beSilent)
<span class="linenos">5376</span>    !
<span class="linenos">5377</span>    !:Purpose: Modify the cloud in tvs_cld_profiles_nl structure of rttovScatt.
<span class="linenos">5378</span>    !
<span class="linenos">5379</span>    implicit none
<span class="linenos">5380</span>    
<span class="linenos">5381</span>    ! Arguments:
<span class="linenos">5382</span>    integer,      intent(in) :: sensorTovsIndexes(:)
<span class="linenos">5383</span>    integer,      intent(in) :: nlv_T
<span class="linenos">5384</span>    character(*), intent(in) :: mode         ! save or restore
<span class="linenos">5385</span>    logical,      intent(in) :: beSilent     ! flag to control verbosity
<span class="linenos">5386</span>
<span class="linenos">5387</span>    ! Locals:
<span class="linenos">5388</span>    integer :: profileIndex, profileCount
<span class="linenos">5389</span>    real(8), allocatable, save :: rainFluxProfileToStore(:,:)
<span class="linenos">5390</span>    real(8), allocatable, save :: snowFluxProfileToStore(:,:)
<span class="linenos">5391</span>    real(8), allocatable, save :: clwProfileToStore(:,:)
<span class="linenos">5392</span>    real(8), allocatable, save :: ciwProfileToStore(:,:)
<span class="linenos">5393</span>    real(8), allocatable, save :: cloudFractionProfileToStore(:,:)
<span class="linenos">5394</span>
<span class="linenos">5395</span>    if ( .not. beSilent ) write(*,*) &#39;updateCloudInTovsCloudProfile: Starting&#39;
<span class="linenos">5396</span>    if ( .not. beSilent ) write(*,*) &#39;Memory Used: &#39;,get_max_rss()/1024,&#39;Mb&#39;
<span class="linenos">5397</span>
<span class="linenos">5398</span>    profileCount = size(sensorTovsIndexes)
<span class="linenos">5399</span>
<span class="linenos">5400</span>    if ( trim(mode) == &#39;save&#39; ) then 
<span class="linenos">5401</span>      if (allocated(rainFluxProfileToStore)) deallocate(rainFluxProfileToStore)
<span class="linenos">5402</span>      if (allocated(snowFluxProfileToStore)) deallocate(snowFluxProfileToStore)
<span class="linenos">5403</span>      if (allocated(clwProfileToStore)) deallocate(clwProfileToStore)
<span class="linenos">5404</span>      if (allocated(ciwProfileToStore)) deallocate(ciwProfileToStore)
<span class="linenos">5405</span>      if (allocated(cloudFractionProfileToStore)) deallocate(cloudFractionProfileToStore)
<span class="linenos">5406</span>      allocate(rainFluxProfileToStore(nlv_T,profileCount))
<span class="linenos">5407</span>      allocate(snowFluxProfileToStore(nlv_T,profileCount))
<span class="linenos">5408</span>      allocate(clwProfileToStore(nlv_T,profileCount))
<span class="linenos">5409</span>      allocate(ciwProfileToStore(nlv_T,profileCount))
<span class="linenos">5410</span>      allocate(cloudFractionProfileToStore(nlv_T,profileCount))
<span class="linenos">5411</span>
<span class="linenos">5412</span>      do profileIndex = 1, profileCount
<span class="linenos">5413</span>        rainFluxProfileToStore(:,profileIndex) = tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,1)
<span class="linenos">5414</span>        snowFluxProfileToStore(:,profileIndex) = tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,2)
<span class="linenos">5415</span>        clwProfileToStore(:,profileIndex) = tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,4)
<span class="linenos">5416</span>        ciwProfileToStore(:,profileIndex) = tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,5)
<span class="linenos">5417</span>        cloudFractionProfileToStore(:,profileIndex) = tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro_frac(:,1)
<span class="linenos">5418</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,1) = qlim_getMinValueCloud(&#39;RF&#39;)
<span class="linenos">5419</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,2) = qlim_getMinValueCloud(&#39;SF&#39;)
<span class="linenos">5420</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,4) = qlim_getMinValueCloud(&#39;LWCR&#39;)
<span class="linenos">5421</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,5) = qlim_getMinValueCloud(&#39;IWCR&#39;)
<span class="linenos">5422</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro_frac(:,1) = qlim_getMinValueCloud(&#39;CLDR&#39;)
<span class="linenos">5423</span>      end do
<span class="linenos">5424</span>
<span class="linenos">5425</span>    else if ( trim(mode) == &#39;restore&#39; ) then 
<span class="linenos">5426</span>      do profileIndex = 1, profileCount
<span class="linenos">5427</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,1) = rainFluxProfileToStore(:,profileIndex)
<span class="linenos">5428</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,2) = snowFluxProfileToStore(:,profileIndex)
<span class="linenos">5429</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,4) = clwProfileToStore(:,profileIndex)
<span class="linenos">5430</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro(:,5) = ciwProfileToStore(:,profileIndex)
<span class="linenos">5431</span>        tvs_cld_profiles_nl(sensorTovsIndexes(profileIndex)) % hydro_frac(:,1) = cloudFractionProfileToStore(:,profileIndex)
<span class="linenos">5432</span>      end do
<span class="linenos">5433</span>
<span class="linenos">5434</span>      deallocate(rainFluxProfileToStore)
<span class="linenos">5435</span>      deallocate(snowFluxProfileToStore)
<span class="linenos">5436</span>      deallocate(clwProfileToStore)
<span class="linenos">5437</span>      deallocate(ciwProfileToStore)
<span class="linenos">5438</span>      deallocate(cloudFractionProfileToStore)
<span class="linenos">5439</span>
<span class="linenos">5440</span>    else
<span class="linenos">5441</span>      call utl_abort(&#39;updateCloudInTovsCloudProfile: mode should be either &quot;save&quot; or &quot;restore&quot;&#39;)
<span class="linenos">5442</span>
<span class="linenos">5443</span>    end if
<span class="linenos">5444</span>
<span class="linenos">5445</span>  end subroutine updateCloudInTovsCloudProfile
<span class="linenos">5446</span>
<span class="linenos">5447</span>  !--------------------------------------------------------------------------
<span class="linenos">5448</span>  !  tvs_getChannelNumIndexFromPPP
<span class="linenos">5449</span>  !--------------------------------------------------------------------------
<span class="linenos">5450</span>  subroutine tvs_getChannelNumIndexFromPPP( obsSpaceData, headerIndex, bodyIndex, &amp;
<span class="linenos">5451</span>                                            channelNumber, channelIndex )
<span class="linenos">5452</span>    !
<span class="linenos">5453</span>    !:Purpose: Get channel number/index from obs_ppp for TO observations.
<span class="linenos">5454</span>    !
<span class="linenos">5455</span>    implicit none
<span class="linenos">5456</span>
<span class="linenos">5457</span>    ! Arguments:
<span class="linenos">5458</span>    type(struct_obs),   intent(in) :: obsSpaceData
<span class="linenos">5459</span>    integer,            intent(in) :: headerIndex
<span class="linenos">5460</span>    integer,            intent(in) :: bodyIndex
<span class="linenos">5461</span>    integer,           intent(out) :: channelNumber
<span class="linenos">5462</span>    integer,           intent(out) :: channelIndex
<span class="linenos">5463</span>
<span class="linenos">5464</span>    ! Locals:
<span class="linenos">5465</span>    integer :: tovsIndex, sensorIndex
<span class="linenos">5466</span>
<span class="linenos">5467</span>    tovsIndex = tvs_tovsIndex(headerIndex)
<span class="linenos">5468</span>    sensorIndex = tvs_lsensor(tovsIndex)
<span class="linenos">5469</span>
<span class="linenos">5470</span>    channelNumber = nint(obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex))
<span class="linenos">5471</span>    channelNumber = max( 0 , min( channelNumber , tvs_maxChannelNumber + 1))
<span class="linenos">5472</span>    channelNumber = channelNumber - tvs_channelOffset(sensorIndex)
<span class="linenos">5473</span>    channelIndex = utl_findArrayIndex(tvs_ichan(:,sensorIndex),tvs_nchan(sensorIndex),channelNumber)
<span class="linenos">5474</span>
<span class="linenos">5475</span>  end subroutine tvs_getChannelNumIndexFromPPP
<span class="linenos">5476</span>
<span class="linenos">5477</span>end module tovs_nl_mod
</pre></div>
</div>
</div></blockquote>
</section>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li><a href="../index.html">MIDAS  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2018, ECCC.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>